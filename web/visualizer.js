/**
 * Audio Spectrum Visualizer - Visualization Engine
 * Implements various visualization modes with Apple minimalist design
 */

class Visualizer {
    constructor(canvas, settings = {}) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.settings = { ...DEFAULT_SETTINGS, ...settings };

        this.centerX = canvas.width / 2;
        this.centerY = canvas.height / 2;

        // Calculate scale factor: ratio of current canvas size to target video dimensions
        // This ensures preview renders proportionally to final video
        const targetSize = Math.min(this.settings.width || 1080, this.settings.height || 1080);
        const currentSize = Math.min(canvas.width, canvas.height);
        this.scaleFactor = currentSize / targetSize;

        this.maxRadius = Math.min(canvas.width, canvas.height) / 2 - (80 * this.scaleFactor);

        this.frameCounter = 0;
        this.animationId = null;

        // Mode-specific particle systems
        this.rainParticles = [];
        this.fireworkParticles = [];

        // Mode-specific state
        this.cassetteReelAngle = 0;
    }

    /**
     * Update canvas dimensions
     */
    updateDimensions(width, height) {
        this.canvas.width = width;
        this.canvas.height = height;
        this.centerX = width / 2;
        this.centerY = height / 2;

        // Recalculate scale factor for new dimensions
        const targetSize = Math.min(this.settings.width || 1080, this.settings.height || 1080);
        const currentSize = Math.min(width, height);
        this.scaleFactor = currentSize / targetSize;

        this.maxRadius = Math.min(width, height) / 2 - (80 * this.scaleFactor);
    }

    /**
     * Get effective inner radius (scaled proportionally for all canvas sizes)
     */
    getEffectiveInnerRadius() {
        const baseInnerRadius = this.settings.innerRadius || 180;
        // Scale inner radius proportionally based on canvas size
        const effectiveRadius = baseInnerRadius * this.scaleFactor;

        if (this.frameCounter === 0) {
            console.log('[Visualizer] Scaling - baseInnerRadius:', baseInnerRadius,
                       'scaleFactor:', this.scaleFactor, 'effectiveRadius:', effectiveRadius);
        }

        return effectiveRadius;
    }

    /**
     * Update settings
     */
    updateSettings(newSettings) {
        this.settings = { ...this.settings, ...newSettings };

        // Recalculate scale factor if width/height changed
        if (newSettings.width !== undefined || newSettings.height !== undefined) {
            const targetSize = Math.min(this.settings.width || 1080, this.settings.height || 1080);
            const currentSize = Math.min(this.canvas.width, this.canvas.height);
            this.scaleFactor = currentSize / targetSize;
            this.maxRadius = Math.min(this.canvas.width, this.canvas.height) / 2 - (80 * this.scaleFactor);
        }
    }

    /**
     * Clear canvas
     */
    clear() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }

    /**
     * Draw background
     */
    drawBackground() {
        const bgStyle = BACKGROUND_STYLES[this.settings.background];
        const color = bgStyle.color;

        if (this.settings.background === 'transparent') {
            this.clear();
        } else {
            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }

        // Apply subtle vignette for non-transparent backgrounds
        if (this.settings.background !== 'transparent') {
            this.applyVignette(0.15);
        }
    }

    /**
     * Apply vignette effect
     */
    applyVignette(strength = 0.3) {
        const r2 = Math.max(10, this.maxRadius * 2);
        const gradient = this.ctx.createRadialGradient(
            this.centerX, this.centerY, 0,
            this.centerX, this.centerY, r2
        );

        gradient.addColorStop(0, `rgba(0, 0, 0, 0)`);
        gradient.addColorStop(1, `rgba(0, 0, 0, ${strength})`);

        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }

    /**
     * Parse RGB color string to array
     */
    parseRgbColor(rgbString) {
        const match = rgbString.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (match) {
            return [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];
        }
        return [255, 255, 255]; // Default to white if parsing fails
    }

    /**
     * Get color for bar index
     */
    getColor(index, total) {
        const scheme = COLOR_SCHEMES[this.settings.colorScheme];

        if (!this.settings.gradient || !scheme.gradient) {
            const color = scheme.primary;
            return `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
        }

        // Create gradient
        const t = index / total;

        // Check if we have a 3-color gradient
        if (scheme.tertiary && scheme.colorCount === 3) {
            const color1 = scheme.primary;
            const color2 = scheme.secondary;
            const color3 = scheme.tertiary;

            let r, g, b;

            if (t < 0.5) {
                // Interpolate between primary and secondary (first half)
                const t1 = t * 2; // Map 0-0.5 to 0-1
                r = Math.round(Utils.lerp(color1[0], color2[0], t1));
                g = Math.round(Utils.lerp(color1[1], color2[1], t1));
                b = Math.round(Utils.lerp(color1[2], color2[2], t1));
            } else {
                // Interpolate between secondary and tertiary (second half)
                const t2 = (t - 0.5) * 2; // Map 0.5-1 to 0-1
                r = Math.round(Utils.lerp(color2[0], color3[0], t2));
                g = Math.round(Utils.lerp(color2[1], color3[1], t2));
                b = Math.round(Utils.lerp(color2[2], color3[2], t2));
            }

            return `rgb(${r}, ${g}, ${b})`;
        } else {
            // 2-color gradient
            const color1 = scheme.primary;
            const color2 = scheme.secondary;

            const r = Math.round(Utils.lerp(color1[0], color2[0], t));
            const g = Math.round(Utils.lerp(color1[1], color2[1], t));
            const b = Math.round(Utils.lerp(color1[2], color2[2], t));

            return `rgb(${r}, ${g}, ${b})`;
        }
    }

    /**
     * Apply easing function
     */
    ease(t) {
        return ANIMATION.easing.easeOutCubic(t);
    }

    /**
     * Render frame based on mode
     */
    render(magnitudes) {
        if (!magnitudes) {
            console.error('[Visualizer] No magnitudes provided to render');
            return;
        }

        if (this.frameCounter === 0) {
            console.log('[Visualizer] === First render ===');
            console.log('[Visualizer] Mode:', this.settings.mode);
            console.log('[Visualizer] Canvas:', this.canvas.width + 'x' + this.canvas.height);
            console.log('[Visualizer] Scale factor:', this.scaleFactor);
            console.log('[Visualizer] Canvas element:', this.canvas);
            console.log('[Visualizer] Canvas context:', this.ctx);
            console.log('[Visualizer] Magnitudes length:', magnitudes.length);
            console.log('[Visualizer] Settings:', JSON.stringify(this.settings, null, 2));
        }

        this.drawBackground();

        if (this.frameCounter === 0) {
            console.log('[Visualizer] Background drawn');
        }

        const modeId = this.settings.mode;
        const mode = Object.values(VISUALIZATION_MODES).find(m => m.id === modeId);

        if (!mode) {
            console.warn('[Visualizer] Mode not found:', modeId, '- using circular_bars');
            this.renderCircularBars(magnitudes);
            return;
        }

        try {
            switch (modeId) {
                // Classic Styles
                case 'circular_bars':
                    this.renderCircularBars(magnitudes);
                    break;
            case 'waves':
                this.renderWaves(magnitudes);
                break;
            case 'smooth_waveform':
                this.renderSmoothWaveform(magnitudes);
                break;
            case 'frequency_bars':
                this.renderFrequencyBars(magnitudes);
                break;
            case 'linear_spectrum':
                this.renderLinearSpectrum(magnitudes);
                break;

            // Particle Effects
            case 'jazzy_fireworks':
                this.renderJazzyFireworks(magnitudes);
                break;
            case 'particles':
                this.renderParticles(magnitudes);
                break;
            case 'fireworks':
                this.renderFireworks(magnitudes);
                break;
            case 'cosmic_dust':
                this.renderCosmicDust(magnitudes);
                break;
            case 'particle_rain':
                this.renderParticleRain(magnitudes);
                break;
            case 'snow_particles':
                this.renderSnowParticles(magnitudes);
                break;

            // Retro & Vintage
            case 'neon_rain':
                this.renderNeonRain(magnitudes);
                break;
            case 'neon_tubes':
                this.renderNeonTubes(magnitudes);
                break;
            case 'vinyl_grooves':
                this.renderVinylGrooves(magnitudes);
                break;
            case 'pixel_clouds':
                this.renderPixelClouds(magnitudes);
                break;
            case 'neon_cityscape':
                this.renderNeonCityscape(magnitudes);
                break;

            // Fluid & Organic
            case 'soul_aura':
                this.renderSoulAura(magnitudes);
                break;
            case 'liquid_mercury':
                this.renderLiquidMercury(magnitudes);
                break;
            case 'lava_lamp':
                this.renderLavaLamp(magnitudes);
                break;
            case 'ink_drops':
                this.renderInkDrops(magnitudes);
                break;
            case 'water_ripples':
                this.renderWaterRipples(magnitudes);
                break;

            // Nature & Ethereal
            case 'aurora_waves':
                this.renderAuroraWaves(magnitudes);
                break;
            case 'crystal_growth':
                this.renderCrystalGrowth(magnitudes);
                break;
            case 'frequency_flowers':
                this.renderFrequencyFlowers(magnitudes);
                break;
            case 'fire_dance':
                this.renderFireDance(magnitudes);
                break;
            case 'bioluminescence':
                this.renderBioluminescence(magnitudes);
                break;

            // Geometric & Mathematical
            case 'mandala_growth':
                this.renderMandalaGrowth(magnitudes);
                break;
            case 'kaleidoscope':
                this.renderKaleidoscope(magnitudes);
                break;
            case 'fractal_bloom':
                this.renderFractalBloom(magnitudes);
                break;
            case 'morphing_geometry':
                this.renderMorphingGeometry(magnitudes);
                break;
            case 'spiral_galaxy':
                this.renderSpiralGalaxy(magnitudes);
                break;

            // Scientific & Physics
            case 'dna_helix':
                this.renderDnaHelix(magnitudes);
                break;
            case 'quantum_strings':
                this.renderQuantumStrings(magnitudes);
                break;
            case 'magnetic_fields':
                this.renderMagneticFields(magnitudes);
                break;
            case 'gravitational_lens':
                this.renderGravitationalLens(magnitudes);
                break;
            case 'seismic_waves':
                this.renderSeismicWaves(magnitudes);
                break;

            // Tech & Futuristic
            case 'tunnel_vision':
                this.renderTunnelVision(magnitudes);
                break;
            case 'matrix_code':
                this.renderMatrixCode(magnitudes);
                break;
            case 'hologram_glitch':
                this.renderHologramGlitch(magnitudes);
                break;
            case 'circuit_board':
                this.renderCircuitBoard(magnitudes);
                break;
            case 'neural_network':
                this.renderNeuralNetwork(magnitudes);
                break;

            // Energy & Abstract
            case 'lightning_strikes':
                this.renderLightningStrikes(magnitudes);
                break;
            case 'plasma_storm':
                this.renderPlasmaStorm(magnitudes);
                break;
            case 'laser_show':
                this.renderLaserShow(magnitudes);
                break;
            case 'energy_pulses':
                this.renderEnergyPulses(magnitudes);
                break;
            case 'rainbow_prism':
                this.renderRainbowPrism(magnitudes);
                break;

            // Extended Modes (51-60)
            case 'fractal_tree':
                this.renderFractalTree(magnitudes);
                break;
            case 'cityscape_extrusion':
                this.renderCityscapeExtrusion(magnitudes);
                break;
            case 'gravity_well':
                this.renderGravityWell(magnitudes);
                break;
            case 'metaball_fluid':
                this.renderMetaballFluid(magnitudes);
                break;
            case 'aurora_borealis':
                this.renderAuroraBorealis(magnitudes);
                break;
            case 'stained_glass':
                this.renderStainedGlass(magnitudes);
                break;
            case 'glitch_artifact':
                this.renderGlitchArtifact(magnitudes);
                break;
            case 'warp_tunnel':
                this.renderWarpTunnel(magnitudes);
                break;
            case 'conway_life':
                this.renderConwayLife(magnitudes);
                break;

            // Extended Modes (61-70)
            case 'ascii_art':
                this.renderAsciiArt(magnitudes);
                break;
            case 'rippling_water':
                this.renderRipplingWater(magnitudes);
                break;
            case 'terrain_flyover':
                this.renderTerrainFlyover(magnitudes);
                break;
            case 'string_art':
                this.renderStringArt(magnitudes);
                break;
            case 'fire_embers':
                this.renderFireEmbers(magnitudes);
                break;
            case 'radial_kaleidoscope':
                this.renderRadialKaleidoscope(magnitudes);
                break;
            case 'orbital_system':
                this.renderOrbitalSystem(magnitudes);
                break;
            case 'spectrum_cube':
                this.renderSpectrumCube(magnitudes);
                break;
            case 'typographic_flow':
                this.renderTypographicFlow(magnitudes);
                break;
            case 'sonar_ping':
                this.renderSonarPing(magnitudes);
                break;
            case 'vu_meters':
                this.renderVUMeters(magnitudes);
                break;
            case 'lightning_cloud':
                this.renderLightningCloud(magnitudes);
                break;
            case 'bouncing_balls':
                this.renderBouncingBalls(magnitudes);
                break;
            case 'liquid_ink':
                this.renderLiquidInk(magnitudes);
                break;
            case 'stereo_landscape':
                this.renderStereoLandscape(magnitudes);
                break;
            case 'ai_latent_walk':
                this.renderAILatentWalk(magnitudes);
                break;
            case 'pixel_storm':
                this.renderPixelStorm(magnitudes);
                break;
            case 'growing_vine':
                this.renderGrowingVine(magnitudes);
                break;
            case 'haunted_faces':
                this.renderHauntedFaces(magnitudes);
                break;
            case 'connecting_constellations':
                this.renderConnectingConstellations(magnitudes);
                break;
            case 'matrix_rain':
                this.renderMatrixRain(magnitudes);
                break;
            case 'voxel_world':
                this.renderVoxelWorld(magnitudes);
                break;
            case 'dna_helix_rungs':
                this.renderDNAHelixRungs(magnitudes);
                break;
            case 'audio_reactive_shader':
                this.renderAudioReactiveShader(magnitudes);
                break;
            case 'spirograph':
                this.renderSpirograph(magnitudes);
                break;
            case 'equalizer_tower':
                this.renderEqualizerTower(magnitudes);
                break;
            case 'audio_driven_doodles':
                this.renderAudioDrivenDoodles(magnitudes);
                break;
            case 'firework_show':
                this.renderFireworkShow(magnitudes);
                break;
            case 'microscopic_view':
                this.renderMicroscopicView(magnitudes);
                break;
            case 'burning_paper':
                this.renderBurningPaper(magnitudes);
                break;
            case 'swarm_intelligence':
                this.renderSwarmIntelligence(magnitudes);
                break;
            case 'pendulum_wave':
                this.renderPendulumWave(magnitudes);
                break;
            case 'retro_scanlines':
                this.renderRetroScanlines(magnitudes);
                break;
            case 'pulsing_polygon':
                this.renderPulsingPolygon(magnitudes);
                break;
            case 'chromatic_orb':
                this.renderChromaticOrb(magnitudes);
                break;
            case 'textured_bars':
                this.renderTexturedBars(magnitudes);
                break;
            case 'voronoi_tessellation':
                this.renderVoronoiTessellation(magnitudes);
                break;
            case 'shattering_glass':
                this.renderShatteringGlass(magnitudes);
                break;
            case 'sunrise_sunset':
                this.renderSunriseSunset(magnitudes);
                break;
            case 'neural_pulse':
                this.renderNeuralPulse(magnitudes);
                break;
            case 'liquid_mercury':
                this.renderLiquidMercury(magnitudes);
                break;
            case 'cosmic_strings':
                this.renderCosmicStrings(magnitudes);
                break;
            case 'particle_swarm':
                this.renderParticleSwarm(magnitudes);
                break;
            case 'crystal_lattice':
                this.renderCrystalLattice(magnitudes);
                break;

            case 'mode_106_aurora_waves':
                this.renderAuroraWaves(magnitudes);
                break;
            case 'mode_107_dna_helix':
                this.render107DnaHelix(magnitudes);
                break;
            case 'mode_108_fractal_bloom':
                this.render108FractalBloom(magnitudes);
                break;
            case 'mode_109_circuit_board':
                this.render109CircuitBoard(magnitudes);
                break;
            case 'mode_110_quantum_field':
                this.render110QuantumField(magnitudes);
                break;
            case 'mode_111_origami_unfold':
                this.render111OrigamiUnfold(magnitudes);
                break;
            case 'mode_112_galaxy_spiral':
                this.render112GalaxySpiral(magnitudes);
                break;
            case 'mode_113_rubber_bands':
                this.render113RubberBands(magnitudes);
                break;
            case 'mode_114_ink_diffusion':
                this.render114InkDiffusion(magnitudes);
                break;
            case 'mode_115_geometric_kaleidoscope':
                this.render115GeometricKaleidoscope(magnitudes);
                break;
            case 'mode_116_lightning_storm':
                this.render116LightningStorm(magnitudes);
                break;
            case 'mode_117_cellular_growth':
                this.render117CellularGrowth(magnitudes);
                break;
            case 'mode_118_sound_ribbons':
                this.render118SoundRibbons(magnitudes);
                break;
            case 'mode_119_matrix_rain':
                this.render119MatrixRain(magnitudes);
                break;
            case 'mode_120_fire_mandala':
                this.render120FireMandala(magnitudes);
                break;
            case 'mode_121_tessellation_shift':
                this.render121TessellationShift(magnitudes);
                break;
            case 'mode_122_seismic_waves':
                this.render122SeismicWaves(magnitudes);
                break;
            case 'mode_123_neon_city':
                this.render123NeonCity(magnitudes);
                break;
            case 'mode_124_magnetic_field':
                this.render124MagneticField(magnitudes);
                break;
            case 'mode_125_bubble_fusion':
                this.render125BubbleFusion(magnitudes);
                break;
            case 'mode_126_tribal_drums':
                this.render126TribalDrums(magnitudes);
                break;
            case 'mode_127_glass_shatter':
                this.render127GlassShatter(magnitudes);
                break;
            case 'mode_128_bioluminescence':
                this.render128Bioluminescence(magnitudes);
                break;
            case 'mode_129_sound_architecture':
                this.render129SoundArchitecture(magnitudes);
                break;
            case 'mode_130_plasma_ball':
                this.render130PlasmaBall(magnitudes);
                break;
            case 'mode_131_sand_mandala':
                this.render131SandMandala(magnitudes);
                break;
            case 'mode_132_laser_show':
                this.render132LaserShow(magnitudes);
                break;
            case 'mode_133_coral_reef':
                this.render133CoralReef(magnitudes);
                break;
            case 'mode_134_wireframe_morph':
                this.render134WireframeMorph(magnitudes);
                break;
            case 'mode_135_sound_garden':
                this.render135SoundGarden(magnitudes);
                break;
            case 'mode_136_hologram_glitch':
                this.render136HologramGlitch(magnitudes);
                break;
            case 'mode_137_pendulum_wave':
                this.render137PendulumWave(magnitudes);
                break;
            case 'mode_138_volcano_eruption':
                this.render138VolcanoEruption(magnitudes);
                break;
            case 'mode_139_butterfly_effect':
                this.render139ButterflyEffect(magnitudes);
                break;
            case 'mode_140_silk_weaving':
                this.render140SilkWeaving(magnitudes);
                break;
            case 'mode_141_clock_gears':
                this.render141ClockGears(magnitudes);
                break;
            case 'mode_142_smoke_signals':
                this.render142SmokeSignals(magnitudes);
                break;
            case 'mode_143_stained_glass':
                this.render143StainedGlass(magnitudes);
                break;
            case 'mode_144_string_theory':
                this.render144StringTheory(magnitudes);
                break;
            case 'mode_145_paper_craft':
                this.render145PaperCraft(magnitudes);
                break;
            case 'mode_146_northern_lights':
                this.render146NorthernLights(magnitudes);
                break;
            case 'mode_147_cellular_automata':
                this.render147CellularAutomata(magnitudes);
                break;
            case 'mode_148_dragon_curve':
                this.render148DragonCurve(magnitudes);
                break;
            case 'mode_149_rain_circles':
                this.render149RainCircles(magnitudes);
                break;
            case 'mode_150_fourier_epicycles':
                this.render150FourierEpicycles(magnitudes);
                break;
            case 'mode_151_neon_halo_burst':
                this.render151NeonHaloBurst(magnitudes);
                break;
            case 'mode_152_twin_orbiters':
                this.render152TwinOrbiters(magnitudes);
                break;
            case 'mode_153_bar_spiral_galaxy':
                this.render153BarSpiralGalaxy(magnitudes);
                break;
            case 'mode_154_ribbon_wave':
                this.render154RibbonWave(magnitudes);
                break;
            case 'mode_155_voxel_city':
                this.render155VoxelCity(magnitudes);
                break;
            case 'mode_156_sunburst_dial':
                this.render156SunburstDial(magnitudes);
                break;
            case 'mode_157_waterline_oscilloscope':
                this.render157WaterlineOscilloscope(magnitudes);
                break;
            case 'mode_158_laser_tunnel':
                this.render158LaserTunnel(magnitudes);
                break;
            case 'mode_159_vector_field_sprites':
                this.render159VectorFieldSprites(magnitudes);
                break;
            case 'mode_160_orbit_rings_meter':
                this.render160OrbitRingsMeter(magnitudes);
                break;
            case 'mode_161_stitch_bars':
                this.render161StitchBars(magnitudes);
                break;
            case 'mode_162_aurora_curtain':
                this.render162AuroraCurtain(magnitudes);
                break;
            case 'mode_164_polygon_heartbeat':
                this.render164PolygonHeartbeat(magnitudes);
                break;
            case 'mode_165_confetti_impulse':
                this.render165ConfettiImpulse(magnitudes);
                break;
            case 'mode_166_wireframe_dome':
                this.render166WireframeDome(magnitudes);
                break;
            case 'mode_167_pulse_dashes':
                this.render167PulseDashes(magnitudes);
                break;
            case 'mode_168_terrain_sweep':
                this.render168TerrainSweep(magnitudes);
                break;
            case 'mode_169_chromatic_bars_mirror':
                this.render169ChromaticBarsMirror(magnitudes);
                break;
            case 'mode_170_bubble_choir':
                this.render170BubbleChoir(magnitudes);
                break;
            case 'mode_171_starfield_quantizer':
                this.render171StarfieldQuantizer(magnitudes);
                break;
            case 'mode_172_dna_ladder':
                this.render172DnaLadder(magnitudes);
                break;
            case 'mode_173_arc_meter_trio':
                this.render173ArcMeterTrio(magnitudes);
                break;
            case 'mode_174_ink_splatter_scope':
                this.render174InkSplatterScope(magnitudes);
                break;
            case 'mode_175_hex_cell_bloom':
                this.render175HexCellBloom(magnitudes);
                break;
            case 'mode_176_event_horizon_lattice':
                this.render176EventHorizonLattice(magnitudes);
                break;
            case 'mode_177_comet_conveyor':
                this.render177CometConveyor(magnitudes);
                break;
            case 'mode_178_quantum_foam_micro':
                this.render178QuantumFoamMicro(magnitudes);
                break;
            case 'mode_179_aurora_crown':
                this.render179AuroraCrown(magnitudes);
                break;
            case 'mode_180_asteroid_excavator':
                this.render180AsteroidExcavator(magnitudes);
                break;
            case 'mode_181_hyperloop_spectrotrain':
                this.render181HyperloopSpectrotrain(magnitudes);
                break;
            case 'mode_182_galactic_pinball':
                this.render182GalacticPinball(magnitudes);
                break;
            case 'mode_183_nebula_inkblot':
                this.render183NebulaInkblot(magnitudes);
                break;
            case 'mode_184_satellite_telemetry_rings':
                this.render184SatelliteTelemetryRings(magnitudes);
                break;
            case 'mode_185_wormhole_origami':
                this.render185WormholeOrigami(magnitudes);
                break;
            case 'mode_186_holographic_jellyfish':
                this.render186HolographicJellyfish(magnitudes);
                break;
            case 'mode_187_moon_quarry_crane':
                this.render187MoonQuarryCrane(magnitudes);
                break;
            case 'mode_188_constellation_typoplot':
                this.render188ConstellationTypoplot(magnitudes);
                break;
            case 'mode_189_cryo_crystal_garden':
                this.render189CryoCrystalGarden(magnitudes);
                break;
            case 'mode_190_meteorite_blueprint':
                this.render190MeteoriteBlueprint(magnitudes);
                break;
            case 'mode_191_lunar_tide_pool':
                this.render191LunarTidePool(magnitudes);
                break;
            case 'mode_192_orbital_barcode_slicer':
                this.render192OrbitalBarcodeSlicer(magnitudes);
                break;
            case 'mode_193_satellite_swarm_flocking':
                this.render193SatelliteSwarmFlocking(magnitudes);
                break;
            case 'mode_194_astro_pulse_weave':
                this.render194AstroPulseWeave(magnitudes);
                break;
            case 'mode_195_zero_g_paint_spheres':
                this.render195ZeroGPaintSpheres(magnitudes);
                break;
            case 'mode_196_supernova_countdown':
                this.render196SupernovaCountdown(magnitudes);
                break;
            case 'mode_197_martian_wind_harp':
                this.render197MartianWindHarp(magnitudes);
                break;
            case 'mode_198_teleporting_bar_choir':
                this.render198TeleportingBarChoir(magnitudes);
                break;
            case 'mode_199_cosmic_vinyl_halo':
                this.render199CosmicVinylHalo(magnitudes);
                break;
            case 'mode_200_photon_origination_chamber':
                this.render200PhotonOriginationChamber(magnitudes);
                break;
            case 'mode_201_meteor_net':
                this.render201Meteornet(magnitudes);
                break;
            case 'mode_202_deep_space_garden_hose':
                this.render202DeepSpaceGardenHose(magnitudes);
                break;
            case 'mode_203_horizon_monoliths':
                this.render203HorizonMonoliths(magnitudes);
                break;
            case 'mode_204_gravity_slingshot_trails':
                this.render204GravitySlingshotTrails(magnitudes);
                break;
            case 'mode_205_solar_flare_notches':
                this.render205SolarFlareNotches(magnitudes);
                break;
            case 'mode_206_tesseract_window':
                this.render206TesseractWindow(magnitudes);
                break;
            case 'mode_207_interstellar_postcards':
                this.render207InterstellarPostcards(magnitudes);
                break;
            case 'mode_208_cosmic_braille':
                this.render208CosmicBraille(magnitudes);
                break;
            case 'mode_209_stellar_harpoon':
                this.render209StellarHarpoon(magnitudes);
                break;
            case 'mode_210_galaxy_ticker_tape':
                this.render210GalaxyTickerTape(magnitudes);
                break;
            case 'mode_211_antimatter_chess':
                this.render211AntimatterChess(magnitudes);
                break;
            case 'mode_212_star_nursery_conveyor':
                this.render212StarNurseryConveyor(magnitudes);
                break;
            case 'mode_213_magnetar_lines':
                this.render213MagnetarLines(magnitudes);
                break;
            case 'mode_214_zero_kelvin_diamonds':
                this.render214ZeroKelvinDiamonds(magnitudes);
                break;
            case 'mode_215_orbital_time_garden':
                this.render215OrbitalTimeGarden(magnitudes);
                break;
            case 'mode_216_subspace_ribbon_printer':
                this.render216SubspaceRibbonPrinter(magnitudes);
                break;
            case 'mode_217_dark_matter_drizzle':
                this.render217DarkMatterDrizzle(magnitudes);
                break;
            case 'mode_218_meteor_choir_cones':
                this.render218MeteorChoirCones(magnitudes);
                break;
            case 'mode_219_folded_galaxy_map':
                this.render219FoldedGalaxyMap(magnitudes);
                break;
            case 'mode_220_ion_thruster_plume':
                this.render220IonThrusterPlume(magnitudes);
                break;
            case 'mode_221_cosmic_dominoes':
                this.render221CosmicDominoes(magnitudes);
                break;
            case 'mode_222_spacesuit_hud':
                this.render222SpacesuitHud(magnitudes);
                break;
            case 'mode_223_pulsar_barcode_beam':
                this.render223PulsarBarcodeBeam(magnitudes);
                break;
            case 'mode_224_astro_terrarium':
                this.render224AstroTerrarium(magnitudes);
                break;
            case 'mode_225_micrometeor_spark_curtain':
                this.render225MicrometeorSparkCurtain(magnitudes);
                break;
            case 'mode_276_quantum_lattice':
                this.render276QuantumLattice(magnitudes);
                break;
            case 'mode_277_prism_rays':
                this.render277PrismRays(magnitudes);
                break;
            case 'mode_278_liquid_nitrogen':
                this.render278LiquidNitrogen(magnitudes);
                break;
            case 'mode_279_silk_road_caravan':
                this.render279SilkRoadCaravan(magnitudes);
                break;
            case 'mode_280_steampunk_gears':
                this.render280SteampunkGears(magnitudes);
                break;
            case 'mode_281_dragon_scales':
                this.render281DragonScales(magnitudes);
                break;
            case 'mode_282_time_dilation_grid':
                this.render282TimeDilationGrid(magnitudes);
                break;
            case 'mode_283_fiber_bundle':
                this.render283FiberBundle(magnitudes);
                break;
            case 'mode_284_moth_wing_shimmer':
                this.render284MothWingShimmer(magnitudes);
                break;
            case 'mode_285_cathedral_rose':
                this.render285CathedralRose(magnitudes);
                break;
            case 'mode_286_neon_veins_pulse':
                this.render286NeonVeinsPulse(magnitudes);
                break;
            case 'mode_287_glacial_crack':
                this.render287GlacialCrack(magnitudes);
                break;
            case 'mode_288_quantum_dots':
                this.render288QuantumDots(magnitudes);
                break;
            case 'mode_289_origami_crane_flight':
                this.render289OrigamiCraneFlight(magnitudes);
                break;
            case 'mode_290_magma_chamber':
                this.render290MagmaChamber(magnitudes);
                break;
            case 'mode_291_spider_web_dew':
                this.render291SpiderWebDew(magnitudes);
                break;
            case 'mode_292_nebula_birth':
                this.render292NebulaBirth(magnitudes);
                break;
            case 'mode_293_circuit_board_live':
                this.render293CircuitBoardLive(magnitudes);
                break;
            case 'mode_294_bioluminescent_tide':
                this.render294BioluminescentTide(magnitudes);
                break;
            case 'mode_295_tesseract_projection':
                this.render295TesseractProjection(magnitudes);
                break;
            case 'mode_296_frost_crystal_growth':
                this.render296FrostCrystalGrowth(magnitudes);
                break;
            case 'mode_297_sound_wave_interference':
                this.render297SoundWaveInterference(magnitudes);
                break;
            case 'mode_298_holographic_fracture':
                this.render298HolographicFracture(magnitudes);
                break;
            case 'mode_299_plasma_ball_arc':
                this.render299PlasmaBallArc(magnitudes);
                break;
            case 'mode_300_eternal_flame_dance':
                this.render300EternalFlameDance(magnitudes);
                break;
            case 'mode_301_forest_canopy':
                this.render301ForestCanopy(magnitudes);
                break;
            case 'mode_302_ocean_waves':
                this.render302OceanWaves(magnitudes);
                break;
            case 'mode_303_coral_reef':
                this.render303CoralReef(magnitudes);
                break;
            case 'mode_304_butterfly_swarm':
                this.render304ButterflySwarm(magnitudes);
                break;
            case 'mode_305_mountain_peaks':
                this.render305MountainPeaks(magnitudes);
                break;
            case 'mode_306_fireflies':
                this.render306Fireflies(magnitudes);
                break;
            case 'mode_307_flower_bloom':
                this.render307FlowerBloom(magnitudes);
                break;
            case 'mode_308_rain_ripples':
                this.render308RainRipples(magnitudes);
                break;
            case 'mode_309_leaf_fall':
                this.render309LeafFall(magnitudes);
                break;
            case 'mode_310_tree_rings':
                this.render310TreeRings(magnitudes);
                break;
            case 'mode_311_lightning_storm':
                this.render311LightningStorm(magnitudes);
                break;
            case 'mode_312_pond_koi':
                this.render312PondKoi(magnitudes);
                break;
            case 'mode_313_moss_growth':
                this.render313MossGrowth(magnitudes);
                break;
            case 'mode_314_aurora_forest':
                this.render314AuroraForest(magnitudes);
                break;
            case 'mode_315_dandelion_seeds':
                this.render315DandelionSeeds(magnitudes);
                break;
            case 'mode_316_fern_fractals':
                this.render316FernFractals(magnitudes);
                break;
            case 'mode_317_beehive_cells':
                this.render317BeehiveCells(magnitudes);
                break;
            case 'mode_318_wheat_field':
                this.render318WheatField(magnitudes);
                break;
            case 'mode_319_spider_web':
                this.render319SpiderWeb(magnitudes);
                break;
            case 'mode_320_mushroom_spores':
                this.render320MushroomSpores(magnitudes);
                break;
            case 'mode_321_bamboo_forest':
                this.render321BambooForest(magnitudes);
                break;
            case 'mode_322_tide_pools':
                this.render322TidePools(magnitudes);
                break;
            case 'mode_323_vine_tendrils':
                this.render323VineTendrils(magnitudes);
                break;
            case 'mode_324_crystal_cave':
                this.render324CrystalCave(magnitudes);
                break;
            case 'mode_325_bird_murmuration':
                this.render325BirdMurmuration(magnitudes);
                break;
            case 'mode_326_river_flow':
                this.render326RiverFlow(magnitudes);
                break;
            case 'mode_327_seed_pods':
                this.render327SeedPods(magnitudes);
                break;
            case 'mode_328_algae_bloom':
                this.render328AlgaeBloom(magnitudes);
                break;
            case 'mode_329_cactus_spines':
                this.render329CactusSpines(magnitudes);
                break;
            case 'mode_330_snowflakes':
                this.render330Snowflakes(magnitudes);
                break;
            case 'mode_331_lava_flow':
                this.render331LavaFlow(magnitudes);
                break;
            case 'mode_332_ice_crystals':
                this.render332IceCrystals(magnitudes);
                break;
            case 'mode_333_pine_cones':
                this.render333PineCones(magnitudes);
                break;
            case 'mode_334_geyser_eruption':
                this.render334GeyserEruption(magnitudes);
                break;
            case 'mode_335_pollen_cloud':
                this.render335PollenCloud(magnitudes);
                break;
            case 'mode_336_desert_dunes':
                this.render336DesertDunes(magnitudes);
                break;
            case 'mode_337_lily_pads':
                this.render337LilyPads(magnitudes);
                break;
            case 'mode_338_termite_mound':
                this.render338TermiteMound(magnitudes);
                break;
            case 'mode_339_cherry_blossoms':
                this.render339CherryBlossoms(magnitudes);
                break;
            case 'mode_340_root_system':
                this.render340RootSystem(magnitudes);
                break;
            case 'mode_341_plankton_swarm':
                this.render341PlanktonSwarm(magnitudes);
                break;
            case 'mode_342_frost_patterns':
                this.render342FrostPatterns(magnitudes);
                break;
            case 'mode_343_ant_trails':
                this.render343AntTrails(magnitudes);
                break;
            case 'mode_344_seaweed_sway':
                this.render344SeaweedSway(magnitudes);
                break;
            case 'mode_345_volcano_ash':
                this.render345VolcanoAsh(magnitudes);
                break;
            case 'mode_346_dragonfly_wings':
                this.render346DragonflyWings(magnitudes);
                break;
            case 'mode_347_pebble_ripples':
                this.render347PebbleRipples(magnitudes);
                break;
            case 'mode_348_moss_tendrils':
                this.render348MossTendrils(magnitudes);
                break;
            case 'mode_349_starfish_arms':
                this.render349StarfishArms(magnitudes);
                break;
            case 'mode_350_venus_flytrap':
                this.render350VenusFlytrap(magnitudes);
                break;
            case 'mode_351_rainbow_mist':
                this.render351RainbowMist(magnitudes);
                break;
            case 'mode_352_geode_crystals':
                this.render352GeodeCrystals(magnitudes);
                break;
            case 'mode_353_snake_scales':
                this.render353SnakeScales(magnitudes);
                break;
            case 'mode_354_whirlpool':
                this.render354Whirlpool(magnitudes);
                break;
            case 'mode_355_owl_eyes':
                this.render355OwlEyes(magnitudes);
                break;
            case 'mode_356_tornado_funnel':
                this.render356TornadoFunnel(magnitudes);
                break;
            case 'mode_357_peacock_feathers':
                this.render357PeacockFeathers(magnitudes);
                break;
            case 'mode_358_jellyfish_pulse':
                this.render358JellyfishPulse(magnitudes);
                break;
            case 'mode_359_sand_ripples':
                this.render359SandRipples(magnitudes);
                break;
            case 'mode_360_bat_swarm':
                this.render360BatSwarm(magnitudes);
                break;
            case 'mode_361_tide_motion':
                this.render361TideMotion(magnitudes);
                break;
            case 'mode_362_lichen_growth':
                this.render362LichenGrowth(magnitudes);
                break;
            case 'mode_363_eagle_soar':
                this.render363EagleSoar(magnitudes);
                break;
            case 'mode_364_mangrove_roots':
                this.render364MangroveRoots(magnitudes);
                break;
            case 'mode_365_aurora_waves':
                this.render365AuroraWaves(magnitudes);
                break;
            case 'mode_366_dolphin_leap':
                this.render366DolphinLeap(magnitudes);
                break;
            case 'mode_367_tumbleweed_roll':
                this.render367TumbleweedRoll(magnitudes);
                break;
            case 'mode_368_coral_polyps':
                this.render368CoralPolyps(magnitudes);
                break;
            case 'mode_369_smoke_wisps':
                this.render369SmokeWisps(magnitudes);
                break;
            case 'mode_370_nautilus_shell':
                this.render370NautilusShell(magnitudes);
                break;
            case 'mode_371_wolf_howl':
                this.render371WolfHowl(magnitudes);
                break;
            case 'mode_372_seashell_patterns':
                this.render372SeashellPatterns(magnitudes);
                break;
            case 'mode_373_grass_blades':
                this.render373GrassBlades(magnitudes);
                break;
            case 'mode_374_stalactites':
                this.render374Stalactites(magnitudes);
                break;
            case 'mode_375_amoeba_movement':
                this.render375AmoebaMovement(magnitudes);
                break;
            case 'mode_376_pine_needles':
                this.render376PineNeedles(magnitudes);
                break;
            case 'mode_377_water_droplet':
                this.render377WaterDroplet(magnitudes);
                break;
            case 'mode_378_succulent_rosette':
                this.render378SucculentRosette(magnitudes);
                break;
            case 'mode_379_salmon_upstream':
                this.render379SalmonUpstream(magnitudes);
                break;
            case 'mode_380_cloud_formation':
                this.render380CloudFormation(magnitudes);
                break;
            case 'mode_381_fox_tail':
                this.render381FoxTail(magnitudes);
                break;
            case 'mode_382_clover_field':
                this.render382CloverField(magnitudes);
                break;
            case 'mode_383_geyser_field':
                this.render383GeyserField(magnitudes);
                break;
            case 'mode_384_insect_compound_eye':
                this.render384InsectCompoundEye(magnitudes);
                break;
            case 'mode_385_moonflower_bloom':
                this.render385MoonflowerBloom(magnitudes);
                break;
            case 'mode_386_sand_dollar':
                this.render386SandDollar(magnitudes);
                break;
            case 'mode_387_glacier_crevasse':
                this.render387GlacierCrevasse(magnitudes);
                break;
            case 'mode_388_antler_growth':
                this.render388AntlerGrowth(magnitudes);
                break;
            case 'mode_389_plume_worm':
                this.render389PlumeWorm(magnitudes);
                break;
            case 'mode_390_reed_marsh':
                this.render390ReedMarsh(magnitudes);
                break;
            case 'mode_391_beetle_shell':
                this.render391BeetleShell(magnitudes);
                break;
            case 'mode_392_tide_anemone':
                this.render392TideAnemone(magnitudes);
                break;
            case 'mode_393_earthquake_waves':
                this.render393EarthquakeWaves(magnitudes);
                break;
            case 'mode_394_butterfly_lifecycle':
                this.render394ButterflyLifecycle(magnitudes);
                break;
            case 'mode_395_coconut_palm':
                this.render395CoconutPalm(magnitudes);
                break;
            case 'mode_396_frost_ferns':
                this.render396FrostFerns(magnitudes);
                break;
            case 'mode_397_bioluminescent_bay':
                this.render397BioluminescentBay(magnitudes);
                break;
            case 'mode_398_erosion_patterns':
                this.render398ErosionPatterns(magnitudes);
                break;
            case 'mode_399_hedge_maze':
                this.render399HedgeMaze(magnitudes);
                break;
            case 'mode_400_water_lily_reflection':
                this.render400WaterLilyReflection(magnitudes);
                break;
            case 'mode_401_atom_model':
                this.render401AtomModel(magnitudes);
                break;
            case 'mode_402_double_helix':
                this.render402DoubleHelix(magnitudes);
                break;
            case 'mode_403_magnetic_field':
                this.render403MagneticField(magnitudes);
                break;
            case 'mode_404_wave_interference':
                this.render404WaveInterference(magnitudes);
                break;
            case 'mode_405_particle_accelerator':
                this.render405ParticleAccelerator(magnitudes);
                break;
            case 'mode_406_crystal_lattice':
                this.render406CrystalLattice(magnitudes);
                break;
            case 'mode_407_electromagnetic_wave':
                this.render407ElectromagneticWave(magnitudes);
                break;
            case 'mode_408_quantum_tunneling':
                this.render408QuantumTunneling(magnitudes);
                break;
            case 'mode_409_fission_reaction':
                this.render409FissionReaction(magnitudes);
                break;
            case 'mode_410_doppler_effect':
                this.render410DopplerEffect(magnitudes);
                break;
            case 'mode_411_gravity_well':
                this.render411GravityWell(magnitudes);
                break;
            case 'mode_412_prism_spectrum':
                this.render412PrismSpectrum(magnitudes);
                break;
            case 'mode_413_molecular_bonds':
                this.render413MolecularBonds(magnitudes);
                break;
            case 'mode_414_standing_wave':
                this.render414StandingWave(magnitudes);
                break;
            case 'mode_415_brownian_motion':
                this.render415BrownianMotion(magnitudes);
                break;
            case 'mode_416_tesla_coil':
                this.render416TeslaCoil(magnitudes);
                break;
            case 'mode_417_phase_transition':
                this.render417PhaseTransition(magnitudes);
                break;
            case 'mode_418_superconductor':
                this.render418Superconductor(magnitudes);
                break;
            case 'mode_419_neuron_firing':
                this.render419NeuronFiring(magnitudes);
                break;
            case 'mode_420_resonance_modes':
                this.render420ResonanceModes(magnitudes);
                break;
            case 'mode_421_fractal_diffusion':
                this.render421FractalDiffusion(magnitudes);
                break;
            case 'mode_422_plasma_ball':
                this.render422PlasmaBall(magnitudes);
                break;
            case 'mode_423_coriolis_effect':
                this.render423CoriolisEffect(magnitudes);
                break;
            case 'mode_424_photoelectric_effect':
                this.render424PhotoelectricEffect(magnitudes);
                break;
            case 'mode_425_lorenz_attractor':
                this.render425LorenzAttractor(magnitudes);
                break;
            case 'mode_426_spin_precession':
                this.render426SpinPrecession(magnitudes);
                break;
            case 'mode_427_compton_scattering':
                this.render427ComptonScattering(magnitudes);
                break;
            case 'mode_428_ferrofluid':
                this.render428Ferrofluid(magnitudes);
                break;
            case 'mode_429_sonoluminescence':
                this.render429Sonoluminescence(magnitudes);
                break;
            case 'mode_430_cherenkov_radiation':
                this.render430CherenkovRadiation(magnitudes);
                break;
            case 'mode_431_hall_effect':
                this.render431HallEffect(magnitudes);
                break;
            case 'mode_432_cymatics':
                this.render432Cymatics(magnitudes);
                break;
            case 'mode_433_klein_bottle':
                this.render433KleinBottle(magnitudes);
                break;
            case 'mode_434_raman_scattering':
                this.render434RamanScattering(magnitudes);
                break;
            case 'mode_435_vortex_shedding':
                this.render435VortexShedding(magnitudes);
                break;
            case 'mode_436_polarization':
                this.render436Polarization(magnitudes);
                break;
            case 'mode_437_higgs_field':
                this.render437HiggsField(magnitudes);
                break;
            case 'mode_438_bose_einstein':
                this.render438BoseEinstein(magnitudes);
                break;
            case 'mode_439_schrodinger_cat':
                this.render439SchrodingerCat(magnitudes);
                break;
            case 'mode_440_string_vibration':
                this.render440StringVibration(magnitudes);
                break;
            case 'mode_441_electron_cloud':
                this.render441ElectronCloud(magnitudes);
                break;
            case 'mode_442_thermoelectric':
                this.render442Thermoelectric(magnitudes);
                break;
            case 'mode_443_photon_entanglement':
                this.render443PhotonEntanglement(magnitudes);
                break;
            case 'mode_444_superfluidity':
                this.render444Superfluidity(magnitudes);
                break;
            case 'mode_445_piezoelectric':
                this.render445Piezoelectric(magnitudes);
                break;
            case 'mode_446_zeeman_effect':
                this.render446ZeemanEffect(magnitudes);
                break;
            case 'mode_447_cyclotron_motion':
                this.render447CyclotronMotion(magnitudes);
                break;
            case 'mode_448_fusion_reactor':
                this.render448FusionReactor(magnitudes);
                break;
            case 'mode_449_antimatter':
                this.render449Antimatter(magnitudes);
                break;
            case 'mode_450_hawking_radiation':
                this.render450HawkingRadiation(magnitudes);
                break;
            case 'mode_451_heisenberg_uncertainty':
                this.render451HeisenbergUncertainty(magnitudes);
                break;
            case 'mode_452_particle_decay':
                this.render452ParticleDecay(magnitudes);
                break;
            case 'mode_453_laser_cavity':
                this.render453LaserCavity(magnitudes);
                break;
            case 'mode_454_dielectric_breakdown':
                this.render454DielectricBreakdown(magnitudes);
                break;
            case 'mode_455_casimir_effect':
                this.render455CasimirEffect(magnitudes);
                break;
            case 'mode_456_sonochemistry':
                this.render456Sonochemistry(magnitudes);
                break;
            case 'mode_457_phonon_propagation':
                this.render457PhononPropagation(magnitudes);
                break;
            case 'mode_458_pair_production':
                this.render458PairProduction(magnitudes);
                break;
            case 'mode_459_stefan_boltzmann':
                this.render459StefanBoltzmann(magnitudes);
                break;
            case 'mode_460_eddy_currents':
                this.render460EddyCurrents(magnitudes);
                break;
            case 'mode_461_wavefunction_collapse':
                this.render461WavefunctionCollapse(magnitudes);
                break;
            case 'mode_462_qed_feynman':
                this.render462QedFeynman(magnitudes);
                break;
            case 'mode_463_holography':
                this.render463Holography(magnitudes);
                break;
            case 'mode_464_metamaterial':
                this.render464Metamaterial(magnitudes);
                break;
            case 'mode_465_photodiode':
                this.render465Photodiode(magnitudes);
                break;
            case 'mode_466_bremsstrahlung':
                this.render466Bremsstrahlung(magnitudes);
                break;
            case 'mode_467_optogenetics':
                this.render467Optogenetics(magnitudes);
                break;
            case 'mode_468_topological_insulator':
                this.render468TopologicalInsulator(magnitudes);
                break;
            case 'mode_469_nernst_equation':
                this.render469NernstEquation(magnitudes);
                break;
            case 'mode_470_mri_precession':
                this.render470MriPrecession(magnitudes);
                break;
            case 'mode_471_josephson_junction':
                this.render471JosephsonJunction(magnitudes);
                break;
            case 'mode_472_liquid_crystal':
                this.render472LiquidCrystal(magnitudes);
                break;
            case 'mode_473_rydberg_atoms':
                this.render473RydbergAtoms(magnitudes);
                break;
            case 'mode_474_cavity_qed':
                this.render474CavityQed(magnitudes);
                break;
            case 'mode_475_quantum_dots':
                this.render475QuantumDots(magnitudes);
                break;
            case 'mode_476_soliton_wave':
                this.render476SolitonWave(magnitudes);
                break;
            case 'mode_477_acoustic_levitation':
                this.render477AcousticLevitation(magnitudes);
                break;
            case 'mode_478_mosfet_channel':
                this.render478MosfetChannel(magnitudes);
                break;
            case 'mode_479_spintronics':
                this.render479Spintronics(magnitudes);
                break;
            case 'mode_480_electrochemistry':
                this.render480Electrochemistry(magnitudes);
                break;
            case 'mode_481_langmuir_wave':
                this.render481LangmuirWave(magnitudes);
                break;
            case 'mode_482_bloch_sphere':
                this.render482BlochSphere(magnitudes);
                break;
            case 'mode_483_curie_temperature':
                this.render483CurieTemperature(magnitudes);
                break;
            case 'mode_484_dyson_sphere':
                this.render484DysonSphere(magnitudes);
                break;
            case 'mode_485_graphene_lattice':
                this.render485GrapheneLattice(magnitudes);
                break;
            case 'mode_486_memristor':
                this.render486Memristor(magnitudes);
                break;
            case 'mode_487_quantum_hall':
                this.render487QuantumHall(magnitudes);
                break;
            case 'mode_488_optomechanics':
                this.render488Optomechanics(magnitudes);
                break;
            case 'mode_489_exciton':
                this.render489Exciton(magnitudes);
                break;
            case 'mode_490_photonic_crystal':
                this.render490PhotonicCrystal(magnitudes);
                break;
            case 'mode_491_skyrmion':
                this.render491Skyrmion(magnitudes);
                break;
            case 'mode_492_mott_insulator':
                this.render492MottInsulator(magnitudes);
                break;
            case 'mode_493_squeezing':
                this.render493Squeezing(magnitudes);
                break;
            case 'mode_494_andreev_reflection':
                this.render494AndreevReflection(magnitudes);
                break;
            case 'mode_495_casimir_polder':
                this.render495CasimirPolder(magnitudes);
                break;
            case 'mode_496_fano_resonance':
                this.render496FanoResonance(magnitudes);
                break;
            case 'mode_497_quantum_zeno':
                this.render497QuantumZeno(magnitudes);
                break;
            case 'mode_498_rabi_oscillation':
                this.render498RabiOscillation(magnitudes);
                break;
            case 'mode_499_aharonov_bohm':
                this.render499AharonovBohm(magnitudes);
                break;
            case 'mode_500_berry_phase':
                this.render500BerryPhase(magnitudes);
                break;
            case 'mode_501_impressionist':
                this.render501Impressionist(magnitudes);
                break;
            case 'mode_502_cubist':
                this.render502Cubist(magnitudes);
                break;
            case 'mode_503_surreal':
                this.render503Surreal(magnitudes);
                break;
            case 'mode_504_abstract_expressionist':
                this.render504AbstractExpressionist(magnitudes);
                break;
            case 'mode_505_pop_art':
                this.render505PopArt(magnitudes);
                break;
            case 'mode_506_minimalist':
                this.render506Minimalist(magnitudes);
                break;
            case 'mode_507_pointillist':
                this.render507Pointillist(magnitudes);
                break;
            case 'mode_508_art_deco':
                this.render508ArtDeco(magnitudes);
                break;
            case 'mode_509_art_nouveau':
                this.render509ArtNouveau(magnitudes);
                break;
            case 'mode_510_bauhaus':
                this.render510Bauhaus(magnitudes);
                break;
            case 'mode_511_futurist':
                this.render511Futurist(magnitudes);
                break;
            case 'mode_512_dadaist':
                this.render512Dadaist(magnitudes);
                break;
            case 'mode_513_expressionist':
                this.render513Expressionist(magnitudes);
                break;
            case 'mode_514_fauvism':
                this.render514Fauvism(magnitudes);
                break;
            case 'mode_515_constructivist':
                this.render515Constructivist(magnitudes);
                break;
            case 'mode_516_suprematist':
                this.render516Suprematist(magnitudes);
                break;
            case 'mode_517_vorticism':
                this.render517Vorticism(magnitudes);
                break;
            case 'mode_518_orphism':
                this.render518Orphism(magnitudes);
                break;
            case 'mode_519_rayonism':
                this.render519Rayonism(magnitudes);
                break;
            case 'mode_520_synchromism':
                this.render520Synchromism(magnitudes);
                break;
            case 'mode_521_precisionism':
                this.render521Precisionism(magnitudes);
                break;
            case 'mode_522_regionalism':
                this.render522Regionalism(magnitudes);
                break;
            case 'mode_523_social_realism':
                this.render523SocialRealism(magnitudes);
                break;
            case 'mode_524_neo_plasticism':
                this.render524NeoPlasticism(magnitudes);
                break;
            case 'mode_525_de_stijl':
                this.render525DeStijl(magnitudes);
                break;
            case 'mode_526_color_field':
                this.render526ColorField(magnitudes);
                break;
            case 'mode_527_hard_edge':
                this.render527HardEdge(magnitudes);
                break;
            case 'mode_528_lyrical_abstraction':
                this.render528LyricalAbstraction(magnitudes);
                break;
            case 'mode_529_tachisme':
                this.render529Tachisme(magnitudes);
                break;
            case 'mode_530_action_painting':
                this.render530ActionPainting(magnitudes);
                break;
            case 'mode_531_stain_painting':
                this.render531StainPainting(magnitudes);
                break;
            case 'mode_532_shaped_canvas':
                this.render532ShapedCanvas(magnitudes);
                break;
            case 'mode_533_monochrome':
                this.render533Monochrome(magnitudes);
                break;
            case 'mode_534_kinetic_art':
                this.render534KineticArt(magnitudes);
                break;
            case 'mode_535_op_art':
                this.render535OpArt(magnitudes);
                break;
            case 'mode_536_light_art':
                this.render536LightArt(magnitudes);
                break;
            case 'mode_537_land_art':
                this.render537LandArt(magnitudes);
                break;
            case 'mode_538_earth_art':
                this.render538EarthArt(magnitudes);
                break;
            case 'mode_539_environmental_art':
                this.render539EnvironmentalArt(magnitudes);
                break;
            case 'mode_540_installation_art':
                this.render540InstallationArt(magnitudes);
                break;
            case 'mode_541_video_art':
                this.render541VideoArt(magnitudes);
                break;
            case 'mode_542_digital_art':
                this.render542DigitalArt(magnitudes);
                break;
            case 'mode_543_glitch_art':
                this.render543GlitchArt(magnitudes);
                break;
            case 'mode_544_pixel_art':
                this.render544PixelArt(magnitudes);
                break;
            case 'mode_545_ascii_art':
                this.render545AsciiArt(magnitudes);
                break;
            case 'mode_546_vector_art':
                this.render546VectorArt(magnitudes);
                break;
            case 'mode_547_fractal_art':
                this.render547FractalArt(magnitudes);
                break;
            case 'mode_548_algorithmic_art':
                this.render548AlgorithmicArt(magnitudes);
                break;
            case 'mode_549_generative_art':
                this.render549GenerativeArt(magnitudes);
                break;
            case 'mode_550_data_art':
                this.render550DataArt(magnitudes);
                break;
            case 'mode_551_bio_art':
                this.render551BioArt(magnitudes);
                break;
            case 'mode_552_net_art':
                this.render552NetArt(magnitudes);
                break;
            case 'mode_553_software_art':
                this.render553SoftwareArt(magnitudes);
                break;
            case 'mode_554_robotic_art':
                this.render554RoboticArt(magnitudes);
                break;
            case 'mode_555_interactive_art':
                this.render555InteractiveArt(magnitudes);
                break;
            case 'mode_556_projection_mapping':
                this.render556ProjectionMapping(magnitudes);
                break;
            case 'mode_557_holographic_art':
                this.render557HolographicArt(magnitudes);
                break;
            case 'mode_558_augmented_reality_art':
                this.render558AugmentedRealityArt(magnitudes);
                break;
            case 'mode_559_vr_art':
                this.render559VrArt(magnitudes);
                break;
            case 'mode_560_procedural_art':
                this.render560ProceduralArt(magnitudes);
                break;
            case 'mode_561_parametric_art':
                this.render561ParametricArt(magnitudes);
                break;
            case 'mode_562_mathematical_art':
                this.render562MathematicalArt(magnitudes);
                break;
            case 'mode_563_geometric_art':
                this.render563GeometricArt(magnitudes);
                break;
            case 'mode_564_tessellation_art':
                this.render564TessellationArt(magnitudes);
                break;
            case 'mode_565_symmetry_art':
                this.render565SymmetryArt(magnitudes);
                break;
            case 'mode_566_kaleidoscope_art':
                this.render566KaleidoscopeArt(magnitudes);
                break;
            case 'mode_567_mandala_art':
                this.render567MandalaArt(magnitudes);
                break;
            case 'mode_568_zentangle_art':
                this.render568ZentangleArt(magnitudes);
                break;
            case 'mode_569_doodle_art':
                this.render569DoodleArt(magnitudes);
                break;
            case 'mode_570_street_art':
                this.render570StreetArt(magnitudes);
                break;
            case 'mode_571_graffiti_art':
                this.render571GraffitiArt(magnitudes);
                break;
            case 'mode_572_mural_art':
                this.render572MuralArt(magnitudes);
                break;
            case 'mode_573_stencil_art':
                this.render573StencilArt(magnitudes);
                break;
            case 'mode_574_wheat_paste_art':
                this.render574WheatPasteArt(magnitudes);
                break;
            case 'mode_575_spray_paint_art':
                this.render575SprayPaintArt(magnitudes);
                break;
            case 'mode_576_mosaic_art':
                this.render576MosaicArt(magnitudes);
                break;
            case 'mode_577_collage_art':
                this.render577CollageArt(magnitudes);
                break;
            case 'mode_578_mixed_media_art':
                this.render578MixedMediaArt(magnitudes);
                break;
            case 'mode_579_assemblage_art':
                this.render579AssemblageArt(magnitudes);
                break;
            case 'mode_580_found_object_art':
                this.render580FoundObjectArt(magnitudes);
                break;
            case 'mode_581_readymade_art':
                this.render581ReadymadeArt(magnitudes);
                break;
            case 'mode_582_appropriation_art':
                this.render582AppropriationArt(magnitudes);
                break;
            case 'mode_583_sampling_art':
                this.render583SamplingArt(magnitudes);
                break;
            case 'mode_584_remix_art':
                this.render584RemixArt(magnitudes);
                break;
            case 'mode_585_mashup_art':
                this.render585MashupArt(magnitudes);
                break;
            case 'mode_586_photomontage':
                this.render586Photomontage(magnitudes);
                break;
            case 'mode_587_cut_up_technique':
                this.render587CutUpTechnique(magnitudes);
                break;
            case 'mode_588_exquisite_corpse':
                this.render588ExquisiteCorpse(magnitudes);
                break;
            case 'mode_589_automatic_drawing':
                this.render589AutomaticDrawing(magnitudes);
                break;
            case 'mode_590_chance_art':
                this.render590ChanceArt(magnitudes);
                break;
            case 'mode_591_indeterminacy_art':
                this.render591IndeterminacyArt(magnitudes);
                break;
            case 'mode_592_aleatory_art':
                this.render592AleatoryArt(magnitudes);
                break;
            case 'mode_593_stochastic_art':
                this.render593StochasticArt(magnitudes);
                break;
            case 'mode_594_entropy_art':
                this.render594EntropyArt(magnitudes);
                break;
            case 'mode_595_chaos_art':
                this.render595ChaosArt(magnitudes);
                break;
            case 'mode_596_complexity_art':
                this.render596ComplexityArt(magnitudes);
                break;
            case 'mode_597_emergence_art':
                this.render597EmergenceArt(magnitudes);
                break;
            case 'mode_598_self_organization_art':
                this.render598SelfOrganizationArt(magnitudes);
                break;
            case 'mode_599_swarm_art':
                this.render599SwarmArt(magnitudes);
                break;
            case 'mode_600_flocking_art':
                this.render600FlockingArt(magnitudes);
                break;
            case 'mode_601_nebula':
                this.render601Nebula(magnitudes);
                break;
            case 'mode_602_galaxy_spiral':
                this.render602GalaxySpiral(magnitudes);
                break;
            case 'mode_603_black_hole':
                this.render603BlackHole(magnitudes);
                break;
            case 'mode_604_pulsar':
                this.render604Pulsar(magnitudes);
                break;
            case 'mode_605_quasar':
                this.render605Quasar(magnitudes);
                break;
            case 'mode_606_supernova':
                this.render606Supernova(magnitudes);
                break;
            case 'mode_607_star_cluster':
                this.render607StarCluster(magnitudes);
                break;
            case 'mode_608_asteroid_belt':
                this.render608AsteroidBelt(magnitudes);
                break;
            case 'mode_609_comet_tail':
                this.render609CometTail(magnitudes);
                break;
            case 'mode_610_meteor_shower':
                this.render610MeteorShower(magnitudes);
                break;
            case 'mode_611_planetary_rings':
                this.render611PlanetaryRings(magnitudes);
                break;
            case 'mode_612_solar_flare':
                this.render612SolarFlare(magnitudes);
                break;
            case 'mode_613_coronal_mass_ejection':
                this.render613CoronalMassEjection(magnitudes);
                break;
            case 'mode_614_cosmic_ray':
                this.render614CosmicRay(magnitudes);
                break;
            case 'mode_615_gamma_ray_burst':
                this.render615GammaRayBurst(magnitudes);
                break;
            case 'mode_616_gravitational_lens':
                this.render616GravitationalLens(magnitudes);
                break;
            case 'mode_617_dark_matter_halo':
                this.render617DarkMatterHalo(magnitudes);
                break;
            case 'mode_618_cosmic_web':
                this.render618CosmicWeb(magnitudes);
                break;
            case 'mode_619_void':
                this.render619Void(magnitudes);
                break;
            case 'mode_620_filament_structure':
                this.render620FilamentStructure(magnitudes);
                break;
            case 'mode_621_hubble_deep_field':
                this.render621HubbleDeepField(magnitudes);
                break;
            case 'mode_622_galaxy_collision':
                this.render622GalaxyCollision(magnitudes);
                break;
            case 'mode_623_tidal_tail':
                this.render623TidalTail(magnitudes);
                break;
            case 'mode_624_starburst_galaxy':
                this.render624StarburstGalaxy(magnitudes);
                break;
            case 'mode_625_active_galactic_nucleus':
                this.render625ActiveGalacticNucleus(magnitudes);
                break;
            case 'mode_626_blazar':
                this.render626Blazar(magnitudes);
                break;
            case 'mode_627_seyfert_galaxy':
                this.render627SeyfertGalaxy(magnitudes);
                break;
            case 'mode_628_radio_galaxy':
                this.render628RadioGalaxy(magnitudes);
                break;
            case 'mode_629_elliptical_galaxy':
                this.render629EllipticalGalaxy(magnitudes);
                break;
            case 'mode_630_irregular_galaxy':
                this.render630IrregularGalaxy(magnitudes);
                break;
            case 'mode_631_dwarf_galaxy':
                this.render631DwarfGalaxy(magnitudes);
                break;
            case 'mode_632_globular_cluster':
                this.render632GlobularCluster(magnitudes);
                break;
            case 'mode_633_open_cluster':
                this.render633OpenCluster(magnitudes);
                break;
            case 'mode_634_protoplanetary_disk':
                this.render634ProtoplanetaryDisk(magnitudes);
                break;
            case 'mode_635_accretion_disk':
                this.render635AccretionDisk(magnitudes);
                break;
            case 'mode_636_jets_from_black_hole':
                this.render636JetsFromBlackHole(magnitudes);
                break;
            case 'mode_637_event_horizon':
                this.render637EventHorizon(magnitudes);
                break;
            case 'mode_638_photon_sphere':
                this.render638PhotonSphere(magnitudes);
                break;
            case 'mode_639_ergosphere':
                this.render639Ergosphere(magnitudes);
                break;
            case 'mode_640_singularity':
                this.render640Singularity(magnitudes);
                break;
            case 'mode_641_wormhole':
                this.render641Wormhole(magnitudes);
                break;
            case 'mode_642_white_hole':
                this.render642WhiteHole(magnitudes);
                break;
            case 'mode_643_naked_singularity':
                this.render643NakedSingularity(magnitudes);
                break;
            case 'mode_644_hawking_radiation':
                this.render644HawkingRadiation(magnitudes);
                break;
            case 'mode_645_information_paradox':
                this.render645InformationParadox(magnitudes);
                break;
            case 'mode_646_multiverse_bubble':
                this.render646MultiverseBubble(magnitudes);
                break;
            case 'mode_647_parallel_universe':
                this.render647ParallelUniverse(magnitudes);
                break;
            case 'mode_648_brane_collision':
                this.render648BraneCollision(magnitudes);
                break;
            case 'mode_649_extra_dimensions':
                this.render649ExtraDimensions(magnitudes);
                break;
            case 'mode_650_calabi_yau_manifold':
                this.render650CalabiYauManifold(magnitudes);
                break;
            case 'mode_651_string_theory_vibration':
                this.render651StringTheoryVibration(magnitudes);
                break;
            case 'mode_652_quantum_foam':
                this.render652QuantumFoam(magnitudes);
                break;
            case 'mode_653_planck_scale':
                this.render653PlanckScale(magnitudes);
                break;
            case 'mode_654_big_bang':
                this.render654BigBang(magnitudes);
                break;
            case 'mode_655_cosmic_microwave_background':
                this.render655CosmicMicrowaveBackground(magnitudes);
                break;
            case 'mode_656_inflation_field':
                this.render656InflationField(magnitudes);
                break;
            case 'mode_657_density_fluctuations':
                this.render657DensityFluctuations(magnitudes);
                break;
            case 'mode_658_baryon_acoustic_oscillations':
                this.render658BaryonAcousticOscillations(magnitudes);
                break;
            case 'mode_659_dark_energy':
                this.render659DarkEnergy(magnitudes);
                break;
            case 'mode_660_cosmological_constant':
                this.render660CosmologicalConstant(magnitudes);
                break;
            case 'mode_661_quintessence_field':
                this.render661QuintessenceField(magnitudes);
                break;
            case 'mode_662_heat_death':
                this.render662HeatDeath(magnitudes);
                break;
            case 'mode_663_big_rip':
                this.render663BigRip(magnitudes);
                break;
            case 'mode_664_big_crunch':
                this.render664BigCrunch(magnitudes);
                break;
            case 'mode_665_big_bounce':
                this.render665BigBounce(magnitudes);
                break;
            case 'mode_666_cyclic_universe':
                this.render666CyclicUniverse(magnitudes);
                break;
            case 'mode_667_conformal_cyclic_cosmology':
                this.render667ConformalCyclicCosmology(magnitudes);
                break;
            case 'mode_668_eternal_inflation':
                this.render668EternalInflation(magnitudes);
                break;
            case 'mode_669_landscape_multiverse':
                this.render669LandscapeMultiverse(magnitudes);
                break;
            case 'mode_670_quantum_decoherence':
                this.render670QuantumDecoherence(magnitudes);
                break;
            case 'mode_671_many_worlds':
                this.render671ManyWorlds(magnitudes);
                break;
            case 'mode_672_pilot_wave':
                this.render672PilotWave(magnitudes);
                break;
            case 'mode_673_spontaneous_collapse':
                this.render673SpontaneousCollapse(magnitudes);
                break;
            case 'mode_674_transactional_interpretation':
                this.render674TransactionalInterpretation(magnitudes);
                break;
            case 'mode_675_relational_quantum_mechanics':
                this.render675RelationalQuantumMechanics(magnitudes);
                break;
            case 'mode_676_quantum_bayesianism':
                this.render676QuantumBayesianism(magnitudes);
                break;
            case 'mode_677_consistent_histories':
                this.render677ConsistentHistories(magnitudes);
                break;
            case 'mode_678_bohemian_mechanics':
                this.render678BohemianMechanics(magnitudes);
                break;
            case 'mode_679_stochastic_mechanics':
                this.render679StochasticMechanics(magnitudes);
                break;
            case 'mode_680_quantum_darwinism':
                this.render680QuantumDarwinism(magnitudes);
                break;
            case 'mode_681_einselection':
                this.render681Einselection(magnitudes);
                break;
            case 'mode_682_pointer_states':
                this.render682PointerStates(magnitudes);
                break;
            case 'mode_683_branching_spacetime':
                this.render683BranchingSpacetime(magnitudes);
                break;
            case 'mode_684_worldline':
                this.render684Worldline(magnitudes);
                break;
            case 'mode_685_light_cone':
                this.render685LightCone(magnitudes);
                break;
            case 'mode_686_cauchy_surface':
                this.render686CauchySurface(magnitudes);
                break;
            case 'mode_687_spacelike_hypersurface':
                this.render687SpacelikeHypersurface(magnitudes);
                break;
            case 'mode_688_timelike_curve':
                this.render688TimelikeCurve(magnitudes);
                break;
            case 'mode_689_closed_timelike_curve':
                this.render689ClosedTimelikeCurve(magnitudes);
                break;
            case 'mode_690_chronology_protection':
                this.render690ChronologyProtection(magnitudes);
                break;
            case 'mode_691_novikov_self_consistency':
                this.render691NovikovSelfConsistency(magnitudes);
                break;
            case 'mode_692_grandfather_paradox':
                this.render692GrandfatherParadox(magnitudes);
                break;
            case 'mode_693_bootstrap_paradox':
                this.render693BootstrapParadox(magnitudes);
                break;
            case 'mode_694_predestination_paradox':
                this.render694PredestinationParadox(magnitudes);
                break;
            case 'mode_695_causal_loop':
                this.render695CausalLoop(magnitudes);
                break;
            case 'mode_696_retrocausality':
                this.render696Retrocausality(magnitudes);
                break;
            case 'mode_697_advanced_wave':
                this.render697AdvancedWave(magnitudes);
                break;
            case 'mode_698_wheeler_feynman_absorber':
                this.render698WheelerFeynmanAbsorber(magnitudes);
                break;
            case 'mode_699_transactional_interpretation':
                this.render699TransactionalInterpretation(magnitudes);
                break;
            case 'mode_700_two_state_vector':
                this.render700TwoStateVector(magnitudes);
                break;
            case 'mode_701_binary_rain':
                this.render701BinaryRain(magnitudes);
                break;
            case 'mode_702_hexadecimal_grid':
                this.render702HexadecimalGrid(magnitudes);
                break;
            case 'mode_703_circuit_board':
                this.render703CircuitBoard(magnitudes);
                break;
            case 'mode_704_data_flow':
                this.render704DataFlow(magnitudes);
                break;
            case 'mode_705_packet_transmission':
                this.render705PacketTransmission(magnitudes);
                break;
            case 'mode_706_network_topology':
                this.render706NetworkTopology(magnitudes);
                break;
            case 'mode_707_server_cluster':
                this.render707ServerCluster(magnitudes);
                break;
            case 'mode_708_cloud_computing':
                this.render708CloudComputing(magnitudes);
                break;
            case 'mode_709_distributed_system':
                this.render709DistributedSystem(magnitudes);
                break;
            case 'mode_710_peer_to_peer':
                this.render710PeerToPeer(magnitudes);
                break;
            case 'mode_711_blockchain':
                this.render711Blockchain(magnitudes);
                break;
            case 'mode_712_hash_function':
                this.render712HashFunction(magnitudes);
                break;
            case 'mode_713_encryption':
                this.render713Encryption(magnitudes);
                break;
            case 'mode_714_public_key':
                this.render714PublicKey(magnitudes);
                break;
            case 'mode_715_digital_signature':
                this.render715DigitalSignature(magnitudes);
                break;
            case 'mode_716_zero_knowledge_proof':
                this.render716ZeroKnowledgeProof(magnitudes);
                break;
            case 'mode_717_homomorphic_encryption':
                this.render717HomomorphicEncryption(magnitudes);
                break;
            case 'mode_718_secure_multiparty_computation':
                this.render718SecureMultipartyComputation(magnitudes);
                break;
            case 'mode_719_differential_privacy':
                this.render719DifferentialPrivacy(magnitudes);
                break;
            case 'mode_720_federated_learning':
                this.render720FederatedLearning(magnitudes);
                break;
            case 'mode_721_neural_network':
                this.render721NeuralNetwork(magnitudes);
                break;
            case 'mode_722_deep_learning':
                this.render722DeepLearning(magnitudes);
                break;
            case 'mode_723_convolutional_layer':
                this.render723ConvolutionalLayer(magnitudes);
                break;
            case 'mode_724_recurrent_connection':
                this.render724RecurrentConnection(magnitudes);
                break;
            case 'mode_725_attention_mechanism':
                this.render725AttentionMechanism(magnitudes);
                break;
            case 'mode_726_transformer_architecture':
                this.render726TransformerArchitecture(magnitudes);
                break;
            case 'mode_727_residual_connection':
                this.render727ResidualConnection(magnitudes);
                break;
            case 'mode_728_skip_connection':
                this.render728SkipConnection(magnitudes);
                break;
            case 'mode_729_batch_normalization':
                this.render729BatchNormalization(magnitudes);
                break;
            case 'mode_730_dropout_regularization':
                this.render730DropoutRegularization(magnitudes);
                break;
            case 'mode_731_activation_function':
                this.render731ActivationFunction(magnitudes);
                break;
            case 'mode_732_gradient_descent':
                this.render732GradientDescent(magnitudes);
                break;
            case 'mode_733_backpropagation':
                this.render733Backpropagation(magnitudes);
                break;
            case 'mode_734_loss_landscape':
                this.render734LossLandscape(magnitudes);
                break;
            case 'mode_735_optimizer_trajectory':
                this.render735OptimizerTrajectory(magnitudes);
                break;
            case 'mode_736_learning_rate_schedule':
                this.render736LearningRateSchedule(magnitudes);
                break;
            case 'mode_737_momentum':
                this.render737Momentum(magnitudes);
                break;
            case 'mode_738_adaptive_learning':
                this.render738AdaptiveLearning(magnitudes);
                break;
            case 'mode_739_weight_decay':
                this.render739WeightDecay(magnitudes);
                break;
            case 'mode_740_early_stopping':
                this.render740EarlyStopping(magnitudes);
                break;
            case 'mode_741_cross_validation':
                this.render741CrossValidation(magnitudes);
                break;
            case 'mode_742_ensemble_method':
                this.render742EnsembleMethod(magnitudes);
                break;
            case 'mode_743_boosting':
                this.render743Boosting(magnitudes);
                break;
            case 'mode_744_bagging':
                this.render744Bagging(magnitudes);
                break;
            case 'mode_745_random_forest':
                this.render745RandomForest(magnitudes);
                break;
            case 'mode_746_decision_tree':
                this.render746DecisionTree(magnitudes);
                break;
            case 'mode_747_support_vector_machine':
                this.render747SupportVectorMachine(magnitudes);
                break;
            case 'mode_748_kernel_trick':
                this.render748KernelTrick(magnitudes);
                break;
            case 'mode_749_feature_space':
                this.render749FeatureSpace(magnitudes);
                break;
            case 'mode_750_dimensionality_reduction':
                this.render750DimensionalityReduction(magnitudes);
                break;
            case 'mode_751_principal_component_analysis':
                this.render751PrincipalComponentAnalysis(magnitudes);
                break;
            case 'mode_752_t_sne_embedding':
                this.render752TSneEmbedding(magnitudes);
                break;
            case 'mode_753_autoencoder_latent_space':
                this.render753AutoencoderLatentSpace(magnitudes);
                break;
            case 'mode_754_variational_autoencoder':
                this.render754VariationalAutoencoder(magnitudes);
                break;
            case 'mode_755_generative_adversarial_network':
                this.render755GenerativeAdversarialNetwork(magnitudes);
                break;
            case 'mode_756_discriminator_network':
                this.render756DiscriminatorNetwork(magnitudes);
                break;
            case 'mode_757_generator_network':
                this.render757GeneratorNetwork(magnitudes);
                break;
            case 'mode_758_style_transfer':
                this.render758StyleTransfer(magnitudes);
                break;
            case 'mode_759_content_loss':
                this.render759ContentLoss(magnitudes);
                break;
            case 'mode_760_gram_matrix':
                this.render760GramMatrix(magnitudes);
                break;
            case 'mode_761_perceptual_loss':
                this.render761PerceptualLoss(magnitudes);
                break;
            case 'mode_762_adversarial_loss':
                this.render762AdversarialLoss(magnitudes);
                break;
            case 'mode_763_cycle_consistency':
                this.render763CycleConsistency(magnitudes);
                break;
            case 'mode_764_identity_loss':
                this.render764IdentityLoss(magnitudes);
                break;
            case 'mode_765_reconstruction_loss':
                this.render765ReconstructionLoss(magnitudes);
                break;
            case 'mode_766_kl_divergence':
                this.render766KlDivergence(magnitudes);
                break;
            case 'mode_767_wasserstein_distance':
                this.render767WassersteinDistance(magnitudes);
                break;
            case 'mode_768_earth_mover_distance':
                this.render768EarthMoverDistance(magnitudes);
                break;
            case 'mode_769_inception_score':
                this.render769InceptionScore(magnitudes);
                break;
            case 'mode_770_frechet_inception_distance':
                this.render770FrechetInceptionDistance(magnitudes);
                break;
            case 'mode_771_bleu_score':
                this.render771BleuScore(magnitudes);
                break;
            case 'mode_772_rouge_score':
                this.render772RougeScore(magnitudes);
                break;
            case 'mode_773_perplexity':
                this.render773Perplexity(magnitudes);
                break;
            case 'mode_774_cross_entropy':
                this.render774CrossEntropy(magnitudes);
                break;
            case 'mode_775_mutual_information':
                this.render775MutualInformation(magnitudes);
                break;
            case 'mode_776_information_bottleneck':
                this.render776InformationBottleneck(magnitudes);
                break;
            case 'mode_777_rate_distortion':
                this.render777RateDistortion(magnitudes);
                break;
            case 'mode_778_source_coding':
                this.render778SourceCoding(magnitudes);
                break;
            case 'mode_779_channel_coding':
                this.render779ChannelCoding(magnitudes);
                break;
            case 'mode_780_error_correction':
                this.render780ErrorCorrection(magnitudes);
                break;
            case 'mode_781_hamming_distance':
                this.render781HammingDistance(magnitudes);
                break;
            case 'mode_782_reed_solomon':
                this.render782ReedSolomon(magnitudes);
                break;
            case 'mode_783_turbo_code':
                this.render783TurboCode(magnitudes);
                break;
            case 'mode_784_ldpc_code':
                this.render784LdpcCode(magnitudes);
                break;
            case 'mode_785_polar_code':
                this.render785PolarCode(magnitudes);
                break;
            case 'mode_786_quantum_error_correction':
                this.render786QuantumErrorCorrection(magnitudes);
                break;
            case 'mode_787_surface_code':
                this.render787SurfaceCode(magnitudes);
                break;
            case 'mode_788_toric_code':
                this.render788ToricCode(magnitudes);
                break;
            case 'mode_789_color_code':
                this.render789ColorCode(magnitudes);
                break;
            case 'mode_790_stabilizer_formalism':
                this.render790StabilizerFormalism(magnitudes);
                break;
            case 'mode_791_clifford_gate':
                this.render791CliffordGate(magnitudes);
                break;
            case 'mode_792_pauli_group':
                this.render792PauliGroup(magnitudes);
                break;
            case 'mode_793_measurement_based_quantum_computing':
                this.render793MeasurementBasedQuantumComputing(magnitudes);
                break;
            case 'mode_794_one_way_quantum_computer':
                this.render794OneWayQuantumComputer(magnitudes);
                break;
            case 'mode_795_adiabatic_quantum_computation':
                this.render795AdiabaticQuantumComputation(magnitudes);
                break;
            case 'mode_796_quantum_annealing':
                this.render796QuantumAnnealing(magnitudes);
                break;
            case 'mode_797_variational_quantum_eigensolver':
                this.render797VariationalQuantumEigensolver(magnitudes);
                break;
            case 'mode_798_quantum_approximate_optimization':
                this.render798QuantumApproximateOptimization(magnitudes);
                break;
            case 'mode_799_quantum_phase_estimation':
                this.render799QuantumPhaseEstimation(magnitudes);
                break;
            case 'mode_800_quantum_fourier_transform':
                this.render800QuantumFourierTransform(magnitudes);
                break;
            case 'mode_801_mandala':
                this.render801Mandala(magnitudes);
                break;
            case 'mode_802_yantra':
                this.render802Yantra(magnitudes);
                break;
            case 'mode_803_lotus':
                this.render803Lotus(magnitudes);
                break;
            case 'mode_804_om_symbol':
                this.render804OmSymbol(magnitudes);
                break;
            case 'mode_805_chakra':
                this.render805Chakra(magnitudes);
                break;
            case 'mode_806_aura_field':
                this.render806AuraField(magnitudes);
                break;
            case 'mode_807_third_eye':
                this.render807ThirdEye(magnitudes);
                break;
            case 'mode_808_kundalini':
                this.render808Kundalini(magnitudes);
                break;
            case 'mode_809_merkaba':
                this.render809Merkaba(magnitudes);
                break;
            case 'mode_810_flower_of_life':
                this.render810FlowerOfLife(magnitudes);
                break;
            case 'mode_811_seed_of_life':
                this.render811SeedOfLife(magnitudes);
                break;
            case 'mode_812_tree_of_life':
                this.render812TreeOfLife(magnitudes);
                break;
            case 'mode_813_metatron_cube':
                this.render813MetatronCube(magnitudes);
                break;
            case 'mode_814_sri_yantra':
                this.render814SriYantra(magnitudes);
                break;
            case 'mode_815_shri_yantra':
                this.render815ShriYantra(magnitudes);
                break;
            case 'mode_816_tibetan_sand_mandala':
                this.render816TibetanSandMandala(magnitudes);
                break;
            case 'mode_817_zen_circle':
                this.render817ZenCircle(magnitudes);
                break;
            case 'mode_818_yin_yang':
                this.render818YinYang(magnitudes);
                break;
            case 'mode_819_tao_symbol':
                this.render819TaoSymbol(magnitudes);
                break;
            case 'mode_820_bagua':
                this.render820Bagua(magnitudes);
                break;
            case 'mode_821_i_ching_hexagram':
                this.render821IChingHexagram(magnitudes);
                break;
            case 'mode_822_trigram':
                this.render822Trigram(magnitudes);
                break;
            case 'mode_823_medicine_wheel':
                this.render823MedicineWheel(magnitudes);
                break;
            case 'mode_824_dreamcatcher':
                this.render824Dreamcatcher(magnitudes);
                break;
            case 'mode_825_totem':
                this.render825Totem(magnitudes);
                break;
            case 'mode_826_spirit_animal':
                this.render826SpiritAnimal(magnitudes);
                break;
            case 'mode_827_shamanic_journey':
                this.render827ShamanicJourney(magnitudes);
                break;
            case 'mode_828_ayahuasca_vision':
                this.render828AyahuascaVision(magnitudes);
                break;
            case 'mode_829_dmt_realm':
                this.render829DmtRealm(magnitudes);
                break;
            case 'mode_830_astral_projection':
                this.render830AstralProjection(magnitudes);
                break;
            case 'mode_831_out_of_body_experience':
                this.render831OutOfBodyExperience(magnitudes);
                break;
            case 'mode_832_near_death_experience':
                this.render832NearDeathExperience(magnitudes);
                break;
            case 'mode_833_tunnel_of_light':
                this.render833TunnelOfLight(magnitudes);
                break;
            case 'mode_834_life_review':
                this.render834LifeReview(magnitudes);
                break;
            case 'mode_835_soul_retrieval':
                this.render835SoulRetrieval(magnitudes);
                break;
            case 'mode_836_past_life_regression':
                this.render836PastLifeRegression(magnitudes);
                break;
            case 'mode_837_akashic_records':
                this.render837AkashicRecords(magnitudes);
                break;
            case 'mode_838_collective_unconscious':
                this.render838CollectiveUnconscious(magnitudes);
                break;
            case 'mode_839_archetypal_realm':
                this.render839ArchetypalRealm(magnitudes);
                break;
            case 'mode_840_synchronicity':
                this.render840Synchronicity(magnitudes);
                break;
            case 'mode_841_meaningful_coincidence':
                this.render841MeaningfulCoincidence(magnitudes);
                break;
            case 'mode_842_serendipity':
                this.render842Serendipity(magnitudes);
                break;
            case 'mode_843_providence':
                this.render843Providence(magnitudes);
                break;
            case 'mode_844_fate':
                this.render844Fate(magnitudes);
                break;
            case 'mode_845_destiny':
                this.render845Destiny(magnitudes);
                break;
            case 'mode_846_karma':
                this.render846Karma(magnitudes);
                break;
            case 'mode_847_dharma':
                this.render847Dharma(magnitudes);
                break;
            case 'mode_848_samsara':
                this.render848Samsara(magnitudes);
                break;
            case 'mode_849_nirvana':
                this.render849Nirvana(magnitudes);
                break;
            case 'mode_850_enlightenment':
                this.render850Enlightenment(magnitudes);
                break;
            case 'mode_851_samadhi':
                this.render851Samadhi(magnitudes);
                break;
            case 'mode_852_satori':
                this.render852Satori(magnitudes);
                break;
            case 'mode_853_kensho':
                this.render853Kensho(magnitudes);
                break;
            case 'mode_854_moksha':
                this.render854Moksha(magnitudes);
                break;
            case 'mode_855_liberation':
                this.render855Liberation(magnitudes);
                break;
            case 'mode_856_self_realization':
                this.render856SelfRealization(magnitudes);
                break;
            case 'mode_857_god_consciousness':
                this.render857GodConsciousness(magnitudes);
                break;
            case 'mode_858_cosmic_consciousness':
                this.render858CosmicConsciousness(magnitudes);
                break;
            case 'mode_859_unity_consciousness':
                this.render859UnityConsciousness(magnitudes);
                break;
            case 'mode_860_non_dual_awareness':
                this.render860NonDualAwareness(magnitudes);
                break;
            case 'mode_861_witness_consciousness':
                this.render861WitnessConsciousness(magnitudes);
                break;
            case 'mode_862_pure_awareness':
                this.render862PureAwareness(magnitudes);
                break;
            case 'mode_863_presence':
                this.render863Presence(magnitudes);
                break;
            case 'mode_864_now_moment':
                this.render864NowMoment(magnitudes);
                break;
            case 'mode_865_eternal_present':
                this.render865EternalPresent(magnitudes);
                break;
            case 'mode_866_timeless_being':
                this.render866TimelessBeing(magnitudes);
                break;
            case 'mode_867_infinite_space':
                this.render867InfiniteSpace(magnitudes);
                break;
            case 'mode_868_boundless_compassion':
                this.render868BoundlessCompassion(magnitudes);
                break;
            case 'mode_869_unconditional_love':
                this.render869UnconditionalLove(magnitudes);
                break;
            case 'mode_870_divine_grace':
                this.render870DivineGrace(magnitudes);
                break;
            case 'mode_871_holy_spirit':
                this.render871HolySpirit(magnitudes);
                break;
            case 'mode_872_shekinah':
                this.render872Shekinah(magnitudes);
                break;
            case 'mode_873_divine_feminine':
                this.render873DivineFeminine(magnitudes);
                break;
            case 'mode_874_goddess_energy':
                this.render874GoddessEnergy(magnitudes);
                break;
            case 'mode_875_sacred_masculine':
                this.render875SacredMasculine(magnitudes);
                break;
            case 'mode_876_hieros_gamos':
                this.render876HierosGamos(magnitudes);
                break;
            case 'mode_877_alchemical_wedding':
                this.render877AlchemicalWedding(magnitudes);
                break;
            case 'mode_878_coniunctio':
                this.render878Coniunctio(magnitudes);
                break;
            case 'mode_879_philosopher_stone':
                this.render879PhilosopherStone(magnitudes);
                break;
            case 'mode_880_prima_materia':
                this.render880PrimaMateria(magnitudes);
                break;
            case 'mode_881_nigredo':
                this.render881Nigredo(magnitudes);
                break;
            case 'mode_882_albedo':
                this.render882Albedo(magnitudes);
                break;
            case 'mode_883_citrinitas':
                this.render883Citrinitas(magnitudes);
                break;
            case 'mode_884_rubedo':
                this.render884Rubedo(magnitudes);
                break;
            case 'mode_885_seven_stages':
                this.render885SevenStages(magnitudes);
                break;
            case 'mode_886_hermetic_principle':
                this.render886HermeticPrinciple(magnitudes);
                break;
            case 'mode_887_as_above_so_below':
                this.render887AsAboveSoBelow(magnitudes);
                break;
            case 'mode_888_microcosm_macrocosm':
                this.render888MicrocosmMacrocosm(magnitudes);
                break;
            case 'mode_889_correspondence':
                this.render889Correspondence(magnitudes);
                break;
            case 'mode_890_vibration':
                this.render890Vibration(magnitudes);
                break;
            case 'mode_891_polarity':
                this.render891Polarity(magnitudes);
                break;
            case 'mode_892_rhythm':
                this.render892Rhythm(magnitudes);
                break;
            case 'mode_893_cause_and_effect':
                this.render893CauseAndEffect(magnitudes);
                break;
            case 'mode_894_gender_principle':
                this.render894GenderPrinciple(magnitudes);
                break;
            case 'mode_895_mentalism':
                this.render895Mentalism(magnitudes);
                break;
            case 'mode_896_emerald_tablet':
                this.render896EmeraldTablet(magnitudes);
                break;
            case 'mode_897_kybalion':
                this.render897Kybalion(magnitudes);
                break;
            case 'mode_898_corpus_hermeticum':
                this.render898CorpusHermeticum(magnitudes);
                break;
            case 'mode_899_gnostic_vision':
                this.render899GnosticVision(magnitudes);
                break;
            case 'mode_900_sophia':
                this.render900Sophia(magnitudes);
                break;
            case 'mode_901_spiral_vortex':
                this.render901SpiralVortex(magnitudes);
                break;
            case 'mode_902_concentric_circles':
                this.render902ConcentricCircles(magnitudes);
                break;
            case 'mode_903_expanding_rings':
                this.render903ExpandingRings(magnitudes);
                break;
            case 'mode_904_contracting_circles':
                this.render904ContractingCircles(magnitudes);
                break;
            case 'mode_905_pulsing_orb':
                this.render905PulsingOrb(magnitudes);
                break;
            case 'mode_906_oscillating_wave':
                this.render906OscillatingWave(magnitudes);
                break;
            case 'mode_907_pendulum_swing':
                this.render907PendulumSwing(magnitudes);
                break;
            case 'mode_908_hypnotic_swirl':
                this.render908HypnoticSwirl(magnitudes);
                break;
            case 'mode_909_tunnel_zoom':
                this.render909TunnelZoom(magnitudes);
                break;
            case 'mode_910_perspective_shift':
                this.render910PerspectiveShift(magnitudes);
                break;
            case 'mode_911_rotating_polygon':
                this.render911RotatingPolygon(magnitudes);
                break;
            case 'mode_912_morphing_shape':
                this.render912MorphingShape(magnitudes);
                break;
            case 'mode_913_flowing_liquid':
                this.render913FlowingLiquid(magnitudes);
                break;
            case 'mode_914_ripple_effect':
                this.render914RippleEffect(magnitudes);
                break;
            case 'mode_915_interference_pattern':
                this.render915InterferencePattern(magnitudes);
                break;
            case 'mode_916_moire_effect':
                this.render916MoireEffect(magnitudes);
                break;
            case 'mode_917_strobing_light':
                this.render917StrobingLight(magnitudes);
                break;
            case 'mode_918_flickering':
                this.render918Flickering(magnitudes);
                break;
            case 'mode_919_pulsating':
                this.render919Pulsating(magnitudes);
                break;
            case 'mode_920_breathing_pattern':
                this.render920BreathingPattern(magnitudes);
                break;
            case 'mode_921_expansion_contraction':
                this.render921ExpansionContraction(magnitudes);
                break;
            case 'mode_922_growth_decay':
                this.render922GrowthDecay(magnitudes);
                break;
            case 'mode_923_birth_death':
                this.render923BirthDeath(magnitudes);
                break;
            case 'mode_924_ebb_flow':
                this.render924EbbFlow(magnitudes);
                break;
            case 'mode_925_inhale_exhale':
                this.render925InhaleExhale(magnitudes);
                break;
            case 'mode_926_systole_diastole':
                this.render926SystoleDiastole(magnitudes);
                break;
            case 'mode_927_tension_release':
                this.render927TensionRelease(magnitudes);
                break;
            case 'mode_928_charge_discharge':
                this.render928ChargeDischarge(magnitudes);
                break;
            case 'mode_929_loading_unloading':
                this.render929LoadingUnloading(magnitudes);
                break;
            case 'mode_930_compression_rarefaction':
                this.render930CompressionRarefaction(magnitudes);
                break;
            case 'mode_931_dense_sparse':
                this.render931DenseSparse(magnitudes);
                break;
            case 'mode_932_thick_thin':
                this.render932ThickThin(magnitudes);
                break;
            case 'mode_933_heavy_light':
                this.render933HeavyLight(magnitudes);
                break;
            case 'mode_934_dark_bright':
                this.render934DarkBright(magnitudes);
                break;
            case 'mode_935_shadow_highlight':
                this.render935ShadowHighlight(magnitudes);
                break;
            case 'mode_936_positive_negative':
                this.render936PositiveNegative(magnitudes);
                break;
            case 'mode_937_convex_concave':
                this.render937ConvexConcave(magnitudes);
                break;
            case 'mode_938_inside_outside':
                this.render938InsideOutside(magnitudes);
                break;
            case 'mode_939_figure_ground':
                this.render939FigureGround(magnitudes);
                break;
            case 'mode_940_foreground_background':
                this.render940ForegroundBackground(magnitudes);
                break;
            case 'mode_941_solid_void':
                this.render941SolidVoid(magnitudes);
                break;
            case 'mode_942_matter_antimatter':
                this.render942MatterAntimatter(magnitudes);
                break;
            case 'mode_943_particle_wave':
                this.render943ParticleWave(magnitudes);
                break;
            case 'mode_944_discrete_continuous':
                this.render944DiscreteContinuous(magnitudes);
                break;
            case 'mode_945_quantized_smooth':
                this.render945QuantizedSmooth(magnitudes);
                break;
            case 'mode_946_digital_analog':
                this.render946DigitalAnalog(magnitudes);
                break;
            case 'mode_947_binary_fluid':
                this.render947BinaryFluid(magnitudes);
                break;
            case 'mode_948_on_off':
                this.render948OnOff(magnitudes);
                break;
            case 'mode_949_yes_no':
                this.render949YesNo(magnitudes);
                break;
            case 'mode_950_zero_one':
                this.render950ZeroOne(magnitudes);
                break;
            case 'mode_951_presence_absence':
                this.render951PresenceAbsence(magnitudes);
                break;
            case 'mode_952_being_nothingness':
                this.render952BeingNothingness(magnitudes);
                break;
            case 'mode_953_existence_void':
                this.render953ExistenceVoid(magnitudes);
                break;
            case 'mode_954_form_emptiness':
                this.render954FormEmptiness(magnitudes);
                break;
            case 'mode_955_substance_essence':
                this.render955SubstanceEssence(magnitudes);
                break;
            case 'mode_956_appearance_reality':
                this.render956AppearanceReality(magnitudes);
                break;
            case 'mode_957_illusion_truth':
                this.render957IllusionTruth(magnitudes);
                break;
            case 'mode_958_maya_brahman':
                this.render958MayaBrahman(magnitudes);
                break;
            case 'mode_959_phenomena_noumena':
                this.render959PhenomenaNoumena(magnitudes);
                break;
            case 'mode_960_relative_absolute':
                this.render960RelativeAbsolute(magnitudes);
                break;
            case 'mode_961_changing_unchanging':
                this.render961ChangingUnchanging(magnitudes);
                break;
            case 'mode_962_temporal_eternal':
                this.render962TemporalEternal(magnitudes);
                break;
            case 'mode_963_finite_infinite':
                this.render963FiniteInfinite(magnitudes);
                break;
            case 'mode_964_limited_boundless':
                this.render964LimitedBoundless(magnitudes);
                break;
            case 'mode_965_mortal_immortal':
                this.render965MortalImmortal(magnitudes);
                break;
            case 'mode_966_perishable_imperishable':
                this.render966PerishableImperishable(magnitudes);
                break;
            case 'mode_967_transient_permanent':
                this.render967TransientPermanent(magnitudes);
                break;
            case 'mode_968_fleeting_lasting':
                this.render968FleetingLasting(magnitudes);
                break;
            case 'mode_969_ephemeral_enduring':
                this.render969EphemeralEnduring(magnitudes);
                break;
            case 'mode_970_momentary_timeless':
                this.render970MomentaryTimeless(magnitudes);
                break;
            case 'mode_971_local_universal':
                this.render971LocalUniversal(magnitudes);
                break;
            case 'mode_972_particular_general':
                this.render972ParticularGeneral(magnitudes);
                break;
            case 'mode_973_specific_generic':
                this.render973SpecificGeneric(magnitudes);
                break;
            case 'mode_974_unique_common':
                this.render974UniqueCommon(magnitudes);
                break;
            case 'mode_975_individual_collective':
                this.render975IndividualCollective(magnitudes);
                break;
            case 'mode_976_one_many':
                this.render976OneMany(magnitudes);
                break;
            case 'mode_977_unity_multiplicity':
                this.render977UnityMultiplicity(magnitudes);
                break;
            case 'mode_978_simple_complex':
                this.render978SimpleComplex(magnitudes);
                break;
            case 'mode_979_elementary_composite':
                this.render979ElementaryComposite(magnitudes);
                break;
            case 'mode_980_atomic_molecular':
                this.render980AtomicMolecular(magnitudes);
                break;
            case 'mode_981_fundamental_derived':
                this.render981FundamentalDerived(magnitudes);
                break;
            case 'mode_982_primary_secondary':
                this.render982PrimarySecondary(magnitudes);
                break;
            case 'mode_983_essential_accidental':
                this.render983EssentialAccidental(magnitudes);
                break;
            case 'mode_984_necessary_contingent':
                this.render984NecessaryContingent(magnitudes);
                break;
            case 'mode_985_a_priori_a_posteriori':
                this.render985APrioriAPosteriori(magnitudes);
                break;
            case 'mode_986_analytic_synthetic':
                this.render986AnalyticSynthetic(magnitudes);
                break;
            case 'mode_987_deductive_inductive':
                this.render987DeductiveInductive(magnitudes);
                break;
            case 'mode_988_logical_empirical':
                this.render988LogicalEmpirical(magnitudes);
                break;
            case 'mode_989_rational_experiential':
                this.render989RationalExperiential(magnitudes);
                break;
            case 'mode_990_abstract_concrete':
                this.render990AbstractConcrete(magnitudes);
                break;
            case 'mode_991_theoretical_practical':
                this.render991TheoreticalPractical(magnitudes);
                break;
            case 'mode_992_ideal_real':
                this.render992IdealReal(magnitudes);
                break;
            case 'mode_993_conceptual_actual':
                this.render993ConceptualActual(magnitudes);
                break;
            case 'mode_994_possible_necessary':
                this.render994PossibleNecessary(magnitudes);
                break;
            case 'mode_995_potential_actual':
                this.render995PotentialActual(magnitudes);
                break;
            case 'mode_996_virtual_real':
                this.render996VirtualReal(magnitudes);
                break;
            case 'mode_997_simulated_genuine':
                this.render997SimulatedGenuine(magnitudes);
                break;
            case 'mode_998_artificial_natural':
                this.render998ArtificialNatural(magnitudes);
                break;
            case 'mode_999_synthetic_organic':
                this.render999SyntheticOrganic(magnitudes);
                break;
            case 'mode_1000_mechanical_living':
                this.render1000MechanicalLiving(magnitudes);
                break;
            default:
                this.renderCircularBars(magnitudes);
            }
        } catch (error) {
            console.error(`[Visualizer] Error rendering mode '${modeId}':`, error.message);
            // Fallback to circular bars on error
            this.renderCircularBars(magnitudes);
        }

        if (this.frameCounter === 0) {
            console.log('[Visualizer] First render completed successfully');
        }

        this.frameCounter++;
    }

    /**
     * Mode 1: Circular Bars
     */
    renderCircularBars(magnitudes) {
        const numBars = magnitudes.length;
        const angleStep = (Math.PI * 2) / numBars;
        const innerRadius = this.getEffectiveInnerRadius();
        const barWidthMultiplier = this.settings.barWidthMultiplier;

        // Enable shadow for depth
        this.ctx.shadowBlur = 15;
        this.ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';

        for (let i = 0; i < numBars; i++) {
            const angle = i * angleStep - Math.PI / 2;
            const magnitude = magnitudes[i];
            const barLength = magnitude * this.maxRadius * 0.7;

            const x1 = this.centerX + Math.cos(angle) * innerRadius;
            const y1 = this.centerY + Math.sin(angle) * innerRadius;
            const x2 = this.centerX + Math.cos(angle) * (innerRadius + barLength);
            const y2 = this.centerY + Math.sin(angle) * (innerRadius + barLength);

            this.ctx.strokeStyle = this.getColor(i, numBars);
            this.ctx.lineWidth = angleStep * innerRadius * barWidthMultiplier;
            this.ctx.lineCap = 'round';

            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }

        // Reset shadow
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 2: Waves
     */
    renderWaves(magnitudes) {
        const numWaves = 5;
        const innerRadius = this.getEffectiveInnerRadius();

        this.ctx.shadowBlur = 20;
        this.ctx.shadowColor = 'rgba(0, 113, 227, 0.3)';

        for (let wave = 0; wave < numWaves; wave++) {
            const waveRadius = innerRadius + (wave * 40);
            const numPoints = magnitudes.length;
            const angleStep = (Math.PI * 2) / numPoints;

            this.ctx.beginPath();
            this.ctx.strokeStyle = this.getColor(wave * 20, 100);
            this.ctx.lineWidth = 3;
            this.ctx.lineCap = 'round';

            for (let i = 0; i <= numPoints; i++) {
                const angle = i * angleStep;
                const magnitude = magnitudes[i % numPoints];
                const radius = waveRadius + magnitude * 30;

                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;

                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }

            this.ctx.closePath();
            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 3: Particles
     */
    renderParticles(magnitudes) {
        const numBars = magnitudes.length;
        const angleStep = (Math.PI * 2) / numBars;
        const innerRadius = this.getEffectiveInnerRadius();

        this.ctx.shadowBlur = 25;

        for (let i = 0; i < numBars; i++) {
            const angle = i * angleStep;
            const magnitude = magnitudes[i];
            const distance = innerRadius + magnitude * this.maxRadius * 0.6;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;
            const size = 4 + magnitude * 8;

            const color = this.getColor(i, numBars);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;

            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 4: Smooth Waveform
     */
    renderSmoothWaveform(magnitudes) {
        const numPoints = magnitudes.length;
        const angleStep = (Math.PI * 2) / numPoints;
        const innerRadius = this.getEffectiveInnerRadius();

        // Draw filled waveform
        this.ctx.beginPath();

        for (let i = 0; i <= numPoints; i++) {
            const angle = i * angleStep;
            const magnitude = magnitudes[i % numPoints];
            const radius = innerRadius + magnitude * this.maxRadius * 0.5;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            if (i === 0) {
                this.ctx.moveTo(x, y);
            } else {
                this.ctx.lineTo(x, y);
            }
        }

        this.ctx.closePath();

        // Create gradient fill (ensure positive radii)
        const r1 = Math.max(0, innerRadius);
        const r2 = Math.max(r1 + 1, innerRadius + this.maxRadius * 0.5);
        const gradient = this.ctx.createRadialGradient(
            this.centerX, this.centerY, r1,
            this.centerX, this.centerY, r2
        );

        const scheme = COLOR_SCHEMES[this.settings.colorScheme];
        const color1 = scheme.primary;
        const color2 = scheme.secondary;

        gradient.addColorStop(0, `rgba(${color1[0]}, ${color1[1]}, ${color1[2]}, 0.8)`);
        gradient.addColorStop(1, `rgba(${color2[0]}, ${color2[1]}, ${color2[2]}, 0.4)`);

        this.ctx.fillStyle = gradient;
        this.ctx.fill();

        // Draw outline
        this.ctx.strokeStyle = `rgb(${color1[0]}, ${color1[1]}, ${color1[2]})`;
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
    }

    /**
     * Jazzy Fireworks: Bursting particles from center with jazz energy
     */
    renderJazzyFireworks(magnitudes) {
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const particleCount = this.settings.jazzyFireworksParticleCount || 200;
        const speed = this.settings.jazzyFireworksSpeed || 10;
        const secondaryBursts = this.settings.jazzyFireworksSecondaryBursts || 3;

        // Spawn particles from center constantly when magnitude is high
        if (avgMagnitude > 0.3) {
            const numParticles = Math.floor(150 + avgMagnitude * (particleCount - 150));

            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const particleSpeed = 5 + Math.random() * speed * (avgMagnitude + 0.5);

                // Use color scheme instead of hardcoded rainbow
                const colorIndex = Math.floor(Math.random() * magnitudes.length);
                const colorStr = this.getColor(colorIndex, magnitudes.length);
                const color = this.parseRgbColor(colorStr);

                this.fireworkParticles.push({
                    x: this.centerX,
                    y: this.centerY,
                    vx: Math.cos(angle) * particleSpeed,
                    vy: Math.sin(angle) * particleSpeed,
                    color: color,
                    life: 1.0,
                    size: 4 + Math.floor(avgMagnitude * 8)
                });
            }
        }

        // Spawn secondary bursts from rotating positions
        if (avgMagnitude > 0.5 && this.frameCounter % 5 === 0) {
            for (let burst = 0; burst < secondaryBursts; burst++) {
                const burstAngle = (burst / secondaryBursts) * Math.PI * 2 + this.frameCounter * 0.1;
                const burstDistance = this.maxRadius * 0.4;
                const burstX = this.centerX + Math.cos(burstAngle) * burstDistance;
                const burstY = this.centerY + Math.sin(burstAngle) * burstDistance;

                for (let i = 0; i < 50; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const particleSpeed = 3 + Math.random() * 10;

                    // Use color scheme
                    const colorIndex = Math.floor(Math.random() * magnitudes.length);
                    const colorStr = this.getColor(colorIndex, magnitudes.length);
                    const color = this.parseRgbColor(colorStr);

                    this.fireworkParticles.push({
                        x: burstX,
                        y: burstY,
                        vx: Math.cos(angle) * particleSpeed,
                        vy: Math.sin(angle) * particleSpeed,
                        color: color,
                        life: 0.8,
                        size: 3 + Math.floor(avgMagnitude * 6)
                    });
                }
            }
        }

        // Update and draw particles
        const newParticles = [];
        for (const particle of this.fireworkParticles) {
            particle.x += particle.vx;
            particle.y += particle.vy;
            particle.life -= 0.008;

            // Apply slight gravity
            particle.vy += 0.05;

            if (particle.life > 0) {
                const alpha = particle.life;
                const size = Math.max(1, Math.floor(particle.size * alpha));

                // Main particle
                this.ctx.fillStyle = `rgba(${particle.color[0]}, ${particle.color[1]}, ${particle.color[2]}, ${alpha})`;
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                this.ctx.fill();

                // Multi-layer glow
                if (alpha > 0.3) {
                    // Outer glow
                    this.ctx.strokeStyle = `rgba(${particle.color[0]}, ${particle.color[1]}, ${particle.color[2]}, ${0.3 * alpha})`;
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, size + 4, 0, Math.PI * 2);
                    this.ctx.stroke();

                    // Inner bright glow
                    this.ctx.fillStyle = `rgba(${particle.color[0]}, ${particle.color[1]}, ${particle.color[2]}, ${0.6 * alpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, size + 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                newParticles.push(particle);
            }
        }

        this.fireworkParticles = newParticles;
        this.frameCounter++;
    }

    /**
     * Neon Rain: Cyberpunk neon droplets cascading down
     */
    renderNeonRain(magnitudes) {
        const numBars = magnitudes.length;
        const spawnRate = this.settings.neonRainSpawnRate || 0.3;
        const particleSize = this.settings.neonRainParticleSize || 5;
        const speed = this.settings.neonRainSpeed || 10;

        // Spawn new rain particles based on magnitudes
        for (let i = 0; i < numBars; i++) {
            const magnitude = magnitudes[i];
            if (magnitude > 0.3 && Math.random() < magnitude * spawnRate) {
                const x = (i / numBars) * this.canvas.width;
                const y = 0;
                const particleSpeed = 3 + magnitude * speed;
                const size = 2 + Math.floor(magnitude * particleSize);

                // Use color scheme instead of hardcoded neon colors
                const colorStr = this.getColor(i, numBars);
                const color = this.parseRgbColor(colorStr);

                this.rainParticles.push({
                    x: x,
                    y: y,
                    speed: particleSpeed,
                    size: size,
                    color: color,
                    trailLength: Math.floor(magnitude * 50)
                });
            }
        }

        // Update and draw rain particles
        const newParticles = [];
        for (const particle of this.rainParticles) {
            particle.y += particle.speed;

            // Keep if still on screen
            if (particle.y < this.canvas.height + 20) {
                // Draw particle with trail
                const trailLength = particle.trailLength;
                for (let t = 0; t < trailLength; t++) {
                    const trailY = particle.y - t * 2;
                    if (trailY >= 0) {
                        const alpha = 1.0 - (t / trailLength);
                        const trailColor = `rgba(${particle.color[0]}, ${particle.color[1]}, ${particle.color[2]}, ${alpha})`;
                        const trailSize = Math.max(1, particle.size - Math.floor(t / 3));

                        this.ctx.fillStyle = trailColor;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, trailY, trailSize, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }

                // Glow effect
                this.ctx.fillStyle = `rgba(${particle.color[0]}, ${particle.color[1]}, ${particle.color[2]}, 0.3)`;
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, particle.size + 3, 0, Math.PI * 2);
                this.ctx.fill();

                newParticles.push(particle);
            }
        }

        this.rainParticles = newParticles;
    }

    renderSoulAura(magnitudes) {
        // Get settings
        const numPoints = this.settings.soulAuraNumPoints || 60;
        const baseRadius = this.settings.soulAuraBaseRadius || 0.5;
        const glowLayers = this.settings.soulAuraGlowLayers || 5;

        const angleStep = 360 / numPoints;
        const points = [];

        // Create smooth organic shape with many points
        for (let i = 0; i < numPoints; i++) {
            const angle = (i * angleStep) * Math.PI / 180;

            // Get magnitude for this angle section
            const magIdx = Math.floor((i / numPoints) * magnitudes.length);
            const magnitude = magnitudes[Math.min(magIdx, magnitudes.length - 1)];

            // Base radius with organic variation
            const baseVariation = Math.sin(i * 0.3 + this.frameCounter * 0.05) * 30;
            const magnitudeVariation = magnitude * 150;
            const radius = this.maxRadius * baseRadius + baseVariation + magnitudeVariation;

            const x = this.centerX + radius * Math.cos(angle);
            const y = this.centerY + radius * Math.sin(angle);
            points.push({ x, y });
        }

        // Calculate average magnitude for colors
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Draw multiple layers for depth and glow (outer glow layers - purple to pink gradient)
        for (let layer = glowLayers; layer > 0; layer--) {
            const expansion = layer * 15;
            const layerPoints = [];

            for (const point of points) {
                // Expand from center
                const dx = point.x - this.centerX;
                const dy = point.y - this.centerY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const scale = 1.0 + (expansion / (dist + 1));

                const x = this.centerX + dx * scale;
                const y = this.centerY + dy * scale;
                layerPoints.push({ x, y });
            }

            // Use color scheme for glow layers
            const colorIndex = Math.floor((layer / glowLayers) * magnitudes.length);
            const colorStr = this.getColor(colorIndex, magnitudes.length);
            const rgb = this.parseRgbColor(colorStr);

            const alpha = 0.3 / layer;
            this.ctx.fillStyle = `rgba(${Math.floor(rgb[0] * alpha)}, ${Math.floor(rgb[1] * alpha)}, ${Math.floor(rgb[2] * alpha)}, ${alpha})`;

            // Draw filled polygon
            this.ctx.beginPath();
            this.ctx.moveTo(layerPoints[0].x, layerPoints[0].y);
            for (let i = 1; i < layerPoints.length; i++) {
                this.ctx.lineTo(layerPoints[i].x, layerPoints[i].y);
            }
            this.ctx.closePath();
            this.ctx.fill();
        }

        // Main aura body - use color scheme
        const mainColorIndex = Math.floor(magnitudes.length / 2);
        const mainColorStr = this.getColor(mainColorIndex, magnitudes.length);
        const mainRgb = this.parseRgbColor(mainColorStr);

        this.ctx.fillStyle = `rgb(${mainRgb[0]}, ${mainRgb[1]}, ${mainRgb[2]})`;
        this.ctx.beginPath();
        this.ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            this.ctx.lineTo(points[i].x, points[i].y);
        }
        this.ctx.closePath();
        this.ctx.fill();

        // Bright outline - use color scheme
        const outlineColorIndex = magnitudes.length - 1;
        const outlineColorStr = this.getColor(outlineColorIndex, magnitudes.length);
        this.ctx.strokeStyle = outlineColorStr;
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            this.ctx.lineTo(points[i].x, points[i].y);
        }
        this.ctx.closePath();
        this.ctx.stroke();
    }

    /**
     * Mode 5: Neon Tubes
     */
    renderNeonTubes(magnitudes) {
        const numBars = magnitudes.length;
        const angleStep = (Math.PI * 2) / numBars;
        const innerRadius = this.getEffectiveInnerRadius();

        // Glow effect
        this.ctx.shadowBlur = 30;

        for (let i = 0; i < numBars; i++) {
            const angle = i * angleStep - Math.PI / 2;
            const magnitude = magnitudes[i];
            const barLength = magnitude * this.maxRadius * 0.6;

            const x1 = this.centerX + Math.cos(angle) * innerRadius;
            const y1 = this.centerY + Math.sin(angle) * innerRadius;
            const x2 = this.centerX + Math.cos(angle) * (innerRadius + barLength);
            const y2 = this.centerY + Math.sin(angle) * (innerRadius + barLength);

            const color = this.getColor(i, numBars);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 6;
            this.ctx.lineCap = 'round';

            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 6: Vinyl Grooves
     */
    renderVinylGrooves(magnitudes) {
        const numGrooves = 8;
        const innerRadius = Math.max(20, this.getEffectiveInnerRadius() - 50);

        this.ctx.strokeStyle = `rgba(${COLORS.TEXT_PRIMARY[0]}, ${COLORS.TEXT_PRIMARY[1]}, ${COLORS.TEXT_PRIMARY[2]}, 0.3)`;
        this.ctx.lineWidth = 1;

        // Draw concentric circles
        for (let i = 0; i < numGrooves; i++) {
            const radius = innerRadius + (i * 20);
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }

        // Draw animated spectrum on grooves
        const numPoints = magnitudes.length;
        const angleStep = (Math.PI * 2) / numPoints;

        this.ctx.shadowBlur = 15;

        for (let i = 0; i < numPoints; i++) {
            const angle = i * angleStep;
            const magnitude = magnitudes[i];
            const radius = innerRadius + magnitude * 150;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, numPoints);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;

            this.ctx.beginPath();
            this.ctx.arc(x, y, 2, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 7: Soul Aura
     */
    renderSoulAura(magnitudes) {
        const numLayers = 6;
        const innerRadius = this.getEffectiveInnerRadius();

        for (let layer = 0; layer < numLayers; layer++) {
            const alpha = 0.3 - (layer * 0.04);
            const layerRadius = innerRadius + (layer * 25);

            const numPoints = magnitudes.length;
            const angleStep = (Math.PI * 2) / numPoints;

            this.ctx.beginPath();

            for (let i = 0; i <= numPoints; i++) {
                const angle = i * angleStep;
                const magnitude = magnitudes[i % numPoints];
                const radius = layerRadius + magnitude * 80;

                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;

                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }

            this.ctx.closePath();

            const scheme = COLOR_SCHEMES[this.settings.colorScheme];
            const color = scheme.primary;
            this.ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${alpha})`;
            this.ctx.fill();
        }
    }

    /**
     * Mode 8: Liquid Mercury
     */
    renderLiquidMercury(magnitudes) {
        const numPoints = magnitudes.length;
        const angleStep = (Math.PI * 2) / numPoints;
        const innerRadius = this.getEffectiveInnerRadius();
        const time = this.frameCounter * 0.02;

        const scheme = COLOR_SCHEMES[this.settings.colorScheme];
        const color1 = scheme.primary;
        const color2 = scheme.secondary;

        this.ctx.shadowBlur = 25;
        this.ctx.shadowColor = `rgba(${color1[0]}, ${color1[1]}, ${color1[2]}, 0.5)`;

        this.ctx.beginPath();

        for (let i = 0; i <= numPoints; i++) {
            const angle = i * angleStep;
            const magnitude = magnitudes[i % numPoints];
            const wave = Math.sin(angle * 3 + time) * 15;
            const radius = innerRadius + magnitude * this.maxRadius * 0.4 + wave;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            if (i === 0) {
                this.ctx.moveTo(x, y);
            } else {
                this.ctx.lineTo(x, y);
            }
        }

        this.ctx.closePath();

        // Fluid gradient using color scheme (ensure positive radii)
        const r1 = Math.max(0, innerRadius * 0.5);
        const r2 = Math.max(r1 + 1, innerRadius + this.maxRadius * 0.4);
        const gradient = this.ctx.createRadialGradient(
            this.centerX, this.centerY, r1,
            this.centerX, this.centerY, r2
        );

        gradient.addColorStop(0, `rgba(${color1[0]}, ${color1[1]}, ${color1[2]}, 0.9)`);
        gradient.addColorStop(0.5, `rgba(${Math.round((color1[0] + color2[0]) / 2)}, ${Math.round((color1[1] + color2[1]) / 2)}, ${Math.round((color1[2] + color2[2]) / 2)}, 0.8)`);
        gradient.addColorStop(1, `rgba(${color2[0]}, ${color2[1]}, ${color2[2]}, 0.6)`);

        this.ctx.fillStyle = gradient;
        this.ctx.fill();

        this.ctx.strokeStyle = `rgba(${color1[0]}, ${color1[1]}, ${color1[2]}, 0.9)`;
        this.ctx.lineWidth = 2;
        this.ctx.stroke();

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 9: Aurora Waves
     */
    renderAuroraWaves(magnitudes) {
        const numWaves = 4;
        const innerRadius = this.getEffectiveInnerRadius();
        const time = this.frameCounter * 0.01;

        for (let wave = 0; wave < numWaves; wave++) {
            const waveOffset = wave * 0.5;
            const numPoints = magnitudes.length;
            const angleStep = (Math.PI * 2) / numPoints;

            this.ctx.beginPath();

            for (let i = 0; i <= numPoints; i++) {
                const angle = i * angleStep;
                const magnitude = magnitudes[i % numPoints];
                const waveMod = Math.sin(angle * 2 + time + waveOffset) * 20;
                const radius = innerRadius + (wave * 30) + magnitude * 60 + waveMod;

                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;

                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }

            this.ctx.closePath();

            const alpha = 0.3 - (wave * 0.05);
            const color = this.getColor(wave * 25, 100);
            const rgbMatch = color.match(/\d+/g);
            if (rgbMatch) {
                this.ctx.fillStyle = `rgba(${rgbMatch[0]}, ${rgbMatch[1]}, ${rgbMatch[2]}, ${alpha})`;
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 10: Mandala Growth
     */
    renderMandalaGrowth(magnitudes) {
        const symmetry = 8;
        const numBars = magnitudes.length / symmetry;
        const angleStep = (Math.PI * 2) / (numBars * symmetry);
        const innerRadius = this.getEffectiveInnerRadius();

        this.ctx.shadowBlur = 20;

        for (let sym = 0; sym < symmetry; sym++) {
            const symAngle = (Math.PI * 2 / symmetry) * sym;

            for (let i = 0; i < numBars; i++) {
                const angle = i * angleStep * symmetry + symAngle;
                const magnitude = magnitudes[i % magnitudes.length];
                const barLength = magnitude * this.maxRadius * 0.5;

                const x1 = this.centerX + Math.cos(angle) * innerRadius;
                const y1 = this.centerY + Math.sin(angle) * innerRadius;
                const x2 = this.centerX + Math.cos(angle) * (innerRadius + barLength);
                const y2 = this.centerY + Math.sin(angle) * (innerRadius + barLength);

                const color = this.getColor(i, numBars);
                this.ctx.shadowColor = color;
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 3;
                this.ctx.lineCap = 'round';

                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x2, y2);
                this.ctx.stroke();
            }
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 11: Frequency Bars
     */
    renderFrequencyBars(magnitudes) {
        const numBars = magnitudes.length;
        const barWidth = this.canvas.width / numBars;
        const centerY = this.canvas.height / 2;

        this.ctx.shadowBlur = 10;

        for (let i = 0; i < numBars; i++) {
            const barHeight = magnitudes[i] * this.canvas.height * 0.7;
            const x = i * barWidth;
            const y = centerY - barHeight / 2;

            const color = this.getColor(i, numBars);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;

            this.ctx.fillRect(x, y, barWidth * 0.8, barHeight);
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 12: Linear Spectrum
     */
    renderLinearSpectrum(magnitudes) {
        const numBars = magnitudes.length;
        const barWidth = this.canvas.width / numBars;
        const baseY = this.canvas.height * 0.75;

        this.ctx.shadowBlur = 12;

        for (let i = 0; i < numBars; i++) {
            const barHeight = magnitudes[i] * this.canvas.height * 0.6;
            const x = i * barWidth;
            const y = baseY - barHeight;

            const color = this.getColor(i, numBars);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;

            this.ctx.fillRect(x, y, barWidth * 0.9, barHeight);
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 13: Fireworks
     */
    renderFireworks(magnitudes) {
        const numBars = magnitudes.length;
        const angleStep = (Math.PI * 2) / numBars;

        this.ctx.shadowBlur = 30;

        for (let i = 0; i < numBars; i++) {
            const angle = i * angleStep;
            const magnitude = magnitudes[i];
            const distance = magnitude * this.maxRadius * 1.2;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            // Trail effect
            for (let t = 0; t < 3; t++) {
                const trailDist = distance * (0.5 + t * 0.2);
                const tx = this.centerX + Math.cos(angle) * trailDist;
                const ty = this.centerY + Math.sin(angle) * trailDist;
                const size = (3 - t) * magnitude * 3;

                const color = this.getColor(i, numBars);
                this.ctx.shadowColor = color;
                this.ctx.fillStyle = color;
                this.ctx.globalAlpha = 0.3 + t * 0.3;

                this.ctx.beginPath();
                this.ctx.arc(tx, ty, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 14: Cosmic Dust
     */
    renderCosmicDust(magnitudes) {
        const numParticles = magnitudes.length * 3;
        const time = this.frameCounter * 0.01;

        this.ctx.shadowBlur = 20;

        for (let i = 0; i < numParticles; i++) {
            const angle = (i / numParticles) * Math.PI * 2 + time;
            const magnitude = magnitudes[i % magnitudes.length];
            const spiral = i / numParticles;
            const distance = this.getEffectiveInnerRadius() + spiral * this.maxRadius * 0.8 + magnitude * 50;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;
            const size = 2 + magnitude * 4;

            const color = this.getColor(i, numParticles);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = 0.6 + magnitude * 0.4;

            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 15: Particle Rain
     */
    renderParticleRain(magnitudes) {
        const numBars = magnitudes.length;
        const barWidth = this.canvas.width / numBars;

        this.ctx.shadowBlur = 15;

        for (let i = 0; i < numBars; i++) {
            const magnitude = magnitudes[i];
            const numDrops = Math.floor(magnitude * 8);
            const x = i * barWidth + barWidth / 2;

            for (let d = 0; d < numDrops; d++) {
                const y = (d / numDrops) * this.canvas.height;
                const size = 2 + magnitude * 3;

                const color = this.getColor(i, numBars);
                this.ctx.shadowColor = color;
                this.ctx.fillStyle = color;
                this.ctx.globalAlpha = 0.4 + (d / numDrops) * 0.4;

                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 16: Snow Particles
     */
    renderSnowParticles(magnitudes) {
        const numFlakes = magnitudes.length * 2;
        const time = this.frameCounter * 0.005;

        this.ctx.shadowBlur = 10;

        for (let i = 0; i < numFlakes; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const x = (i / numFlakes) * this.canvas.width + Math.sin(time + i) * 30;
            const y = ((time * 50 + i * 50) % this.canvas.height);
            const size = 1 + magnitude * 4;

            const color = this.getColor(i, numFlakes);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = 0.5 + magnitude * 0.5;

            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 18: Pixel Clouds
     */
    renderPixelClouds(magnitudes) {
        const pixelSize = 12;
        const numClouds = magnitudes.length / 2;
        const time = this.frameCounter * 0.02;

        for (let i = 0; i < numClouds; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const x = ((i * 137.5 + time * 20) % this.canvas.width);
            const y = (i * 17) % this.canvas.height;
            const size = Math.floor(2 + magnitude * 5);

            const color = this.getColor(i, numClouds);
            this.ctx.fillStyle = color;

            // Draw pixelated cloud
            for (let px = 0; px < size; px++) {
                for (let py = 0; py < size; py++) {
                    if (Math.random() > 0.3) {
                        this.ctx.fillRect(x + px * pixelSize, y + py * pixelSize, pixelSize, pixelSize);
                    }
                }
            }
        }
    }

    /**
     * Mode 19: Neon Cityscape
     */
    renderNeonCityscape(magnitudes) {
        const numBuildings = magnitudes.length;
        const buildingWidth = this.canvas.width / numBuildings;
        const baseY = this.canvas.height * 0.9;

        this.ctx.shadowBlur = 25;

        for (let i = 0; i < numBuildings; i++) {
            const magnitude = magnitudes[i];
            const height = 50 + magnitude * this.canvas.height * 0.7;
            const x = i * buildingWidth;
            const y = baseY - height;

            const color = this.getColor(i, numBuildings);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 2;

            // Building outline
            this.ctx.strokeRect(x + 2, y, buildingWidth - 4, height);

            // Windows
            const windowRows = Math.floor(height / 20);
            for (let w = 0; w < windowRows; w++) {
                if (magnitude > 0.3) {
                    this.ctx.fillStyle = color;
                    this.ctx.globalAlpha = 0.6;
                    this.ctx.fillRect(x + buildingWidth / 4, y + w * 20 + 5, buildingWidth / 4, 10);
                }
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 20: Lava Lamp
     */
    renderLavaLamp(magnitudes) {
        const numBlobs = Math.min(magnitudes.length / 4, 12);
        const time = this.frameCounter * 0.01;

        this.ctx.shadowBlur = 30;

        for (let i = 0; i < numBlobs; i++) {
            const magnitude = magnitudes[i * 4] || magnitudes[i];
            const x = this.centerX + Math.sin(time + i * 2) * this.maxRadius * 0.5;
            const y = this.centerY + Math.cos(time * 0.7 + i * 1.5) * this.maxRadius * 0.6;
            const radius = 30 + magnitude * 80;

            const color = this.getColor(i * 8, numBlobs * 8);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = 0.6;

            this.ctx.beginPath();
            this.ctx.arc(x, y, radius, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 21: Ink Drops
     */
    renderInkDrops(magnitudes) {
        const numDrops = Math.min(magnitudes.length / 3, 20);
        const time = this.frameCounter * 0.02;

        this.ctx.shadowBlur = 25;

        for (let i = 0; i < numDrops; i++) {
            const magnitude = magnitudes[i * 3] || magnitudes[i];
            const age = (time + i) % 10;
            const expansion = age / 10;

            const x = this.centerX + (Math.random() - 0.5) * 100;
            const y = this.centerY + (Math.random() - 0.5) * 100;
            const radius = expansion * magnitude * 100;

            const color = this.getColor(i * 4, numDrops * 4);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = Math.max(0, 0.8 - expansion);

            this.ctx.beginPath();
            this.ctx.arc(x, y, radius, 0, Math.PI * 2);
            this.ctx.fill();

            // Tendrils
            for (let t = 0; t < 5; t++) {
                const angle = (t / 5) * Math.PI * 2 + i;
                const length = expansion * magnitude * 120;
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                this.ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 22: Water Ripples
     */
    renderWaterRipples(magnitudes) {
        const numRipples = 8;
        const time = this.frameCounter * 0.05;

        this.ctx.shadowBlur = 15;

        for (let r = 0; r < numRipples; r++) {
            const phase = (time + r * 0.5) % 5;
            const radius = this.getEffectiveInnerRadius() * 0.5 + phase * 60;

            const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
            const thickness = 1 + avgMagnitude * 3;

            const color = this.getColor(r * 10, numRipples * 10);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = thickness;
            this.ctx.globalAlpha = Math.max(0, 1 - phase / 5);

            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 23: Crystal Growth
     */
    renderCrystalGrowth(magnitudes) {
        const numCrystals = magnitudes.length;
        const angleStep = (Math.PI * 2) / numCrystals;
        const innerRadius = this.getEffectiveInnerRadius();

        this.ctx.shadowBlur = 20;

        for (let i = 0; i < numCrystals; i++) {
            const angle = i * angleStep;
            const magnitude = magnitudes[i];
            const length = magnitude * this.maxRadius * 0.6;

            const x1 = this.centerX + Math.cos(angle) * innerRadius;
            const y1 = this.centerY + Math.sin(angle) * innerRadius;
            const x2 = this.centerX + Math.cos(angle) * (innerRadius + length);
            const y2 = this.centerY + Math.sin(angle) * (innerRadius + length);

            const color = this.getColor(i, numCrystals);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;

            // Main crystal spike
            this.ctx.lineWidth = 4;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();

            // Crystal branches
            if (magnitude > 0.4) {
                for (let b = 0; b < 3; b++) {
                    const branchAngle = angle + (Math.random() - 0.5) * 0.5;
                    const branchLength = length * (0.3 + Math.random() * 0.3);
                    const branchX = x1 + Math.cos(branchAngle) * branchLength;
                    const branchY = y1 + Math.sin(branchAngle) * branchLength;

                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, y1);
                    this.ctx.lineTo(branchX, branchY);
                    this.ctx.stroke();
                }
            }
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 24: Frequency Flowers
     */
    renderFrequencyFlowers(magnitudes) {
        const numPetals = magnitudes.length;
        const angleStep = (Math.PI * 2) / numPetals;
        const innerRadius = this.getEffectiveInnerRadius();

        this.ctx.shadowBlur = 20;

        for (let i = 0; i < numPetals; i++) {
            const angle = i * angleStep;
            const magnitude = magnitudes[i];
            const petalLength = magnitude * this.maxRadius * 0.5;

            const color = this.getColor(i, numPetals);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = 0.7;

            // Draw petal shape
            this.ctx.beginPath();
            const x1 = this.centerX + Math.cos(angle - 0.2) * innerRadius;
            const y1 = this.centerY + Math.sin(angle - 0.2) * innerRadius;
            const x2 = this.centerX + Math.cos(angle) * (innerRadius + petalLength);
            const y2 = this.centerY + Math.sin(angle) * (innerRadius + petalLength);
            const x3 = this.centerX + Math.cos(angle + 0.2) * innerRadius;
            const y3 = this.centerY + Math.sin(angle + 0.2) * innerRadius;

            this.ctx.moveTo(x1, y1);
            this.ctx.quadraticCurveTo(x2, y2, x3, y3);
            this.ctx.lineTo(this.centerX, this.centerY);
            this.ctx.closePath();
            this.ctx.fill();
        }

        // Draw center
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        this.ctx.fillStyle = this.getColor(0, numPetals);
        this.ctx.globalAlpha = 1;
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, innerRadius * 0.3 + avgMagnitude * 20, 0, Math.PI * 2);
        this.ctx.fill();

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 25: Fire Dance
     */
    renderFireDance(magnitudes) {
        const numFlames = magnitudes.length;
        const flameWidth = this.canvas.width / numFlames;
        const baseY = this.canvas.height * 0.8;

        this.ctx.shadowBlur = 30;

        for (let i = 0; i < numFlames; i++) {
            const magnitude = magnitudes[i];
            const x = i * flameWidth + flameWidth / 2;
            const height = magnitude * this.canvas.height * 0.6;

            const color = this.getColor(i, numFlames);
            this.ctx.shadowColor = color;

            // Draw flame shape
            this.ctx.beginPath();
            this.ctx.moveTo(x, baseY);

            for (let h = 0; h < height; h += 10) {
                const flicker = Math.sin(this.frameCounter * 0.1 + i + h * 0.1) * 5;
                const width = (1 - h / height) * flameWidth * 0.4;
                this.ctx.lineTo(x + flicker, baseY - h);
            }

            this.ctx.lineTo(x, baseY - height);
            this.ctx.lineTo(x, baseY);
            this.ctx.closePath();

            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = 0.7;
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 26: Ocean Bioluminescence
     */
    renderBioluminescence(magnitudes) {
        const numOrganisms = magnitudes.length * 2;
        const time = this.frameCounter * 0.01;

        this.ctx.shadowBlur = 25;

        for (let i = 0; i < numOrganisms; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const swimPattern = Math.sin(time + i * 0.5) * 100;
            const x = ((i / numOrganisms) * this.canvas.width + swimPattern) % this.canvas.width;
            const y = (i * 17 % this.canvas.height);
            const size = 3 + magnitude * 8;
            const pulse = Math.sin(time * 2 + i) * 0.3 + 0.7;

            const color = this.getColor(i, numOrganisms);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = pulse * magnitude;

            // Draw organism
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();

            // Trail
            for (let t = 1; t < 4; t++) {
                this.ctx.globalAlpha = (pulse * magnitude) / (t + 1);
                this.ctx.beginPath();
                this.ctx.arc(x - t * 8, y, size * (1 - t * 0.2), 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 27: Kaleidoscope
     */
    renderKaleidoscope(magnitudes) {
        const segments = 8;
        const numBars = magnitudes.length / segments;
        const angleStep = (Math.PI * 2) / segments;
        const innerRadius = this.getEffectiveInnerRadius();

        this.ctx.shadowBlur = 15;

        for (let seg = 0; seg < segments; seg++) {
            this.ctx.save();
            this.ctx.translate(this.centerX, this.centerY);
            this.ctx.rotate(seg * angleStep);

            for (let i = 0; i < numBars; i++) {
                const magnitude = magnitudes[Math.floor(i % magnitudes.length)];
                const barAngle = (i / numBars) * angleStep;
                const distance = innerRadius + magnitude * this.maxRadius * 0.5;

                const x = Math.cos(barAngle) * distance;
                const y = Math.sin(barAngle) * distance;
                const size = 3 + magnitude * 6;

                const color = this.getColor(i, numBars);
                this.ctx.shadowColor = color;
                this.ctx.fillStyle = color;

                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, Math.PI * 2);
                this.ctx.fill();
            }

            this.ctx.restore();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 28: Fractal Bloom
     */
    renderFractalBloom(magnitudes) {
        const depth = 4;
        const baseAngle = this.frameCounter * 0.01;

        this.ctx.shadowBlur = 15;

        const drawBranch = (x, y, angle, length, iteration, colorIndex) => {
            if (iteration >= depth) return;

            const magnitude = magnitudes[colorIndex % magnitudes.length];
            const endX = x + Math.cos(angle) * length;
            const endY = y + Math.sin(angle) * length;

            const color = this.getColor(colorIndex, magnitudes.length);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = (depth - iteration) * magnitude * 2;

            this.ctx.beginPath();
            this.ctx.moveTo(x, y);
            this.ctx.lineTo(endX, endY);
            this.ctx.stroke();

            const newLength = length * 0.7;
            drawBranch(endX, endY, angle - 0.5, newLength, iteration + 1, colorIndex + 1);
            drawBranch(endX, endY, angle + 0.5, newLength, iteration + 1, colorIndex + 2);
        };

        for (let i = 0; i < 6; i++) {
            const startAngle = baseAngle + (i / 6) * Math.PI * 2;
            drawBranch(this.centerX, this.centerY, startAngle, 80, 0, i * 10);
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 29: Morphing Geometry
     */
    renderMorphingGeometry(magnitudes) {
        const time = this.frameCounter * 0.02;
        const sides = 3 + Math.floor(Math.sin(time) * 3 + 4);
        const angleStep = (Math.PI * 2) / sides;
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const radius = this.getEffectiveInnerRadius() + avgMagnitude * this.maxRadius * 0.4;

        this.ctx.shadowBlur = 20;

        // Main shape
        this.ctx.beginPath();
        for (let i = 0; i <= sides; i++) {
            const angle = i * angleStep + time;
            const magnitude = magnitudes[i % magnitudes.length];
            const r = radius + magnitude * 50;
            const x = this.centerX + Math.cos(angle) * r;
            const y = this.centerY + Math.sin(angle) * r;

            if (i === 0) {
                this.ctx.moveTo(x, y);
            } else {
                this.ctx.lineTo(x, y);
            }
        }
        this.ctx.closePath();

        const color = this.getColor(Math.floor(time * 10), 100);
        this.ctx.shadowColor = color;
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = 3;
        this.ctx.stroke();

        // Inner wireframe
        this.ctx.globalAlpha = 0.5;
        this.ctx.beginPath();
        for (let i = 0; i < sides; i++) {
            const angle = i * angleStep + time;
            const x = this.centerX + Math.cos(angle) * radius * 0.5;
            const y = this.centerY + Math.sin(angle) * radius * 0.5;

            this.ctx.moveTo(this.centerX, this.centerY);
            this.ctx.lineTo(x, y);
        }
        this.ctx.stroke();

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 30: Spiral Galaxy
     */
    renderSpiralGalaxy(magnitudes) {
        const numArms = 3;
        const particlesPerArm = magnitudes.length / numArms;
        const time = this.frameCounter * 0.01;

        this.ctx.shadowBlur = 20;

        for (let arm = 0; arm < numArms; arm++) {
            const armAngle = (arm / numArms) * Math.PI * 2;

            for (let i = 0; i < particlesPerArm; i++) {
                const t = i / particlesPerArm;
                const magnitude = magnitudes[Math.floor(arm * particlesPerArm + i) % magnitudes.length];
                const spiralAngle = armAngle + t * Math.PI * 4 + time;
                const distance = this.getEffectiveInnerRadius() * 0.3 + t * this.maxRadius * 0.8;

                const x = this.centerX + Math.cos(spiralAngle) * distance;
                const y = this.centerY + Math.sin(spiralAngle) * distance;
                const size = 2 + magnitude * 5;

                const color = this.getColor(Math.floor(arm * particlesPerArm + i), magnitudes.length);
                this.ctx.shadowColor = color;
                this.ctx.fillStyle = color;
                this.ctx.globalAlpha = 0.6 + magnitude * 0.4;

                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 31: DNA Helix
     */
    renderDnaHelix(magnitudes) {
        const time = this.frameCounter * 0.05;
        const numPairs = magnitudes.length / 2;
        const spacing = this.canvas.height / numPairs;

        this.ctx.shadowBlur = 15;

        for (let i = 0; i < numPairs; i++) {
            const y = i * spacing + spacing / 2;
            const phase = i * 0.5 + time;
            const magnitude = magnitudes[i % magnitudes.length];

            const x1 = this.centerX + Math.sin(phase) * (100 + magnitude * 50);
            const x2 = this.centerX - Math.sin(phase) * (100 + magnitude * 50);

            const color = this.getColor(i, numPairs);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;

            // Base pair connection
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y);
            this.ctx.lineTo(x2, y);
            this.ctx.stroke();

            // Nucleotides
            this.ctx.fillStyle = color;
            this.ctx.beginPath();
            this.ctx.arc(x1, y, 4 + magnitude * 4, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.arc(x2, y, 4 + magnitude * 4, 0, Math.PI * 2);
            this.ctx.fill();

            // Helix strands
            if (i > 0) {
                const prevY = (i - 1) * spacing + spacing / 2;
                const prevPhase = (i - 1) * 0.5 + time;
                const prevX1 = this.centerX + Math.sin(prevPhase) * (100 + magnitude * 50);
                const prevX2 = this.centerX - Math.sin(prevPhase) * (100 + magnitude * 50);

                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(prevX1, prevY);
                this.ctx.lineTo(x1, y);
                this.ctx.stroke();
                this.ctx.beginPath();
                this.ctx.moveTo(prevX2, prevY);
                this.ctx.lineTo(x2, y);
                this.ctx.stroke();
            }
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 32: Quantum Strings
     */
    renderQuantumStrings(magnitudes) {
        const numStrings = Math.min(magnitudes.length / 2, 20);
        const time = this.frameCounter * 0.02;

        this.ctx.shadowBlur = 20;

        for (let s = 0; s < numStrings; s++) {
            const magnitude = magnitudes[s * 2 % magnitudes.length];
            const startX = (s / numStrings) * this.canvas.width;
            const numPoints = 50;

            const color = this.getColor(s, numStrings);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 1 + magnitude * 2;

            this.ctx.beginPath();

            for (let i = 0; i < numPoints; i++) {
                const t = i / numPoints;
                const x = startX + (t * this.canvas.width);
                const y = this.centerY + Math.sin(t * Math.PI * 4 + time + s) * magnitude * 100;

                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }

            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 33: Magnetic Fields
     */
    renderMagneticFields(magnitudes) {
        const numLines = magnitudes.length / 2;

        this.ctx.shadowBlur = 10;

        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const startY = (i / numLines) * this.canvas.height;

            const color = this.getColor(i, numLines);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 1 + magnitude * 2;

            this.ctx.beginPath();

            const numPoints = 100;
            for (let p = 0; p < numPoints; p++) {
                const t = p / numPoints;
                const x = t * this.canvas.width;

                // Magnetic field curve
                const distFromCenter = Math.abs(startY - this.canvas.height / 2);
                const curve = Math.sin(t * Math.PI) * magnitude * (100 - distFromCenter * 0.3);
                const y = startY + curve;

                if (p === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }

            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 34: Gravitational Lens
     */
    renderGravitationalLens(magnitudes) {
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const numRings = 8;

        this.ctx.shadowBlur = 20;

        // Central mass
        const massRadius = 30 + avgMagnitude * 40;
        const color1 = this.getColor(0, numRings);
        this.ctx.shadowColor = color1;
        this.ctx.fillStyle = color1;
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, massRadius, 0, Math.PI * 2);
        this.ctx.fill();

        // Lensing rings
        for (let r = 0; r < numRings; r++) {
            const magnitude = magnitudes[r * (magnitudes.length / numRings)] || avgMagnitude;
            const baseRadius = this.getEffectiveInnerRadius() + r * 40;

            const color = this.getColor(r * 10, numRings * 10);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 2 + magnitude * 3;
            this.ctx.globalAlpha = 0.7;

            // Distorted ring
            this.ctx.beginPath();
            const numPoints = 100;
            for (let i = 0; i <= numPoints; i++) {
                const angle = (i / numPoints) * Math.PI * 2;
                const distortion = Math.sin(angle * 2) * magnitude * 20;
                const radius = baseRadius + distortion;

                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;

                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }
            this.ctx.stroke();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 35: Seismic Waves
     */
    renderSeismicWaves(magnitudes) {
        const centerY = this.canvas.height / 2;
        const numPoints = magnitudes.length;
        const spacing = this.canvas.width / numPoints;

        this.ctx.shadowBlur = 15;

        // Draw multiple seismic traces
        for (let trace = 0; trace < 3; trace++) {
            const yOffset = (trace - 1) * 100;
            const color = this.getColor(trace * 20, 60);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 2;

            this.ctx.beginPath();

            for (let i = 0; i < numPoints; i++) {
                const x = i * spacing;
                const magnitude = magnitudes[i];
                const amplitude = magnitude * 80;
                const y = centerY + yOffset + (Math.random() - 0.5) * amplitude;

                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }

            this.ctx.stroke();
        }

        // Draw grid
        this.ctx.strokeStyle = 'rgba(100, 100, 100, 0.2)';
        this.ctx.lineWidth = 1;
        for (let i = 0; i < 10; i++) {
            const y = (i / 10) * this.canvas.height;
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.canvas.width, y);
            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 36: Tunnel Vision
     */
    renderTunnelVision(magnitudes) {
        const numRings = 20;
        const time = this.frameCounter * 0.05;

        this.ctx.shadowBlur = 25;

        for (let r = 0; r < numRings; r++) {
            const t = (r + time) % numRings;
            const radius = (t / numRings) * this.maxRadius * 1.5;
            const magnitude = magnitudes[r % magnitudes.length];

            const color = this.getColor(r, numRings);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 3 + magnitude * 10;
            this.ctx.globalAlpha = 1 - (t / numRings);

            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 37: Matrix Code
     */
    renderMatrixCode(magnitudes) {
        const columns = Math.min(magnitudes.length, 60);
        const columnWidth = this.canvas.width / columns;
        const charHeight = 20;

        this.ctx.shadowBlur = 15;
        this.ctx.font = '14px monospace';

        for (let i = 0; i < columns; i++) {
            const magnitude = magnitudes[i];
            const numChars = Math.floor(magnitude * 30);

            const color = this.getColor(i, columns);
            this.ctx.shadowColor = color;

            for (let c = 0; c < numChars; c++) {
                const x = i * columnWidth + columnWidth / 2;
                const y = ((this.frameCounter * magnitude * 2 + c * charHeight) % this.canvas.height);
                const char = String.fromCharCode(0x30A0 + Math.floor(Math.random() * 96));

                const alpha = 1 - (c / numChars);
                this.ctx.fillStyle = color;
                this.ctx.globalAlpha = alpha * magnitude;
                this.ctx.fillText(char, x, y);
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 38: Hologram Glitch
     */
    renderHologramGlitch(magnitudes) {
        const numBars = magnitudes.length;
        const angleStep = (Math.PI * 2) / numBars;
        const innerRadius = this.getEffectiveInnerRadius();
        const glitchIntensity = Math.max(...magnitudes);

        this.ctx.shadowBlur = 20;

        for (let i = 0; i < numBars; i++) {
            const angle = i * angleStep;
            const magnitude = magnitudes[i];

            // Glitch offset
            const glitchX = (Math.random() - 0.5) * glitchIntensity * 20;
            const glitchY = (Math.random() - 0.5) * glitchIntensity * 20;

            const barLength = magnitude * this.maxRadius * 0.6;
            const x1 = this.centerX + Math.cos(angle) * innerRadius + glitchX;
            const y1 = this.centerY + Math.sin(angle) * innerRadius + glitchY;
            const x2 = this.centerX + Math.cos(angle) * (innerRadius + barLength) + glitchX;
            const y2 = this.centerY + Math.sin(angle) * (innerRadius + barLength) + glitchY;

            const color = this.getColor(i, numBars);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 3;
            this.ctx.globalAlpha = 0.6 + Math.random() * 0.4;

            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 39: Circuit Board
     */
    renderCircuitBoard(magnitudes) {
        const gridSize = 40;
        const cols = Math.floor(this.canvas.width / gridSize);
        const rows = Math.floor(this.canvas.height / gridSize);

        this.ctx.shadowBlur = 15;

        // Draw grid
        this.ctx.strokeStyle = this.getColor(0, magnitudes.length);
        this.ctx.lineWidth = 1;
        this.ctx.globalAlpha = 0.3;

        for (let x = 0; x < cols; x++) {
            for (let y = 0; y < rows; y++) {
                this.ctx.strokeRect(x * gridSize, y * gridSize, gridSize, gridSize);
            }
        }

        this.ctx.globalAlpha = 1;

        // Draw active paths
        const numPaths = Math.min(magnitudes.length / 2, cols);

        for (let i = 0; i < numPaths; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            if (magnitude < 0.3) continue;

            const x = (i % cols) * gridSize + gridSize / 2;
            const segments = Math.floor(magnitude * 10);

            const color = this.getColor(i, numPaths);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 2;

            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);

            let currentY = 0;
            for (let s = 0; s < segments; s++) {
                currentY += gridSize;
                if (currentY > this.canvas.height) break;

                const horizontalShift = (Math.random() > 0.5 ? 1 : -1) * gridSize;
                this.ctx.lineTo(x, currentY);
                this.ctx.lineTo(x + horizontalShift, currentY);
            }

            this.ctx.stroke();

            // Draw nodes
            this.ctx.fillStyle = color;
            this.ctx.beginPath();
            this.ctx.arc(x, 0, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 40: Neural Network
     */
    renderNeuralNetwork(magnitudes) {
        const layers = 4;
        const nodesPerLayer = 8;
        const layerSpacing = this.canvas.width / (layers + 1);
        const nodeSpacing = this.canvas.height / (nodesPerLayer + 1);

        this.ctx.shadowBlur = 15;

        // Draw connections
        for (let l = 0; l < layers - 1; l++) {
            for (let n1 = 0; n1 < nodesPerLayer; n1++) {
                for (let n2 = 0; n2 < nodesPerLayer; n2++) {
                    const magnitude = magnitudes[(l * nodesPerLayer + n1) % magnitudes.length];

                    if (magnitude > 0.4) {
                        const x1 = (l + 1) * layerSpacing;
                        const y1 = (n1 + 1) * nodeSpacing;
                        const x2 = (l + 2) * layerSpacing;
                        const y2 = (n2 + 1) * nodeSpacing;

                        const color = this.getColor(l * nodesPerLayer + n1, magnitudes.length);
                        this.ctx.shadowColor = color;
                        this.ctx.strokeStyle = color;
                        this.ctx.lineWidth = magnitude * 2;
                        this.ctx.globalAlpha = magnitude * 0.6;

                        this.ctx.beginPath();
                        this.ctx.moveTo(x1, y1);
                        this.ctx.lineTo(x2, y2);
                        this.ctx.stroke();
                    }
                }
            }
        }

        this.ctx.globalAlpha = 1;

        // Draw nodes
        for (let l = 0; l < layers; l++) {
            for (let n = 0; n < nodesPerLayer; n++) {
                const x = (l + 1) * layerSpacing;
                const y = (n + 1) * nodeSpacing;
                const magnitude = magnitudes[(l * nodesPerLayer + n) % magnitudes.length];
                const size = 5 + magnitude * 10;

                const color = this.getColor(l * nodesPerLayer + n, magnitudes.length);
                this.ctx.shadowColor = color;
                this.ctx.fillStyle = color;

                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 41: Lightning Strikes
     */
    renderLightningStrikes(magnitudes) {
        const numBolts = magnitudes.length;

        this.ctx.shadowBlur = 25;

        for (let i = 0; i < numBolts; i++) {
            const magnitude = magnitudes[i];
            if (magnitude < 0.5) continue;

            const startX = (i / numBolts) * this.canvas.width;
            const startY = 0;
            const endY = this.canvas.height;

            const color = this.getColor(i, numBolts);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 2 + magnitude * 4;

            this.ctx.beginPath();
            this.ctx.moveTo(startX, startY);

            let currentX = startX;
            let currentY = startY;
            const segments = 10 + Math.floor(magnitude * 10);

            for (let s = 0; s < segments; s++) {
                currentY += (endY - startY) / segments;
                currentX += (Math.random() - 0.5) * 40 * magnitude;

                this.ctx.lineTo(currentX, currentY);

                // Branch
                if (Math.random() > 0.7) {
                    const branchX = currentX + (Math.random() - 0.5) * 60;
                    const branchY = currentY + 40;
                    this.ctx.moveTo(currentX, currentY);
                    this.ctx.lineTo(branchX, branchY);
                    this.ctx.moveTo(currentX, currentY);
                }
            }

            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 42: Plasma Storm
     */
    renderPlasmaStorm(magnitudes) {
        const time = this.frameCounter * 0.03;
        const numVortices = 3;

        this.ctx.shadowBlur = 30;

        for (let v = 0; v < numVortices; v++) {
            const vortexAngle = (v / numVortices) * Math.PI * 2 + time;
            const vortexDist = this.getEffectiveInnerRadius() * 0.5;
            const vortexX = this.centerX + Math.cos(vortexAngle) * vortexDist;
            const vortexY = this.centerY + Math.sin(vortexAngle) * vortexDist;

            const numParticles = magnitudes.length / numVortices;

            for (let i = 0; i < numParticles; i++) {
                const magnitude = magnitudes[v * numParticles + i % magnitudes.length];
                const angle = (i / numParticles) * Math.PI * 2 + time * 2;
                const distance = magnitude * 100;

                const x = vortexX + Math.cos(angle) * distance;
                const y = vortexY + Math.sin(angle) * distance;
                const size = 2 + magnitude * 6;

                const color = this.getColor(v * numParticles + i, magnitudes.length);
                this.ctx.shadowColor = color;
                this.ctx.fillStyle = color;
                this.ctx.globalAlpha = 0.7;

                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 43: Laser Show
     */
    renderLaserShow(magnitudes) {
        const numLasers = Math.min(magnitudes.length / 2, 20);
        const time = this.frameCounter * 0.05;

        this.ctx.shadowBlur = 30;

        for (let i = 0; i < numLasers; i++) {
            const magnitude = magnitudes[i * 2 % magnitudes.length];
            if (magnitude < 0.3) continue;

            const angle = (i / numLasers) * Math.PI * 2 + time + magnitude;
            const length = this.maxRadius * 1.5;

            const x1 = this.centerX;
            const y1 = this.centerY;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const color = this.getColor(i, numLasers);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 3 + magnitude * 5;
            this.ctx.globalAlpha = 0.8;

            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();

            // End glow
            this.ctx.fillStyle = color;
            this.ctx.beginPath();
            this.ctx.arc(x2, y2, 5 + magnitude * 10, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 44: Energy Pulses
     */
    renderEnergyPulses(magnitudes) {
        const numPulses = 6;
        const time = this.frameCounter * 0.1;

        this.ctx.shadowBlur = 25;

        for (let p = 0; p < numPulses; p++) {
            const phase = (time + p * 0.5) % 3;
            const radius = this.getEffectiveInnerRadius() + phase * 100;
            const magnitude = magnitudes[p * (magnitudes.length / numPulses) % magnitudes.length];

            const color = this.getColor(p * 10, numPulses * 10);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 3 + magnitude * 8;
            this.ctx.globalAlpha = Math.max(0, 1 - phase / 3);

            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 45: Rainbow Prism
     */
    renderRainbowPrism(magnitudes) {
        const numRays = magnitudes.length;
        const angleStep = (Math.PI * 2) / numRays;
        const innerRadius = this.getEffectiveInnerRadius() * 0.5;

        this.ctx.shadowBlur = 20;

        for (let i = 0; i < numRays; i++) {
            const angle = i * angleStep;
            const magnitude = magnitudes[i];
            const length = magnitude * this.maxRadius * 0.8;

            const x1 = this.centerX + Math.cos(angle) * innerRadius;
            const y1 = this.centerY + Math.sin(angle) * innerRadius;
            const x2 = this.centerX + Math.cos(angle) * (innerRadius + length);
            const y2 = this.centerY + Math.sin(angle) * (innerRadius + length);

            // Create gradient for each ray
            const gradient = this.ctx.createLinearGradient(x1, y1, x2, y2);
            const color1 = this.getColor(i, numRays);
            const color2 = this.getColor((i + numRays / 6) % numRays, numRays);

            gradient.addColorStop(0, color1);
            gradient.addColorStop(1, color2);

            this.ctx.shadowColor = color1;
            this.ctx.strokeStyle = gradient;
            this.ctx.lineWidth = 4 + magnitude * 6;
            this.ctx.globalAlpha = 0.8;

            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }

        // Central prism
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        this.ctx.globalAlpha = 1;
        this.ctx.fillStyle = this.getColor(0, numRays);
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, innerRadius * 0.6 + avgMagnitude * 20, 0, Math.PI * 2);
        this.ctx.fill();

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 46: Neon Rain (already implemented - keeping reference)
     */
    // renderNeonRain is already implemented above

    /**
     * Mode 47: Jazzy Fireworks (already implemented - keeping reference)
     */
    // renderJazzyFireworks is already implemented above

    /**
     * Mode 48: Retro Cassette New (already implemented - keeping reference)
     */
    // renderRetroCassetteNew is already implemented above

    /**
     * Mode 49: Soul Aura (already implemented - keeping reference)
     */
    // renderSoulAura is already implemented above

    /**
     * Mode 50: Frequency Flowers (migrated)
     */
    renderFrequencyFlowers(magnitudes) {
        const numPetals = Math.min(24, magnitudes.length);
        const angleStep = (Math.PI * 2) / numPetals;
        const time = this.frameCounter * 0.5;

        this.ctx.shadowBlur = 15;

        for (let i = 0; i < numPetals; i++) {
            const angle = i * angleStep + time * 0.01;
            const magnitude = magnitudes[Math.floor((i / numPetals) * magnitudes.length)];

            const petalLength = 50 + magnitude * 150;
            const petalWidth = 20 + magnitude * 40;
            const baseRadius = this.maxRadius * 0.4;

            const baseX = this.centerX + Math.cos(angle) * baseRadius;
            const baseY = this.centerY + Math.sin(angle) * baseRadius;

            const tipX = baseX + Math.cos(angle) * petalLength;
            const tipY = baseY + Math.sin(angle) * petalLength;

            const centerX = (baseX + tipX) / 2;
            const centerY = (baseY + tipY) / 2;

            // Use color scheme for petals
            const color = this.getColor(i, numPetals);

            this.ctx.fillStyle = color;
            this.ctx.shadowColor = color;

            this.ctx.save();
            this.ctx.translate(centerX, centerY);
            this.ctx.rotate(angle);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, petalWidth / 2, petalLength / 2, 0, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.restore();
        }

        // Flower center - use color scheme
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const centerRadius = 30 + avgMagnitude * 50;
        this.ctx.shadowBlur = 20;
        const centerColorIndex = Math.floor(magnitudes.length / 2);
        this.ctx.fillStyle = this.getColor(centerColorIndex, magnitudes.length);
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, centerRadius, 0, Math.PI * 2);
        this.ctx.fill();

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 51: Fractal Tree
     */
    renderFractalTree(magnitudes) {
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);

        // Trunk sway
        const trunkSway = Math.sin(this.frameCounter * 0.1 + avgMagnitude) * 20;
        const trunkBase = { x: this.centerX + trunkSway, y: this.canvas.height - 50 };
        const trunkTop = { x: this.centerX + trunkSway, y: this.centerY };

        // Draw trunk - use color scheme
        const trunkThickness = 10 + avgMagnitude * 15;
        const trunkColorIndex = 0;
        this.ctx.strokeStyle = this.getColor(trunkColorIndex, magnitudes.length);
        this.ctx.lineWidth = trunkThickness;
        this.ctx.lineCap = 'round';
        this.ctx.beginPath();
        this.ctx.moveTo(trunkBase.x, trunkBase.y);
        this.ctx.lineTo(trunkTop.x, trunkTop.y);
        this.ctx.stroke();

        // Spawn branches on bass hits
        if (!this.fractalTreeBranches) this.fractalTreeBranches = [];
        if (bass > 0.3 && this.frameCounter % 8 === 0) {
            const angle = -Math.PI / 2 + (Math.random() - 0.5) * Math.PI / 3;
            this.fractalTreeBranches.push({
                x: trunkTop.x,
                y: trunkTop.y,
                angle: angle,
                length: 40 + bass * 60,
                thickness: 3 + bass * 8,
                generation: 0,
                life: 1.0
            });
        }

        // Update and draw branches
        this.fractalTreeBranches = this.fractalTreeBranches.filter(branch => {
            if (branch.life <= 0) return false;

            const endX = branch.x + Math.cos(branch.angle) * branch.length;
            const endY = branch.y + Math.sin(branch.angle) * branch.length;

            this.ctx.globalAlpha = branch.life;
            const branchColorIndex = Math.floor(branch.generation * 2) % magnitudes.length;
            const branchColorStr = this.getColor(branchColorIndex, magnitudes.length);
            const branchRgb = this.parseRgbColor(branchColorStr);
            this.ctx.strokeStyle = `rgba(${branchRgb[0]}, ${branchRgb[1]}, ${branchRgb[2]}, ${branch.life})`;
            this.ctx.lineWidth = branch.thickness;
            this.ctx.beginPath();
            this.ctx.moveTo(branch.x, branch.y);
            this.ctx.lineTo(endX, endY);
            this.ctx.stroke();

            // Bloom flowers on treble - use color scheme
            if (treble > 0.4 && branch.generation > 0) {
                const bloomSize = 3 + treble * 10;
                const bloomColorIndex = magnitudes.length - 1;
                const bloomColorStr = this.getColor(bloomColorIndex, magnitudes.length);
                const rgb = this.parseRgbColor(bloomColorStr);
                this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${branch.life})`;
                this.ctx.beginPath();
                this.ctx.arc(endX, endY, bloomSize, 0, Math.PI * 2);
                this.ctx.fill();
            }

            branch.life -= 0.003;
            return true;
        }).slice(0, 100);

        this.ctx.globalAlpha = 1;
    }

    /**
     * Mode 52: Cityscape Extrusion
     */
    renderCityscapeExtrusion(magnitudes) {
        const numBlocks = Math.min(magnitudes.length, 40);
        const blockWidth = this.canvas.width / numBlocks;

        for (let i = 0; i < numBlocks; i++) {
            const magnitude = magnitudes[i] || 0;
            const buildingHeight = magnitude * this.canvas.height * 0.7;

            const baseY = this.canvas.height - 100;
            const topY = baseY - buildingHeight;
            const xLeft = i * blockWidth + 5;
            const xRight = (i + 1) * blockWidth - 5;

            // Building color - use color scheme
            this.ctx.fillStyle = this.getColor(i, numBlocks);
            this.ctx.fillRect(xLeft, topY, xRight - xLeft, baseY - topY);

            // Windows
            if (magnitude > 0.3) {
                const numWindows = Math.max(2, Math.floor(buildingHeight / 30));
                for (let w = 0; w < numWindows; w++) {
                    const windowY = baseY - ((w + 0.5) * buildingHeight / numWindows);
                    const windowX = (xLeft + xRight) / 2;
                    const brightness = 255 * magnitude;
                    this.ctx.fillStyle = `rgb(${brightness}, ${brightness}, 200)`;
                    this.ctx.beginPath();
                    this.ctx.arc(windowX, windowY, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
        }
    }

    /**
     * Mode 53: Gravity Well
     */
    renderGravityWell(magnitudes) {
        if (!this.gravityWellParticles) this.gravityWellParticles = [];

        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);

        // Spawn particles
        if (this.frameCounter % 2 === 0) {
            for (let i = 0; i < treble * 20 + 5; i++) {
                const angle = Math.random() * Math.PI * 2;
                const edgeDist = Math.min(this.canvas.width, this.canvas.height) / 2;
                this.gravityWellParticles.push({
                    x: this.centerX + Math.cos(angle) * edgeDist,
                    y: this.centerY + Math.sin(angle) * edgeDist,
                    vx: 0,
                    vy: 0,
                    colorIndex: Math.floor(Math.random() * magnitudes.length)
                });
            }
        }

        // Black hole - use color scheme
        const wellRadius = 30 + bass * 50;
        const wellColorIndex = Math.floor(magnitudes.length / 2);
        this.ctx.fillStyle = this.getColor(wellColorIndex, magnitudes.length);
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, wellRadius, 0, Math.PI * 2);
        this.ctx.fill();

        // Update particles
        const shockwaveForce = bass > 0.6 ? bass * 500 : 0;

        this.gravityWellParticles = this.gravityWellParticles.filter(p => {
            const dx = this.centerX - p.x;
            const dy = this.centerY - p.y;
            const dist = Math.sqrt(dx * dx + dy * dy) + 1;

            // Gravity
            const pullForce = 200 / (dist * dist);
            p.vx += (dx / dist) * pullForce;
            p.vy += (dy / dist) * pullForce;

            // Shockwave
            if (shockwaveForce > 0 && dist < 200) {
                p.vx -= (dx / dist) * shockwaveForce;
                p.vy -= (dy / dist) * shockwaveForce;
            }

            p.x += p.vx;
            p.y += p.vy;

            if (dist > wellRadius && p.x >= 0 && p.x < this.canvas.width &&
                p.y >= 0 && p.y < this.canvas.height) {
                this.ctx.fillStyle = this.getColor(p.colorIndex, magnitudes.length);
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                this.ctx.fill();
                return true;
            }
            return false;
        }).slice(0, 500);
    }

    /**
     * Mode 54: Metaball Fluid
     */
    renderMetaballFluid(magnitudes) {
        if (!this.metaballs) this.metaballs = [];

        const numBalls = Math.min(magnitudes.length, 15);
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Initialize metaballs
        while (this.metaballs.length < numBalls) {
            this.metaballs.push({
                x: Math.random() * this.canvas.width,
                y: Math.random() * this.canvas.height,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                baseRadius: 40 + Math.random() * 40
            });
        }

        // Draw metaballs
        for (let i = 0; i < Math.min(numBalls, this.metaballs.length); i++) {
            const ball = this.metaballs[i];
            const magnitude = magnitudes[i] || avgMagnitude;
            const radius = ball.baseRadius * (0.7 + magnitude * 0.8);

            // Update position
            ball.x += ball.vx;
            ball.y += ball.vy;

            // Bounce
            if (ball.x < radius || ball.x > this.canvas.width - radius) ball.vx *= -1;
            if (ball.y < radius || ball.y > this.canvas.height - radius) ball.vy *= -1;

            // Color - use color scheme
            const colorStr = this.getColor(i, numBalls);
            const rgb = this.parseRgbColor(colorStr);

            // Draw with gradient
            for (let r = radius; r > 0; r -= 5) {
                const alpha = r / radius;
                this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${alpha * 0.6})`;
                this.ctx.beginPath();
                this.ctx.arc(ball.x, ball.y, r, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 55: Aurora Borealis
     */
    renderAuroraBorealis(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);

        const numCurtains = 5;
        const curtainPoints = 60;

        for (let curtainIdx = 0; curtainIdx < numCurtains; curtainIdx++) {
            const points = [];
            const baseYOffset = curtainIdx * 80 - 160;

            for (let i = 0; i < curtainPoints; i++) {
                const x = (i / curtainPoints) * this.canvas.width;
                const wave1 = Math.sin(i * 0.15 + this.frameCounter * 0.05 + curtainIdx) * bass * 60;
                const wave2 = Math.sin(i * 0.08 + this.frameCounter * 0.03) * bass * 40;
                const shimmer = Math.sin(i * 0.8 + this.frameCounter * 0.4) * treble * 20;
                const y = this.centerY + baseYOffset + wave1 + wave2 + shimmer;

                points.push({ x, y });
            }

            // Use color scheme for curtain
            const colorStr = this.getColor(curtainIdx, numCurtains);
            this.ctx.strokeStyle = colorStr;
            this.ctx.lineWidth = 3;
            this.ctx.shadowBlur = 15;
            this.ctx.shadowColor = this.ctx.strokeStyle;

            this.ctx.beginPath();
            this.ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                this.ctx.lineTo(points[i].x, points[i].y);
            }
            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 56: Stained Glass
     */
    renderStainedGlass(magnitudes) {
        const rows = 6, cols = 10;
        const paneWidth = this.canvas.width / cols;
        const paneHeight = this.canvas.height / rows;

        let paneIdx = 0;
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (paneIdx >= magnitudes.length) break;

                const magnitude = magnitudes[paneIdx];
                const x1 = col * paneWidth + 2;
                const y1 = row * paneHeight + 2;
                const x2 = (col + 1) * paneWidth - 2;
                const y2 = (row + 1) * paneHeight - 2;

                // Use color scheme for glass pane
                const colorStr = this.getColor(paneIdx, magnitudes.length);
                this.ctx.fillStyle = colorStr;
                this.ctx.fillRect(x1, y1, x2 - x1, y2 - y1);

                if (magnitude > 0.5) {
                    this.ctx.shadowBlur = magnitude * 20;
                    this.ctx.shadowColor = colorStr;
                    this.ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
                    this.ctx.shadowBlur = 0;
                }

                paneIdx++;
            }
        }
    }

    /**
     * Mode 57: Neural Network
     */
    renderNeuralNetwork(magnitudes) {
        if (!this.nerveNodes || this.nerveNodes.length === 0) {
            this.nerveNodes = [];
            const numNodes = 20;
            for (let i = 0; i < numNodes; i++) {
                this.nerveNodes.push({
                    x: 100 + Math.random() * (this.canvas.width - 200),
                    y: 100 + Math.random() * (this.canvas.height - 200),
                    pulse: 0,
                    connections: []
                });
            }
            // Create connections
            this.nerveNodes.forEach((node, i) => {
                const numConnections = 2 + Math.floor(Math.random() * 3);
                for (let j = 0; j < numConnections; j++) {
                    const target = Math.floor(Math.random() * numNodes);
                    if (target !== i) node.connections.push(target);
                }
            });
        }

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);

        // Update pulses
        this.nerveNodes.forEach((node, i) => {
            if (i < magnitudes.length) node.pulse = magnitudes[i];
        });

        // Get color scheme
        const scheme = COLOR_SCHEMES[this.settings.colorScheme];
        const color1 = scheme.primary;
        const color2 = scheme.secondary;

        // Draw connections
        this.ctx.strokeStyle = `rgba(${color1[0]}, ${color1[1]}, ${color1[2]}, ${treble * 0.8})`;
        this.ctx.lineWidth = 2;
        this.nerveNodes.forEach(node => {
            node.connections.forEach(targetIdx => {
                const target = this.nerveNodes[targetIdx];
                if (treble > 0.5) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(node.x, node.y);
                    this.ctx.lineTo(target.x, target.y);
                    this.ctx.stroke();
                }
            });
        });

        // Draw nodes
        this.nerveNodes.forEach(node => {
            const radius = 10 + node.pulse * 25;
            this.ctx.fillStyle = `rgba(${color2[0]}, ${color2[1]}, ${color2[2]}, ${0.6 + node.pulse * 0.4})`;
            this.ctx.beginPath();
            this.ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
            this.ctx.fill();
        });
    }

    /**
     * Mode 58: Glitch Artifact
     */
    renderGlitchArtifact(magnitudes) {
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);

        // Get color scheme
        const scheme = COLOR_SCHEMES[this.settings.colorScheme];
        const color1 = scheme.primary;

        // Draw clean bars
        const barWidth = this.canvas.width / magnitudes.length;
        magnitudes.forEach((magnitude, i) => {
            const barHeight = magnitude * this.canvas.height * 0.7;
            const x = i * barWidth;
            const y = this.canvas.height - barHeight;

            this.ctx.fillStyle = `rgb(${color1[0]}, ${color1[1]}, ${color1[2]})`;
            this.ctx.fillRect(x, y, barWidth - 2, barHeight);
        });

        // Apply glitch on strong transients
        if (treble > 0.7) {
            const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
            const shift = Math.floor(treble * 20);

            // Simple chromatic aberration simulation
            for (let y = 0; y < this.canvas.height; y += 10) {
                const rowData = this.ctx.getImageData(0, y, this.canvas.width, 1);
                this.ctx.putImageData(rowData, shift, y);
            }
        }
    }

    /**
     * Mode 59: Warp Tunnel
     */
    renderWarpTunnel(magnitudes) {
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const numRings = 30;

        for (let i = 0; i < numRings; i++) {
            const depth = i / numRings;
            const scale = 1 - depth * 0.9;
            const freqIdx = Math.floor(depth * magnitudes.length);
            const magnitude = magnitudes[Math.min(freqIdx, magnitudes.length - 1)];
            const radius = this.maxRadius * scale * (0.5 + magnitude * 0.8);

            // Use color scheme for tunnel ring
            const colorIndex = Math.floor(depth * magnitudes.length);
            this.ctx.strokeStyle = this.getColor(colorIndex, magnitudes.length);
            this.ctx.lineWidth = 2 + magnitude * 8;

            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 60: Conway's Game of Life
     */
    renderConwayLife(magnitudes) {
        const gridSize = 40;
        const cellWidth = this.canvas.width / gridSize;
        const cellHeight = this.canvas.height / gridSize;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);

        if (!this.cellularAutomaton || this.cellularAutomaton.length === 0) {
            this.cellularAutomaton = [];
            for (let y = 0; y < gridSize; y++) {
                this.cellularAutomaton[y] = [];
                for (let x = 0; x < gridSize; x++) {
                    this.cellularAutomaton[y][x] = Math.random() > 0.5 ? 1 : 0;
                }
            }
        }

        if (this.frameCounter % 3 === 0) {
            const newGrid = this.cellularAutomaton.map(row => [...row]);

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    let neighbors = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dy === 0 && dx === 0) continue;
                            const ny = (y + dy + gridSize) % gridSize;
                            const nx = (x + dx + gridSize) % gridSize;
                            neighbors += this.cellularAutomaton[ny][nx];
                        }
                    }

                    if (this.cellularAutomaton[y][x] === 1) {
                        if (neighbors < 2 || neighbors > 3) newGrid[y][x] = 0;
                    } else {
                        if (neighbors === 3 || (bass > 0.6 && Math.random() < bass * 0.1)) {
                            newGrid[y][x] = 1;
                        }
                    }
                }
            }

            this.cellularAutomaton = newGrid;
        }

        // Get color scheme
        const scheme = COLOR_SCHEMES[this.settings.colorScheme];
        const color1 = scheme.primary;

        // Draw grid
        this.ctx.fillStyle = `rgb(${color1[0]}, ${color1[1]}, ${color1[2]})`;
        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                if (this.cellularAutomaton[y][x] === 1) {
                    this.ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth - 1, cellHeight - 1);
                }
            }
        }
    }

    /**
     * Mode 61: ASCII Art Bars
     */
    renderAsciiArt(magnitudes) {
        const chars = ['.', '-', '=', '+', '*', '#', '@'];
        const barWidth = this.canvas.width / magnitudes.length;

        // Get color scheme
        const scheme = COLOR_SCHEMES[this.settings.colorScheme];
        const color1 = scheme.primary;

        this.ctx.font = '20px monospace';
        this.ctx.textAlign = 'center';

        for (let i = 0; i < magnitudes.length; i++) {
            const magnitude = magnitudes[i];
            const barHeight = Math.floor(magnitude * 20);
            const charIdx = Math.min(Math.floor(magnitude * chars.length), chars.length - 1);
            const char = chars[charIdx];

            const x = i * barWidth + barWidth / 2;
            for (let row = 0; row < barHeight; row++) {
                const y = this.canvas.height - row * 30 - 30;
                if (y > 0) {
                    // Use color scheme with varying opacity based on magnitude
                    const alpha = 0.7 + magnitude * 0.3;
                    this.ctx.fillStyle = `rgba(${color1[0]}, ${color1[1]}, ${color1[2]}, ${alpha})`;
                    this.ctx.fillText(char, x, y);
                }
            }
        }
    }

    /**
     * Mode 62: Rippling Water
     */
    renderRipplingWater(magnitudes) {
        for (let i = 0; i < magnitudes.length; i++) {
            const magnitude = magnitudes[i];
            if (magnitude > 0.4) {
                const x = (i / magnitudes.length) * this.canvas.width;
                const y = this.canvas.height * 0.3;

                const rippleRadius = ((this.frameCounter % 60) * magnitude * 8);
                const alpha = 1.0 - (rippleRadius / 300);

                if (alpha > 0) {
                    this.ctx.strokeStyle = `rgba(100, 150, 255, ${alpha})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, rippleRadius, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
            }
        }
    }

    /**
     * Mode 63: Terrain Flyover
     */
    renderTerrainFlyover(magnitudes) {
        const terrainWidth = 50;
        const terrainDepth = 30;
        const scale = 15;
        const offsetX = this.canvas.width / 2;
        const offsetY = this.canvas.height - 200;

        for (let z = 0; z < terrainDepth - 1; z++) {
            for (let x = 0; x < terrainWidth - 1; x++) {
                const freqIdx = Math.floor((x / terrainWidth) * magnitudes.length);
                const height = magnitudes[Math.min(freqIdx, magnitudes.length - 1)] * 200;

                const x1 = offsetX + (x - terrainWidth / 2) * scale;
                const y1 = offsetY - height - z * 10;

                const x2 = offsetX + (x + 1 - terrainWidth / 2) * scale;
                const y2 = offsetY - height - z * 10;

                const x3 = offsetX + (x - terrainWidth / 2) * scale;
                const y3 = offsetY - height - (z + 1) * 10;

                const depthFactor = 1 - z / terrainDepth;
                const color = `rgb(${100 * depthFactor}, ${200 * depthFactor}, ${100 * depthFactor})`;

                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x2, y2);
                this.ctx.stroke();

                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x3, y3);
                this.ctx.stroke();
            }
        }
    }

    /**
     * Mode 64: String Art
     */
    renderStringArt(magnitudes) {
        const numPoints = Math.min(magnitudes.length, 36);
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 2);
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);

        // Calculate points
        const points = [];
        for (let i = 0; i < numPoints; i++) {
            const angle = (i / numPoints) * Math.PI * 2;
            const radius = this.maxRadius * 0.8 * (1 + bass * 0.3);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            points.push({ x, y });
        }

        // Draw lines - use color scheme
        const numLines = mids * 50 + treble * 100;
        const lineColorIndex = Math.floor(magnitudes.length / 2);
        const lineColorStr = this.getColor(lineColorIndex, magnitudes.length);
        const rgb = this.parseRgbColor(lineColorStr);

        this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.3)`;
        this.ctx.lineWidth = 1;

        for (let i = 0; i < numLines; i++) {
            const idx1 = Math.floor(Math.random() * points.length);
            const idx2 = Math.floor(Math.random() * points.length);
            if (idx1 !== idx2) {
                this.ctx.beginPath();
                this.ctx.moveTo(points[idx1].x, points[idx1].y);
                this.ctx.lineTo(points[idx2].x, points[idx2].y);
                this.ctx.stroke();
            }
        }

        // Draw points - use color scheme
        const pointColorIndex = magnitudes.length - 1;
        this.ctx.fillStyle = this.getColor(pointColorIndex, magnitudes.length);
        points.forEach(point => {
            this.ctx.beginPath();
            this.ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        });
    }

    /**
     * Mode 65: Fire Embers
     */
    renderFireEmbers(magnitudes) {
        if (!this.emberParticles) this.emberParticles = [];

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);

        // Central fire
        const fireHeight = bass * 300 + 100;
        const fireWidth = 150;

        for (let i = 0; i < 20; i++) {
            const flameX = this.centerX + (Math.random() - 0.5) * fireWidth;
            const flameY = this.canvas.height - 100 - Math.random() * fireHeight;
            const flameSize = 20 + bass * 30;

            // Use color scheme for flames
            const flameColorIndex = Math.floor(Math.random() * magnitudes.length);
            this.ctx.fillStyle = this.getColor(flameColorIndex, magnitudes.length);
            this.ctx.beginPath();
            this.ctx.arc(flameX, flameY, flameSize, 0, Math.PI * 2);
            this.ctx.fill();
        }

        // Emit embers on treble
        if (treble > 0.5) {
            for (let i = 0; i < treble * 30; i++) {
                this.emberParticles.push({
                    x: this.centerX + (Math.random() - 0.5) * 100,
                    y: this.canvas.height - 150,
                    vx: (Math.random() - 0.5) * 8,
                    vy: -Math.random() * 15 - 5,
                    life: 1.0
                });
            }
        }

        // Update embers
        this.emberParticles = this.emberParticles.filter(ember => {
            ember.x += ember.vx;
            ember.y += ember.vy;
            ember.vy += 0.5; // Gravity
            ember.life -= 0.015;

            if (ember.life > 0 && ember.y < this.canvas.height) {
                const alpha = ember.life;
                const emberColorIndex = Math.floor(magnitudes.length * 0.75);
                const emberColorStr = this.getColor(emberColorIndex, magnitudes.length);
                const emberRgb = this.parseRgbColor(emberColorStr);
                this.ctx.fillStyle = `rgba(${emberRgb[0]}, ${emberRgb[1]}, ${emberRgb[2]}, ${alpha})`;
                this.ctx.beginPath();
                this.ctx.arc(ember.x, ember.y, 3, 0, Math.PI * 2);
                this.ctx.fill();
                return true;
            }
            return false;
        });
    }

    /**
     * Mode 66: Radial Kaleidoscope
     */
    renderRadialKaleidoscope(magnitudes) {
        const numSegments = 8;
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const segmentAngle = (Math.PI * 2) / numSegments;

        // Draw particles in mirrored segments
        for (let i = 0; i < Math.min(magnitudes.length, 30); i++) {
            const magnitude = magnitudes[i];
            if (magnitude > 0.2) {
                const angle = (i / 30) * segmentAngle;
                const distance = 100 + magnitude * 300;

                // Use color scheme for kaleidoscope particles
                const colorStr = this.getColor(i, magnitudes.length);
                const [r, g, b] = this.parseRgbColor(colorStr);

                // Draw in all mirrored segments
                for (let seg = 0; seg < numSegments; seg++) {
                    const segAngle = seg * segmentAngle + this.frameCounter * 0.02;
                    const rotX = this.centerX + Math.cos(angle + segAngle) * distance;
                    const rotY = this.centerY + Math.sin(angle + segAngle) * distance;

                    const size = 5 + magnitude * 15;
                    this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    this.ctx.beginPath();
                    this.ctx.arc(rotX, rotY, size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
        }
    }

    /**
     * Mode 68: Orbital System
     */
    renderOrbitalSystem(magnitudes) {
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);

        // Central sun pulses - use color scheme
        const sunRadius = 40 + avgMagnitude * 40;
        const sunColorIndex = Math.floor(magnitudes.length / 2);
        this.ctx.fillStyle = this.getColor(sunColorIndex, magnitudes.length);
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, sunRadius, 0, Math.PI * 2);
        this.ctx.fill();

        this.ctx.strokeStyle = this.getColor(sunColorIndex + 1, magnitudes.length);
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, sunRadius + 10, 0, Math.PI * 2);
        this.ctx.stroke();

        // Planets orbit
        const numPlanets = Math.min(mids.length, 6);
        for (let i = 0; i < numPlanets; i++) {
            const magnitude = i < mids.length ? mids[i] : 0;
            const orbitRadius = 120 + i * 70;
            const angle = this.frameCounter * 0.02 * (1 + i * 0.3);

            const planetX = this.centerX + Math.cos(angle) * orbitRadius;
            const planetY = this.centerY + Math.sin(angle) * orbitRadius;
            const planetSize = 10 + magnitude * 25;

            // Planet color - use color scheme
            this.ctx.fillStyle = this.getColor(i, numPlanets);
            this.ctx.beginPath();
            this.ctx.arc(planetX, planetY, planetSize, 0, Math.PI * 2);
            this.ctx.fill();

            // Moon orbits planet (treble)
            if (treble > 0.4) {
                const moonAngle = this.frameCounter * 0.1;
                const moonDistance = planetSize + 20;
                const moonX = planetX + Math.cos(moonAngle) * moonDistance;
                const moonY = planetY + Math.sin(moonAngle) * moonDistance;
                const moonSize = 3 + treble * 8;

                const moonColorIndex = magnitudes.length - 1;
                this.ctx.fillStyle = this.getColor(moonColorIndex, magnitudes.length);
                this.ctx.beginPath();
                this.ctx.arc(moonX, moonY, moonSize, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 69: Spectrum Cube
     */
    renderSpectrumCube(magnitudes) {
        if (!this.cubeRotation) this.cubeRotation = 0;
        this.cubeRotation += 0.02;

        const cubeSize = 200;
        const angleX = this.cubeRotation;
        const angleY = this.cubeRotation * 0.7;

        // Cube vertices
        const vertices3D = [
            [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],
            [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]
        ];

        // Rotate and project
        const vertices2D = vertices3D.map(([vx, vy, vz]) => {
            // Rotate around Y
            let x = vx * Math.cos(angleY) - vz * Math.sin(angleY);
            let z = vx * Math.sin(angleY) + vz * Math.cos(angleY);

            // Rotate around X
            const y = vy * Math.cos(angleX) - z * Math.sin(angleX);
            z = vy * Math.sin(angleX) + z * Math.cos(angleX);

            // Project to 2D
            const scale = cubeSize / (3 + z);
            const x2d = this.centerX + x * scale;
            const y2d = this.centerY + y * scale;

            return [x2d, y2d];
        });

        // Draw cube edges
        const edges = [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
        this.ctx.strokeStyle = 'rgb(100, 200, 255)';
        this.ctx.lineWidth = 2;

        edges.forEach(([start, end]) => {
            this.ctx.beginPath();
            this.ctx.moveTo(vertices2D[start][0], vertices2D[start][1]);
            this.ctx.lineTo(vertices2D[end][0], vertices2D[end][1]);
            this.ctx.stroke();
        });

        // Draw bars on front face
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const faceCenterX = (vertices2D[0][0] + vertices2D[2][0]) / 2;
        const faceCenterY = (vertices2D[0][1] + vertices2D[2][1]) / 2;
        const barLength = 30 + avgMagnitude * 50;

        this.ctx.strokeStyle = 'rgb(255, 200, 100)';
        this.ctx.lineWidth = 3;
        this.ctx.beginPath();
        this.ctx.moveTo(faceCenterX, faceCenterY);
        this.ctx.lineTo(faceCenterX, faceCenterY - barLength);
        this.ctx.stroke();
    }

    /**
     * Mode 70: Typographic Flow
     */
    renderTypographicFlow(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);

        // Initialize word particles
        if (!this.wordParticles) this.wordParticles = [];

        // Spawn new words
        if (this.frameCounter % 30 === 0) {
            const words = ['MUSIC', 'FLOW', 'VIBE', 'SOUND', 'WAVE', 'PULSE', 'RHYTHM'];
            const word = words[Math.floor(Math.random() * words.length)];
            this.wordParticles.push({
                word: word,
                x: Math.random() * this.canvas.width,
                y: this.canvas.height + 50,
                vy: -2 - Math.random() * 2,
                life: 1.0
            });
        }

        // Update and draw words
        this.wordParticles = this.wordParticles.filter(particle => {
            particle.y += particle.vy;
            particle.life -= 0.01;

            if (particle.life > 0 && particle.y > -100) {
                const size = 20 + bass * 40;
                const waviness = treble * 20;
                const offsetX = Math.sin(particle.y * 0.02 + this.frameCounter * 0.1) * waviness;

                this.ctx.save();
                this.ctx.font = `${size}px Arial`;
                this.ctx.fillStyle = `rgba(100, 200, 255, ${particle.life})`;
                this.ctx.fillText(particle.word, particle.x + offsetX, particle.y);
                this.ctx.restore();

                return true;
            }
            return false;
        });
    }

    /**
     * Mode 71: Sonar Ping
     */
    renderSonarPing(magnitudes) {
        // Rotating sweep line
        const sweepAngle = (this.frameCounter * 0.05) % (Math.PI * 2);
        const sweepEndX = this.centerX + Math.cos(sweepAngle) * this.maxRadius;
        const sweepEndY = this.centerY + Math.sin(sweepAngle) * this.maxRadius;

        // Draw sweep line
        this.ctx.strokeStyle = 'rgb(100, 255, 100)';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(this.centerX, this.centerY);
        this.ctx.lineTo(sweepEndX, sweepEndY);
        this.ctx.stroke();

        // Draw concentric circles (radar grid)
        this.ctx.strokeStyle = 'rgb(50, 100, 50)';
        this.ctx.lineWidth = 1;
        for (let ring = 1; ring <= 5; ring++) {
            const radius = (this.maxRadius * ring) / 5;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }

        // Frequency blips appear on radar
        magnitudes.forEach((magnitude, i) => {
            if (magnitude > 0.4) {
                const distance = (i / magnitudes.length) * this.maxRadius;
                const angle = sweepAngle + (Math.random() - 0.5) * 0.5;

                const blipX = this.centerX + Math.cos(angle) * distance;
                const blipY = this.centerY + Math.sin(angle) * distance;

                const blipSize = 3 + magnitude * 12;
                const brightness = 200 + magnitude * 55;

                this.ctx.fillStyle = `rgb(${brightness}, 255, ${brightness})`;
                this.ctx.beginPath();
                this.ctx.arc(blipX, blipY, blipSize, 0, Math.PI * 2);
                this.ctx.fill();
            }
        });
    }

    /**
     * Mode 72: VU Meters
     */
    renderVUMeters(magnitudes) {
        // Split audio into Left/Right
        const leftMagnitude = magnitudes.slice(0, Math.floor(magnitudes.length / 2))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 2);
        const rightMagnitude = magnitudes.slice(Math.floor(magnitudes.length / 2))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 2);

        // Initialize needle positions
        if (!this.vuNeedlePositions) this.vuNeedlePositions = [-60, -60];

        // Smooth needle movement
        const targetLeft = -60 + leftMagnitude * 120;
        const targetRight = -60 + rightMagnitude * 120;

        this.vuNeedlePositions[0] += (targetLeft - this.vuNeedlePositions[0]) * 0.3;
        this.vuNeedlePositions[1] += (targetRight - this.vuNeedlePositions[1]) * 0.3;

        // Draw VU meters
        const meterWidth = 300;
        const meterHeight = 200;

        ['L', 'R'].forEach((label, idx) => {
            const centerX = this.canvas.width / 4 + idx * this.canvas.width / 2;
            const centerY = this.centerY;
            const needleAngle = this.vuNeedlePositions[idx];

            // Draw meter face
            this.ctx.fillStyle = 'rgb(50, 50, 50)';
            this.ctx.beginPath();
            this.ctx.ellipse(centerX, centerY, meterWidth / 2, meterHeight / 2, 0, Math.PI, 2 * Math.PI);
            this.ctx.fill();

            this.ctx.strokeStyle = 'rgb(200, 200, 200)';
            this.ctx.lineWidth = 3;
            this.ctx.beginPath();
            this.ctx.ellipse(centerX, centerY, meterWidth / 2, meterHeight / 2, 0, Math.PI, 2 * Math.PI);
            this.ctx.stroke();

            // Draw scale marks
            for (let angle = -60; angle <= 60; angle += 10) {
                const markAngleRad = (Math.PI - angle * Math.PI / 180);
                const startR = meterWidth / 2 - 20;
                const endR = meterWidth / 2 - 10;

                this.ctx.strokeStyle = 'rgb(200, 200, 200)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(centerX + Math.cos(markAngleRad) * startR,
                               centerY - Math.sin(markAngleRad) * startR);
                this.ctx.lineTo(centerX + Math.cos(markAngleRad) * endR,
                               centerY - Math.sin(markAngleRad) * endR);
                this.ctx.stroke();
            }

            // Draw needle
            const needleAngleRad = (Math.PI - needleAngle * Math.PI / 180);
            this.ctx.strokeStyle = 'rgb(255, 100, 100)';
            this.ctx.lineWidth = 4;
            this.ctx.beginPath();
            this.ctx.moveTo(centerX, centerY);
            this.ctx.lineTo(centerX + Math.cos(needleAngleRad) * (meterWidth / 2 - 30),
                           centerY - Math.sin(needleAngleRad) * (meterWidth / 2 - 30));
            this.ctx.stroke();

            this.ctx.fillStyle = 'rgb(150, 150, 150)';
            this.ctx.beginPath();
            this.ctx.arc(centerX, centerY, 10, 0, Math.PI * 2);
            this.ctx.fill();

            // Label
            this.ctx.fillStyle = 'rgb(200, 200, 200)';
            this.ctx.font = '32px Arial';
            this.ctx.fillText(label, centerX - 15, centerY + 80);
        });
    }

    /**
     * Mode 73: Lightning Cloud
     */
    renderLightningCloud(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);

        // Cloud shape
        const cloudHeight = 150 + bass * 100;

        this.ctx.globalAlpha = 0.3;
        for (let i = 0; i < 20; i++) {
            const cloudX = Math.random() * this.canvas.width;
            const cloudY = Math.random() * cloudHeight;
            const cloudSize = 30 + bass * 50;

            this.ctx.fillStyle = 'rgb(30, 30, 50)';
            this.ctx.beginPath();
            this.ctx.arc(cloudX, cloudY, cloudSize, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;

        // Lightning bolts on strong treble
        if (treble > 0.65) {
            const startX = Math.random() * (this.canvas.width / 2) + this.canvas.width / 4;
            const startY = cloudHeight;

            let x = startX;
            let y = startY;
            const points = [[x, y]];

            // Jagged lightning path
            for (let i = 0; i < 5 + treble * 10; i++) {
                x += (Math.random() - 0.5) * 80;
                y += 40 + Math.random() * 60;
                points.push([x, y]);
            }

            // Draw lightning (glow first, then bright line)
            this.ctx.lineWidth = 12;
            this.ctx.strokeStyle = 'rgba(100, 100, 200, 0.6)';
            this.ctx.beginPath();
            points.forEach((point, i) => {
                if (i === 0) this.ctx.moveTo(point[0], point[1]);
                else this.ctx.lineTo(point[0], point[1]);
            });
            this.ctx.stroke();

            const brightness = 200 + treble * 55;
            this.ctx.lineWidth = 4;
            this.ctx.strokeStyle = `rgb(${brightness}, ${brightness}, 255)`;
            this.ctx.beginPath();
            points.forEach((point, i) => {
                if (i === 0) this.ctx.moveTo(point[0], point[1]);
                else this.ctx.lineTo(point[0], point[1]);
            });
            this.ctx.stroke();
        }
    }

    /**
     * Mode 74: Bouncing Balls
     */
    renderBouncingBalls(magnitudes) {
        // Initialize balls
        if (!this.bouncingBalls) {
            this.bouncingBalls = [];
            for (let i = 0; i < Math.min(magnitudes.length, 30); i++) {
                this.bouncingBalls.push({
                    x: (i / 30) * this.canvas.width,
                    y: this.canvas.height - 50,
                    vy: 0,
                    colorIndex: i
                });
            }
        }

        const gravity = 0.8;

        // Update and draw balls
        this.bouncingBalls.forEach((ball, i) => {
            if (i >= magnitudes.length) return;

            const magnitude = magnitudes[i];

            // Bounce based on amplitude
            if (ball.y >= this.canvas.height - 50) {
                ball.vy = -magnitude * 30 - 5;
            }

            // Apply gravity
            ball.vy += gravity;
            ball.y += ball.vy;

            // Keep ball in bounds
            if (ball.y > this.canvas.height - 50) {
                ball.y = this.canvas.height - 50;
                ball.vy *= -0.7;
            }

            // Draw ball - use color scheme
            const ballSize = 10 + magnitude * 20;
            this.ctx.fillStyle = this.getColor(ball.colorIndex, magnitudes.length);
            this.ctx.beginPath();
            this.ctx.arc(ball.x, ball.y, ballSize, 0, Math.PI * 2);
            this.ctx.fill();
        });
    }

    /**
     * Mode 75: Liquid Ink
     */
    renderLiquidInk(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);

        // Initialize blooms
        if (!this.inkBlooms) this.inkBlooms = [];

        // Bass hits create large ink blooms
        if (bass > 0.4 && this.frameCounter % 15 === 0) {
            this.inkBlooms.push({
                x: Math.random() * (this.canvas.width - 400) + 200,
                y: 100,
                radius: 10,
                maxRadius: 150 + bass * 200,
                life: 1.0,
                colorIndex: Math.floor(Math.random() * magnitudes.length)
            });
        }

        // Treble creates small bright splatters
        if (treble > 0.5) {
            for (let i = 0; i < treble * 10; i++) {
                this.inkBlooms.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    radius: 5,
                    maxRadius: 20 + treble * 40,
                    life: 1.0,
                    colorIndex: Math.floor(Math.random() * magnitudes.length)
                });
            }
        }

        // Update and draw blooms
        this.inkBlooms = this.inkBlooms.filter(bloom => {
            bloom.radius += 2;
            bloom.life -= 0.01;

            if (bloom.life > 0 && bloom.radius < bloom.maxRadius) {
                // Use color scheme for bloom
                const bloomColorStr = this.getColor(bloom.colorIndex, magnitudes.length);
                const [r, g, b] = this.parseRgbColor(bloomColorStr);

                this.ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${bloom.life})`;
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(bloom.x, bloom.y, bloom.radius, 0, Math.PI * 2);
                this.ctx.stroke();

                return true;
            }
            return false;
        });

        // Limit blooms
        if (this.inkBlooms.length > 100) {
            this.inkBlooms = this.inkBlooms.slice(-100);
        }
    }

    renderStereoLandscape(magnitudes) {
        // Mode 76: 3D perspective - left channel left mountain, right channel right mountain
        const midpoint = Math.floor(magnitudes.length / 2);
        const leftMags = magnitudes.slice(0, midpoint);
        const rightMags = magnitudes.slice(midpoint);

        // Draw left landscape
        this.ctx.beginPath();
        this.ctx.moveTo(0, this.canvas.height);

        for (let i = 0; i < leftMags.length; i++) {
            const x = (i / leftMags.length) * (this.canvas.width / 2);
            const y = this.canvas.height - 100 - leftMags[i] * 300;
            this.ctx.lineTo(x, y);
        }

        this.ctx.lineTo(this.canvas.width / 2, this.canvas.height);
        this.ctx.lineTo(0, this.canvas.height);
        this.ctx.fillStyle = 'rgba(100, 150, 255, 0.7)';
        this.ctx.fill();

        // Left landscape outline
        this.ctx.beginPath();
        for (let i = 0; i < leftMags.length; i++) {
            const x = (i / leftMags.length) * (this.canvas.width / 2);
            const y = this.canvas.height - 100 - leftMags[i] * 300;
            if (i === 0) this.ctx.moveTo(x, y);
            else this.ctx.lineTo(x, y);
        }
        this.ctx.strokeStyle = 'rgba(150, 200, 255, 1)';
        this.ctx.lineWidth = 3;
        this.ctx.stroke();

        // Draw right landscape
        this.ctx.beginPath();
        this.ctx.moveTo(this.canvas.width / 2, this.canvas.height);

        for (let i = 0; i < rightMags.length; i++) {
            const x = this.canvas.width / 2 + (i / rightMags.length) * (this.canvas.width / 2);
            const y = this.canvas.height - 100 - rightMags[i] * 300;
            this.ctx.lineTo(x, y);
        }

        this.ctx.lineTo(this.canvas.width, this.canvas.height);
        this.ctx.lineTo(this.canvas.width / 2, this.canvas.height);
        this.ctx.fillStyle = 'rgba(255, 150, 100, 0.7)';
        this.ctx.fill();

        // Right landscape outline
        this.ctx.beginPath();
        for (let i = 0; i < rightMags.length; i++) {
            const x = this.canvas.width / 2 + (i / rightMags.length) * (this.canvas.width / 2);
            const y = this.canvas.height - 100 - rightMags[i] * 300;
            if (i === 0) this.ctx.moveTo(x, y);
            else this.ctx.lineTo(x, y);
        }
        this.ctx.strokeStyle = 'rgba(255, 200, 150, 1)';
        this.ctx.lineWidth = 3;
        this.ctx.stroke();
    }

    renderAILatentWalk(magnitudes) {
        // Mode 77: Abstract latent space visualization (simulated)
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);

        // Initialize latent state
        if (this.latentMorphState === undefined) this.latentMorphState = 0;
        this.latentMorphState += avgMagnitude * 0.1;

        const numShapes = 15;
        for (let i = 0; i < numShapes; i++) {
            // Position influenced by latent state
            const angle = (i / numShapes) * Math.PI * 2 + this.latentMorphState;
            const radius = 100 + Math.sin(this.latentMorphState + i) * 200;

            const x = this.canvas.width / 2 + Math.cos(angle) * radius;
            const y = this.canvas.height / 2 + Math.sin(angle) * radius;

            // Morphing size
            const size = 20 + bass * 40 + Math.sin(this.latentMorphState * 2 + i) * 20;

            // Dream-like colors - use color scheme
            const colorStr = this.getColor(i, numShapes);
            const [r, g, b] = this.parseRgbColor(colorStr);

            // Draw with glow effect
            this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.7)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    renderPixelStorm(magnitudes) {
        // Mode 78: Blizzard of 8-bit pixels - wind direction from stereo, speed from volume
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Stereo pan (L/R balance)
        const midpoint = Math.floor(magnitudes.length / 2);
        const leftPower = magnitudes.slice(0, midpoint).reduce((a, b) => a + b, 0) / midpoint;
        const rightPower = magnitudes.slice(midpoint).reduce((a, b) => a + b, 0) / (magnitudes.length - midpoint);
        const windDirection = (rightPower - leftPower) * 5;

        // Initialize pixel storm
        if (!this.pixelStorm) this.pixelStorm = [];

        // Spawn pixels
        if (this.frameCounter % 2 === 0) {
            const numPixels = Math.floor(avgMagnitude * 30 + 10);
            for (let i = 0; i < numPixels; i++) {
                // Dominant frequency determines color
                const dominantFreqIdx = magnitudes.indexOf(Math.max(...magnitudes));

                this.pixelStorm.push({
                    x: Math.random() * this.canvas.width,
                    y: 0,
                    vx: windDirection + (Math.random() - 0.5) * 3,
                    vy: 3 + avgMagnitude * 5,
                    colorIndex: dominantFreqIdx,
                    life: 1.0
                });
            }
        }

        // Update and draw pixels
        this.pixelStorm = this.pixelStorm.filter(pixel => {
            pixel.x += pixel.vx;
            pixel.y += pixel.vy;
            pixel.life -= 0.01;

            if (pixel.life > 0 && pixel.y < this.canvas.height) {
                const colorStr = this.getColor(pixel.colorIndex, magnitudes.length);
                const [r, g, b] = this.parseRgbColor(colorStr);

                // 8-bit pixel (small rectangle)
                this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                this.ctx.fillRect(Math.floor(pixel.x), Math.floor(pixel.y), 4, 4);

                return true;
            }
            return false;
        });

        // Limit particle count
        if (this.pixelStorm.length > 400) {
            this.pixelStorm = this.pixelStorm.slice(-400);
        }
    }

    renderGrowingVine(magnitudes) {
        // Mode 79: Vine grows across screen, sprouts leaves on beats
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);

        // Initialize vine
        if (!this.vineSegments) this.vineSegments = [];

        // Grow vine if not complete
        if (this.vineSegments.length < 200) {
            if (this.vineSegments.length === 0) {
                this.vineSegments.push({x: 100, y: this.canvas.height - 100, leaves: []});
            } else {
                const last = this.vineSegments[this.vineSegments.length - 1];
                // Vine meanders
                const angle = -Math.PI / 6 + (Math.random() - 0.5) * Math.PI / 4;
                const newX = last.x + Math.cos(angle) * 15;
                const newY = last.y + Math.sin(angle) * 15;

                if (newX > 0 && newX < this.canvas.width && newY > 0 && newY < this.canvas.height) {
                    const newSegment = {x: newX, y: newY, leaves: []};
                    this.vineSegments.push(newSegment);

                    // Sprout leaf on beat
                    if (bass > 0.5) {
                        const leafSize = 10 + bass * 30;
                        newSegment.leaves.push({
                            offsetX: (Math.random() - 0.5) * 20,
                            offsetY: (Math.random() - 0.5) * 20,
                            size: leafSize
                        });
                    }
                }
            }
        }

        // Draw vine
        this.ctx.strokeStyle = 'rgb(50, 120, 50)';
        this.ctx.lineWidth = 3;
        this.ctx.beginPath();
        for (let i = 0; i < this.vineSegments.length - 1; i++) {
            const seg = this.vineSegments[i];
            const nextSeg = this.vineSegments[i + 1];
            if (i === 0) {
                this.ctx.moveTo(seg.x, seg.y);
            }
            this.ctx.lineTo(nextSeg.x, nextSeg.y);
        }
        this.ctx.stroke();

        // Draw leaves
        for (const seg of this.vineSegments) {
            for (const leaf of seg.leaves) {
                const leafX = seg.x + leaf.offsetX;
                const leafY = seg.y + leaf.offsetY;
                this.ctx.fillStyle = 'rgb(100, 255, 100)';
                this.ctx.beginPath();
                this.ctx.arc(leafX, leafY, leaf.size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    renderHauntedFaces(magnitudes) {
        // Mode 80: Ghostly faces fade in/out with mid-range (vocals), eyes glow on bass
        const midRange = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 2);
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);

        // Face opacity controlled by mid-range (vocals)
        const faceAlpha = midRange;

        if (faceAlpha > 0.2) {
            // Draw ghostly faces
            const numFaces = 3;
            for (let i = 0; i < numFaces; i++) {
                const faceX = ((i + 1) * this.canvas.width) / (numFaces + 1);
                const faceY = this.canvas.height / 3 + Math.sin(this.frameCounter * 0.05 + i) * 50;
                const faceSize = 80;

                const alpha = faceAlpha * 0.5;

                // Face circle
                this.ctx.fillStyle = `rgba(200, 200, 220, ${alpha})`;
                this.ctx.beginPath();
                this.ctx.arc(faceX, faceY, faceSize, 0, Math.PI * 2);
                this.ctx.fill();

                // Eyes (glow on bass)
                const eyeGlow = bass > 0.6 ? 255 : 100;
                const eyeOffset = 25;

                // Left eye
                this.ctx.fillStyle = `rgb(${eyeGlow}, ${eyeGlow}, 50)`;
                this.ctx.beginPath();
                this.ctx.arc(faceX - eyeOffset, faceY - 20, 12, 0, Math.PI * 2);
                this.ctx.fill();

                // Right eye
                this.ctx.beginPath();
                this.ctx.arc(faceX + eyeOffset, faceY - 20, 12, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    renderConnectingConstellations(magnitudes) {
        // Mode 81: Stars that connect when their frequencies pass threshold
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Initialize stars
        if (!this.constellationStars) {
            this.constellationStars = [];
            const numStars = 50;
            for (let i = 0; i < numStars; i++) {
                this.constellationStars.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    freqIdx: Math.floor(Math.random() * magnitudes.length),
                    shining: false,
                    baseSize: 2 + Math.random() * 3
                });
            }
        }

        // Clear with fade
        this.ctx.fillStyle = 'rgba(0, 0, 20, 0.2)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Update stars based on their frequency
        for (const star of this.constellationStars) {
            const magnitude = magnitudes[star.freqIdx];
            star.shining = magnitude > 0.5;

            const brightness = star.shining ? 255 : 100;
            const size = star.shining ? star.baseSize * (1 + magnitude) : star.baseSize;

            // Draw star
            this.ctx.fillStyle = `rgb(${brightness}, ${brightness}, 255)`;
            this.ctx.beginPath();
            this.ctx.arc(star.x, star.y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        // Connect nearby shining stars
        this.ctx.strokeStyle = 'rgba(100, 100, 200, 0.4)';
        this.ctx.lineWidth = 1;
        for (let i = 0; i < this.constellationStars.length; i++) {
            const star1 = this.constellationStars[i];
            if (!star1.shining) continue;

            for (let j = i + 1; j < this.constellationStars.length; j++) {
                const star2 = this.constellationStars[j];
                if (!star2.shining) continue;

                const dx = star2.x - star1.x;
                const dy = star2.y - star1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 200) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(star1.x, star1.y);
                    this.ctx.lineTo(star2.x, star2.y);
                    this.ctx.stroke();
                }
            }
        }
    }

    renderMatrixRain(magnitudes) {
        // Mode 82: Falling Matrix-style characters with audio-reactive speed
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Initialize columns
        if (!this.matrixColumns) {
            this.matrixColumns = [];
            const numColumns = Math.floor(this.canvas.width / 20);
            for (let i = 0; i < numColumns; i++) {
                this.matrixColumns.push({
                    x: i * 20,
                    y: -Math.random() * this.canvas.height,
                    speed: 2 + Math.random() * 3,
                    chars: []
                });
            }
        }

        // Clear with fade for trail effect
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Update and draw columns
        this.ctx.font = '16px monospace';
        for (const column of this.matrixColumns) {
            // Speed modulated by volume
            column.y += column.speed * (1 + avgMagnitude);

            // Reset when off screen
            if (column.y > this.canvas.height + 200) {
                column.y = -100;
            }

            // Draw trail of characters
            const trailLength = 20;
            for (let i = 0; i < trailLength; i++) {
                const charY = column.y - i * 16;
                if (charY < 0 || charY > this.canvas.height) continue;

                // Brightness fades towards tail, treble adds flash
                const brightness = 150 - i * 8 + treble * 105;
                const char = String.fromCharCode(33 + Math.floor(Math.random() * 94));

                this.ctx.fillStyle = `rgb(50, ${Math.max(0, Math.min(255, brightness))}, 50)`;
                this.ctx.fillText(char, column.x, charY);
            }
        }
    }

    renderVoxelWorld(magnitudes) {
        // Mode 83: 3D voxel grid with audio shockwave
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        this.ctx.fillStyle = 'rgb(10, 10, 30)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // 3D grid parameters
        const gridSize = 8;
        const voxelSize = 30;
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;

        // Shockwave radius from bass
        const shockwave = bass * 300;

        // Draw voxel grid with 3D perspective
        for (let x = 0; x < gridSize; x++) {
            for (let z = 0; z < gridSize; z++) {
                const worldX = (x - gridSize / 2) * voxelSize;
                const worldZ = (z - gridSize / 2) * voxelSize;

                // Distance from center for shockwave
                const dist = Math.sqrt(worldX * worldX + worldZ * worldZ);

                // Height based on frequency and distance from shockwave
                const freqIdx = Math.floor(((x + z * gridSize) / (gridSize * gridSize)) * magnitudes.length);
                const magnitude = magnitudes[freqIdx];
                const shockwaveEffect = Math.max(0, 1 - Math.abs(dist - shockwave) / 50);
                const height = (magnitude + shockwaveEffect) * 100;

                // 3D to 2D projection (simple isometric)
                const screenX = centerX + worldX - worldZ * 0.5;
                const screenY = centerY + worldZ * 0.5 - height;

                // Color based on height - use color scheme
                const colorIndex = Math.floor(((x + z * gridSize) / (gridSize * gridSize)) * magnitudes.length);
                this.ctx.fillStyle = this.getColor(colorIndex, magnitudes.length);
                this.ctx.beginPath();
                this.ctx.moveTo(screenX, screenY);
                this.ctx.lineTo(screenX + voxelSize / 2, screenY + voxelSize / 4);
                this.ctx.lineTo(screenX, screenY + voxelSize / 2);
                this.ctx.lineTo(screenX - voxelSize / 2, screenY + voxelSize / 4);
                this.ctx.closePath();
                this.ctx.fill();
            }
        }
    }

    renderDNAHelixRungs(magnitudes) {
        // Mode 84: DNA double helix with rungs lighting up per frequency
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        const numRungs = 40;
        const helixRadius = 100;
        const centerX = this.canvas.width / 2;

        for (let i = 0; i < numRungs; i++) {
            const t = (i / numRungs) * Math.PI * 4 + this.frameCounter * 0.02;
            const y = (i / numRungs) * this.canvas.height;

            // Left strand
            const x1 = centerX + Math.cos(t) * helixRadius;
            // Right strand
            const x2 = centerX + Math.cos(t + Math.PI) * helixRadius;

            // Strand beads
            this.ctx.fillStyle = 'rgba(100, 150, 255, 0.8)';
            this.ctx.beginPath();
            this.ctx.arc(x1, y, 8, 0, Math.PI * 2);
            this.ctx.fill();

            this.ctx.fillStyle = 'rgba(255, 100, 150, 0.8)';
            this.ctx.beginPath();
            this.ctx.arc(x2, y, 8, 0, Math.PI * 2);
            this.ctx.fill();

            // Rung connecting strands (lit by frequency)
            const freqIdx = Math.floor((i / numRungs) * magnitudes.length);
            const magnitude = magnitudes[freqIdx];

            if (magnitude > 0.3) {
                const brightness = magnitude * 255;
                this.ctx.strokeStyle = `rgba(${brightness}, 255, ${brightness}, ${magnitude})`;
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y);
                this.ctx.lineTo(x2, y);
                this.ctx.stroke();
            }
        }
    }

    renderAudioReactiveShader(magnitudes) {
        // Mode 85: Procedural shader-like effect with audio modulation
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Pixel-based shader effect
        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        const data = imageData.data;

        const time = this.frameCounter * 0.01;
        const scale = 0.02 + avgMagnitude * 0.02;

        for (let y = 0; y < this.canvas.height; y += 2) {
            for (let x = 0; x < this.canvas.width; x += 2) {
                const idx = (y * this.canvas.width + x) * 4;

                // Normalized coordinates
                const nx = x / this.canvas.width - 0.5;
                const ny = y / this.canvas.height - 0.5;

                // Distance from center
                const dist = Math.sqrt(nx * nx + ny * ny);

                // Procedural pattern
                const wave1 = Math.sin(nx * 10 * scale + time + bass * 5) * 0.5 + 0.5;
                const wave2 = Math.cos(ny * 10 * scale + time + treble * 5) * 0.5 + 0.5;
                const pattern = wave1 * wave2;

                // Radial influence
                const radialEffect = 1 - dist;

                // Color based on pattern and audio
                const r = pattern * 255 * (1 + bass);
                const g = (1 - pattern) * 255 * avgMagnitude;
                const b = Math.sin(dist * 20 + time) * 127 + 128;

                data[idx] = Math.min(255, r * radialEffect);
                data[idx + 1] = Math.min(255, g * radialEffect);
                data[idx + 2] = Math.min(255, b * radialEffect * (1 + treble));
                data[idx + 3] = 255;
            }
        }

        this.ctx.putImageData(imageData, 0, 0);
    }

    renderSpirograph(magnitudes) {
        // Mode 86: Spirograph pattern - radii controlled by frequencies
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const mids = magnitudes.slice(Math.floor(magnitudes.length * 0.25), Math.floor(magnitudes.length * 0.75)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.5);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Clear with fade
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Spirograph parameters modulated by audio
        const R = 150 + bass * 100;  // Outer wheel radius
        const r = 50 + mids * 50;    // Inner wheel radius
        const d = 30 + treble * 40;  // Pen distance

        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;

        // Draw spirograph
        this.ctx.beginPath();
        let firstPoint = true;

        for (let t = 0; t < Math.PI * 10; t += 0.02) {
            const x = centerX + (R - r) * Math.cos(t) + d * Math.cos((R - r) / r * t);
            const y = centerY + (R - r) * Math.sin(t) - d * Math.sin((R - r) / r * t);

            if (x >= 0 && x < this.canvas.width && y >= 0 && y < this.canvas.height) {
                if (firstPoint) {
                    this.ctx.moveTo(x, y);
                    firstPoint = false;
                } else {
                    this.ctx.lineTo(x, y);
                }
            }
        }

        // Color based on treble - use color scheme
        const colorIndex = Math.floor(treble * magnitudes.length);
        this.ctx.strokeStyle = this.getColor(colorIndex, magnitudes.length);
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
    }

    renderEqualizerTower(magnitudes) {
        // Mode 87: 3D tower of stacked glowing rings
        this.ctx.fillStyle = 'rgb(0, 0, 0)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        const numRings = Math.min(magnitudes.length, 40);
        const ringHeight = this.canvas.height / numRings;
        const centerX = this.canvas.width / 2;

        for (let i = 0; i < numRings; i++) {
            const magnitude = magnitudes[i];
            const y = this.canvas.height - (i + 1) * ringHeight;
            const radius = magnitude * (this.canvas.width / 3);

            // Color gradient - use color scheme
            this.ctx.strokeStyle = this.getColor(i, numRings);

            // Ring thickness
            const thickness = 2 + magnitude * 10;
            this.ctx.lineWidth = thickness;
            this.ctx.beginPath();
            this.ctx.arc(centerX, y, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
    }

    renderAudioDrivenDoodles(magnitudes) {
        // Mode 88: Generative doodle bot - bass=90 turns, treble=shakiness
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const mids = magnitudes.slice(Math.floor(magnitudes.length * 0.25), Math.floor(magnitudes.length * 0.75)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.5);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Initialize path
        if (!this.doodlePath) {
            this.doodlePath = [{
                x: this.canvas.width / 2,
                y: this.canvas.height / 2,
                angle: 0
            }];
            this.doodleCounter = 0;
        }

        this.doodleCounter++;

        // Clear with fade
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Current position
        const current = this.doodlePath[this.doodlePath.length - 1];

        // Bass hit causes 90 turn
        if (bass > 0.6 && this.doodleCounter % 10 === 0) {
            current.angle += Math.PI / 2;
        }

        // Move forward
        const stepSize = 5 + mids * 5;
        const shakiness = treble * 10;
        let newX = current.x + Math.cos(current.angle) * stepSize + (Math.random() - 0.5) * shakiness;
        let newY = current.y + Math.sin(current.angle) * stepSize + (Math.random() - 0.5) * shakiness;

        // Keep in bounds
        newX = Math.max(50, Math.min(this.canvas.width - 50, newX));
        newY = Math.max(50, Math.min(this.canvas.height - 50, newY));

        this.doodlePath.push({ x: newX, y: newY, angle: current.angle });

        // Limit path length
        if (this.doodlePath.length > 500) {
            this.doodlePath = this.doodlePath.slice(-500);
        }

        // Draw path
        for (let i = 0; i < this.doodlePath.length - 1; i++) {
            const p1 = this.doodlePath[i];
            const p2 = this.doodlePath[i + 1];

            // Color based on mids - use color scheme
            const alpha = i / this.doodlePath.length;
            const colorIndex = Math.floor(i / this.doodlePath.length * magnitudes.length);
            const colorStr = this.getColor(colorIndex, magnitudes.length);
            const color = this.parseRgbColor(colorStr);

            this.ctx.strokeStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.lineWidth = 3;
            this.ctx.beginPath();
            this.ctx.moveTo(p1.x, p1.y);
            this.ctx.lineTo(p2.x, p2.y);
            this.ctx.stroke();
        }
    }

    renderFireworkShow(magnitudes) {
        // Mode 89: Bass launches rockets, they explode at peak with mid-range color
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const mids = magnitudes.slice(Math.floor(magnitudes.length * 0.25), Math.floor(magnitudes.length * 0.75)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.5);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Get parameters with defaults
        const bassThreshold = this.settings.fireworkShowBassThreshold || 0.3;
        const particleCount = this.settings.fireworkShowParticleCount || 150;
        const rocketSpeed = this.settings.fireworkShowRocketSpeed || 12;
        const particleSpeed = this.settings.fireworkShowParticleSpeed || 6;
        const particleSize = this.settings.fireworkShowParticleSize || 4;
        const trailLength = this.settings.fireworkShowTrailLength || 0.15;

        // Initialize rockets array
        if (!this.fireworkRockets) {
            this.fireworkRockets = [];
        }

        // Clear with fade (controlled by trailLength parameter)
        this.ctx.fillStyle = `rgba(0, 0, 10, ${trailLength})`;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Calculate average magnitude for general activity
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Launch rockets on bass hits OR periodically with any audio activity
        const shouldLaunchBass = bass > bassThreshold && this.frameCounter % 10 === 0;
        const shouldLaunchAny = avgMagnitude > 0.2 && this.frameCounter % 30 === 0;
        const shouldLaunchIdle = this.frameCounter % 60 === 0; // Always launch some even without audio

        if (shouldLaunchBass || shouldLaunchAny || shouldLaunchIdle) {
            // Store color index for this rocket so explosion uses consistent color
            const colorIndex = Math.floor(Math.random() * magnitudes.length);

            // Use bass for velocity if available, otherwise use avg magnitude
            const velocityMultiplier = bass > 0.1 ? bass : Math.max(avgMagnitude, 0.3);

            this.fireworkRockets.push({
                x: Math.random() * (this.canvas.width / 2) + this.canvas.width / 4,
                y: this.canvas.height - 50,
                vy: -rocketSpeed - velocityMultiplier * 8,
                exploded: false,
                particles: [],
                colorIndex: colorIndex
            });
        }

        // Update rockets
        const newRockets = [];
        for (const rocket of this.fireworkRockets) {
            if (!rocket.exploded) {
                rocket.y += rocket.vy;
                rocket.vy += 0.3;  // Gravity

                // Draw rocket trail (use the rocket's assigned color)
                const rocketColorStr = this.getColor(rocket.colorIndex, magnitudes.length);
                const rocketColor = this.parseRgbColor(rocketColorStr);
                this.ctx.fillStyle = `rgb(${rocketColor[0]}, ${rocketColor[1]}, ${rocketColor[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(rocket.x, rocket.y, 5, 0, Math.PI * 2);
                this.ctx.fill();

                // Explode at peak
                if (rocket.vy > 0) {
                    rocket.exploded = true;
                    // Create particle burst (particle count controlled by parameter)
                    const numParticles = Math.floor(particleCount * (0.5 + mids * 0.5));
                    for (let i = 0; i < numParticles; i++) {
                        const angle = Math.random() * 2 * Math.PI;
                        const speed = particleSpeed * (0.5 + Math.random() * 0.5);

                        // Vary color slightly for each particle
                        const colorVariation = Math.floor((i / numParticles) * magnitudes.length);
                        const particleColorIndex = (rocket.colorIndex + colorVariation) % magnitudes.length;

                        rocket.particles.push({
                            x: rocket.x,
                            y: rocket.y,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            life: 1.0,
                            colorIndex: particleColorIndex
                        });
                    }
                }
            }

            // Update explosion particles
            if (rocket.exploded) {
                const newParticles = [];
                for (const particle of rocket.particles) {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.2;  // Gravity
                    particle.life -= 0.015;

                    if (particle.life > 0) {
                        // Use particle's stored color index for consistent coloring
                        const colorStr = this.getColor(particle.colorIndex, magnitudes.length);
                        const color = this.parseRgbColor(colorStr);

                        // Size controlled by parameter and audio reactivity
                        const size = particleSize * (0.5 + treble * 0.5) * particle.life;
                        this.ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${particle.life})`;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                        this.ctx.fill();

                        newParticles.push(particle);
                    }
                }

                rocket.particles = newParticles;
                if (rocket.particles.length > 0) {
                    newRockets.push(rocket);
                }
            } else {
                newRockets.push(rocket);
            }
        }

        this.fireworkRockets = newRockets.slice(0, 20);
    }

    renderMicroscopicView(magnitudes) {
        // Mode 90: Cells jiggle and divide based on frequency
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Initialize cells
        if (!this.microscopicCells) {
            this.microscopicCells = [];
            for (let i = 0; i < 10; i++) {
                this.microscopicCells.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    radius: 30 + Math.random() * 30,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    freqIdx: i % magnitudes.length
                });
            }
        }

        // Clear
        this.ctx.fillStyle = 'rgb(240, 240, 250)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Update cells
        const newCells = [];
        for (const cell of this.microscopicCells) {
            const freqIdx = cell.freqIdx % magnitudes.length;
            const magnitude = magnitudes[freqIdx];

            // Jiggle (agitation from overall volume)
            const jiggleX = (Math.random() - 0.5) * avgMagnitude * 10;
            const jiggleY = (Math.random() - 0.5) * avgMagnitude * 10;

            cell.x += cell.vx + jiggleX;
            cell.y += cell.vy + jiggleY;

            // Bounce off walls
            if (cell.x < cell.radius || cell.x > this.canvas.width - cell.radius) {
                cell.vx *= -1;
            }
            if (cell.y < cell.radius || cell.y > this.canvas.height - cell.radius) {
                cell.vy *= -1;
            }

            // Divide when amplitude is high
            if (magnitude > 0.7 && newCells.length < 50 && Math.random() < 0.05) {
                // Create daughter cell
                newCells.push({
                    x: cell.x + 20,
                    y: cell.y + 20,
                    radius: cell.radius * 0.7,
                    vx: -cell.vx,
                    vy: -cell.vy,
                    freqIdx: freqIdx
                });
                cell.radius *= 0.7;
            }

            // Draw cell - use color scheme
            this.ctx.fillStyle = this.getColor(freqIdx, magnitudes.length);
            this.ctx.beginPath();
            this.ctx.arc(cell.x, cell.y, cell.radius, 0, Math.PI * 2);
            this.ctx.fill();

            const strokeColorIndex = (freqIdx + 1) % magnitudes.length;
            this.ctx.strokeStyle = this.getColor(strokeColorIndex, magnitudes.length);
            this.ctx.lineWidth = 2;
            this.ctx.stroke();

            newCells.push(cell);
        }

        this.microscopicCells = newCells.slice(0, 50);
    }

    /**
     * Mode 91: Burning Paper
     * Spectrum bars as flames, embers on high freq, paper curls on bass
     */
    renderBurningPaper(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Fade background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw flame bars
        const barWidth = this.canvas.width / magnitudes.length;
        for (let i = 0; i < magnitudes.length; i++) {
            const magnitude = magnitudes[i];
            const barHeight = magnitude * this.canvas.height * 0.7;
            const x = i * barWidth;
            const yBase = this.canvas.height - 50;

            // Flame effect (multiple layers)
            for (let layer = 0; layer < 3; layer++) {
                const yOffset = layer * 15;
                const layerHeight = barHeight - yOffset;
                if (layerHeight > 0) {
                    const y = yBase - layerHeight;

                    // Flame color gradient - use color scheme
                    const colorIndex = (i + layer) % magnitudes.length;
                    this.ctx.fillStyle = this.getColor(colorIndex, magnitudes.length);

                    // Flickering width
                    const flicker = Math.floor((Math.random() - 0.5) * 5);
                    this.ctx.fillRect(x + flicker, y, barWidth - 2, yBase - y);
                }
            }
        }

        // Embers on treble
        if (treble > 0.5) {
            for (let i = 0; i < treble * 20; i++) {
                const emberX = Math.random() * this.canvas.width;
                const emberY = this.canvas.height - 50 - Math.random() * 100;
                const emberColorIndex = Math.floor(Math.random() * magnitudes.length);
                this.ctx.fillStyle = this.getColor(emberColorIndex, magnitudes.length);
                this.ctx.beginPath();
                this.ctx.arc(emberX, emberY, 2, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        // Paper curl effect on bass (darken corners)
        if (bass > 0.4) {
            const curlAlpha = bass * 0.5;
            this.ctx.fillStyle = `rgba(10, 20, 20, ${curlAlpha})`;
            this.ctx.beginPath();
            this.ctx.moveTo(0, 0);
            this.ctx.lineTo(this.canvas.width * 0.2, 0);
            this.ctx.lineTo(0, this.canvas.height * 0.2);
            this.ctx.closePath();
            this.ctx.fill();
        }
    }

    /**
     * Mode 92: Swarm Intelligence
     * Boid flocking - cohesion/separation modulated by audio
     */
    renderSwarmIntelligence(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Initialize boids
        if (!this.swarmBoids) {
            this.swarmBoids = [];
            for (let i = 0; i < 40; i++) {
                this.swarmBoids.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4
                });
            }
        }

        // Fade background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Boid rules modulated by audio
        const cohesionFactor = 0.01 * (1 - bass);  // Bass scatters
        const separationFactor = 0.5 + treble * 1.5;  // Treble aligns
        const alignmentFactor = 0.05 + treble * 0.1;

        for (let boid of this.swarmBoids) {
            // Calculate forces
            let cohesionX = 0, cohesionY = 0;
            let separationX = 0, separationY = 0;
            let alignmentVx = 0, alignmentVy = 0;
            let neighbors = 0;

            for (let other of this.swarmBoids) {
                if (other === boid) continue;

                const dx = other.x - boid.x;
                const dy = other.y - boid.y;
                const dist = Math.sqrt(dx * dx + dy * dy) + 0.1;

                if (dist < 100) {
                    // Cohesion
                    cohesionX += dx;
                    cohesionY += dy;

                    // Alignment
                    alignmentVx += other.vx;
                    alignmentVy += other.vy;

                    neighbors++;
                }

                if (dist < 30) {
                    // Separation
                    separationX -= dx / dist;
                    separationY -= dy / dist;
                }
            }

            if (neighbors > 0) {
                cohesionX /= neighbors;
                cohesionY /= neighbors;
                alignmentVx /= neighbors;
                alignmentVy /= neighbors;
            }

            // Apply forces
            boid.vx += cohesionX * cohesionFactor + separationX * separationFactor + alignmentVx * alignmentFactor;
            boid.vy += cohesionY * cohesionFactor + separationY * separationFactor + alignmentVy * alignmentFactor;

            // Limit speed
            const speed = Math.sqrt(boid.vx * boid.vx + boid.vy * boid.vy);
            const maxSpeed = 5 + treble * 5;
            if (speed > maxSpeed) {
                boid.vx = (boid.vx / speed) * maxSpeed;
                boid.vy = (boid.vy / speed) * maxSpeed;
            }

            // Update position
            boid.x += boid.vx;
            boid.y += boid.vy;

            // Wrap around
            boid.x = (boid.x + this.canvas.width) % this.canvas.width;
            boid.y = (boid.y + this.canvas.height) % this.canvas.height;

            // Draw boid
            this.ctx.fillStyle = 'rgb(255, 200, 100)';
            this.ctx.beginPath();
            this.ctx.arc(boid.x, boid.y, 5, 0, Math.PI * 2);
            this.ctx.fill();

            // Draw velocity direction
            const endX = boid.x + boid.vx * 3;
            const endY = boid.y + boid.vy * 3;
            this.ctx.strokeStyle = 'rgb(255, 220, 150)';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.moveTo(boid.x, boid.y);
            this.ctx.lineTo(endX, endY);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 93: Pendulum Wave
     * Multiple pendulums with slightly different periods - force from frequency
     */
    renderPendulumWave(magnitudes) {
        const numPendulums = Math.min(magnitudes.length, 30);

        // Initialize pendulum angles
        if (!this.pendulumAngles) {
            this.pendulumAngles = new Array(numPendulums).fill(0);
        }

        // Clear background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Update and draw pendulums
        for (let i = 0; i < numPendulums; i++) {
            const magnitude = i < magnitudes.length ? magnitudes[i] : 0;

            // Period slightly different for each pendulum
            const period = 0.05 + i * 0.001;

            // Force from audio
            this.pendulumAngles[i] += period + magnitude * 0.1;

            // Pendulum position
            const xBase = (i / numPendulums) * this.canvas.width;
            const yBase = 100;

            const pendulumLength = 200 + magnitude * 100;
            const xEnd = xBase + Math.sin(this.pendulumAngles[i]) * pendulumLength;
            const yEnd = yBase + pendulumLength;

            // Draw rod
            this.ctx.strokeStyle = 'rgb(150, 150, 150)';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.moveTo(xBase, yBase);
            this.ctx.lineTo(xEnd, yEnd);
            this.ctx.stroke();

            // Draw bob - use color scheme
            const bobSize = 5 + magnitude * 15;
            this.ctx.fillStyle = this.getColor(i, numPendulums);
            this.ctx.beginPath();
            this.ctx.arc(xEnd, yEnd, bobSize, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 94: Retro Scanlines
     * Waveform on old CRT with scanlines and static
     */
    renderRetroScanlines(magnitudes) {
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Initialize CRT flicker state
        if (this.crtFlicker === undefined) {
            this.crtFlicker = 0;
        }

        // Fade background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw waveform - use color scheme
        const waveformColorIndex = Math.floor(magnitudes.length / 2);
        this.ctx.strokeStyle = this.getColor(waveformColorIndex, magnitudes.length);
        this.ctx.lineWidth = 3;
        this.ctx.beginPath();

        for (let i = 0; i < magnitudes.length; i++) {
            const x = (i / magnitudes.length) * this.canvas.width;
            const y = this.canvas.height / 2 + (magnitudes[i] - 0.5) * this.canvas.height * 0.6;

            if (i === 0) {
                this.ctx.moveTo(x, y);
            } else {
                this.ctx.lineTo(x, y);
            }
        }
        this.ctx.stroke();

        // Scanlines
        for (let y = 0; y < this.canvas.height; y += 4) {
            this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.canvas.width, y);
            this.ctx.stroke();
        }

        // Static/noise increases with treble
        if (treble > 0.3) {
            const noiseIntensity = Math.floor(treble * 50);
            for (let i = 0; i < noiseIntensity; i++) {
                const x = Math.random() * this.canvas.width;
                const y = Math.random() * this.canvas.height;
                const brightness = Math.floor(Math.random() * 155) + 100;
                this.ctx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
                this.ctx.fillRect(x, y, 1, 1);
            }
        }

        // CRT flicker
        this.crtFlicker = (this.crtFlicker + treble * 10) % 20;
        if (this.crtFlicker > 18) {
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }
    }

    /**
     * Mode 95: Pulsing Polygon
     * Central polygon with vertices pushed by frequency bands
     */
    renderPulsingPolygon(magnitudes) {
        const numVertices = Math.min(magnitudes.length, 12);

        // Fade background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Calculate vertex positions
        const vertices = [];
        for (let i = 0; i < numVertices; i++) {
            const angle = (i / numVertices) * 2 * Math.PI;
            const magnitude = i < magnitudes.length ? magnitudes[i] : 0;

            // Base radius and pushed radius
            const baseRadius = Math.min(this.canvas.width, this.canvas.height) * 0.25;
            const pushedRadius = baseRadius + magnitude * 200;

            const x = this.canvas.width / 2 + Math.cos(angle) * pushedRadius;
            const y = this.canvas.height / 2 + Math.sin(angle) * pushedRadius;
            vertices.push({ x, y });
        }

        // Draw filled polygon
        if (vertices.length > 2) {
            const avgMagnitude = magnitudes.slice(0, numVertices).reduce((a, b) => a + b, 0) / numVertices;

            // Use color scheme for polygon
            const colorIndex = Math.floor(avgMagnitude * magnitudes.length);
            this.ctx.fillStyle = this.getColor(colorIndex, magnitudes.length);
            this.ctx.beginPath();
            this.ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < vertices.length; i++) {
                this.ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            this.ctx.closePath();
            this.ctx.fill();

            // Draw outline - use color scheme
            const outlineColorIndex = (colorIndex + 1) % magnitudes.length;
            this.ctx.strokeStyle = this.getColor(outlineColorIndex, magnitudes.length);
            this.ctx.lineWidth = 3;
            this.ctx.stroke();
        }
    }

    /**
     * Mode 96: Chromatic Orb
     * 3D sphere with chromatic shader and moving light source
     */
    renderChromaticOrb(magnitudes) {
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Light source moves with stereo pan
        const left = magnitudes.slice(0, Math.floor(magnitudes.length / 2))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 2);
        const right = magnitudes.slice(Math.floor(magnitudes.length / 2))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 2);

        if (!this.chromaticOrbRotation) this.chromaticOrbRotation = 0;
        this.chromaticOrbRotation += (right - left) * 0.1;
        const lightAngle = this.chromaticOrbRotation;
        const lightX = Math.cos(lightAngle);
        const lightY = Math.sin(lightAngle);

        // Fade background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw orb
        const orbRadius = 150 + bass * 50;
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;

        for (let angleIdx = 0; angleIdx < 60; angleIdx++) {
            const angle = (angleIdx / 60) * Math.PI * 2;
            for (let radiusIdx = 0; radiusIdx < 20; radiusIdx++) {
                const radiusFactor = radiusIdx / 20;
                const radius = orbRadius * radiusFactor;

                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;

                // Lighting calculation
                const dot = Math.cos(angle) * lightX + Math.sin(angle) * lightY;
                const brightness = Math.max(0, dot) * 200 + 55;

                // Chromatic color - use color scheme
                const colorIndex = Math.floor(((angleIdx + radiusIdx) / 80) * magnitudes.length);
                this.ctx.fillStyle = this.getColor(colorIndex, magnitudes.length);
                this.ctx.beginPath();
                this.ctx.arc(x, y, 3, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 97: Textured Bars
     * Bars filled with scrolling animated texture
     */
    renderTexturedBars(magnitudes) {
        const barWidth = this.canvas.width / magnitudes.length;

        // Clear background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        for (let i = 0; i < magnitudes.length; i++) {
            const magnitude = magnitudes[i];
            const barHeight = magnitude * this.canvas.height * 0.7;
            const x = i * barWidth;
            const y = this.canvas.height - barHeight;

            // Scrolling texture (simulated with pattern)
            for (let ty = y; ty < this.canvas.height; ty += 5) {
                const scrollOffset = Math.floor((this.frameCounter * magnitude * 2) % 10);
                const patternY = (ty + scrollOffset) % 10;

                // Use color scheme for texture pattern
                const colorIndex = patternY < 5 ? i : (i + 1) % magnitudes.length;
                this.ctx.strokeStyle = this.getColor(colorIndex, magnitudes.length);

                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(x, ty);
                this.ctx.lineTo(x + barWidth - 2, ty);
                this.ctx.stroke();
            }
        }
    }

    /**
     * Mode 98: Voronoi Tessellation
     * Voronoi diagram with cells pulsing and seed points moving
     */
    renderVoronoiTessellation(magnitudes) {
        const numSeeds = Math.min(magnitudes.length, 20);
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Initialize seed positions
        if (!this.voronoiSeeds || this.voronoiSeeds.length === 0) {
            this.voronoiSeeds = [];
            for (let i = 0; i < numSeeds; i++) {
                this.voronoiSeeds.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height
                });
            }
        }

        // Update seed positions
        for (let i = 0; i < numSeeds && i < this.voronoiSeeds.length; i++) {
            const seed = this.voronoiSeeds[i];
            const magnitude = i < magnitudes.length ? magnitudes[i] : 0;

            // Seeds move slightly
            seed.x += (Math.random() - 0.5) * bass * 5;
            seed.y += (Math.random() - 0.5) * bass * 5;

            // Keep in bounds
            seed.x = Math.max(0, Math.min(this.canvas.width, seed.x));
            seed.y = Math.max(0, Math.min(this.canvas.height, seed.y));
        }

        // Draw Voronoi cells (simplified - sample points)
        for (let y = 0; y < this.canvas.height; y += 5) {
            for (let x = 0; x < this.canvas.width; x += 5) {
                // Find closest seed
                let minDist = Infinity;
                let closestIdx = 0;

                for (let i = 0; i < numSeeds && i < this.voronoiSeeds.length; i++) {
                    const seed = this.voronoiSeeds[i];
                    const dist = (x - seed.x) ** 2 + (y - seed.y) ** 2;
                    if (dist < minDist) {
                        minDist = dist;
                        closestIdx = i;
                    }
                }

                // Color based on closest seed and its magnitude
                const magnitude = closestIdx < magnitudes.length ? magnitudes[closestIdx] : 0;
                const hue = (closestIdx / numSeeds) * 180;
                const saturation = 78 + magnitude * 22;
                const value = 39 + magnitude * 61;
                const color = this.hsvToRgb(hue, saturation, value);

                this.ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                this.ctx.fillRect(x, y, 5, 5);
            }
        }

        // Draw seed points
        for (let i = 0; i < numSeeds && i < this.voronoiSeeds.length; i++) {
            const seed = this.voronoiSeeds[i];
            this.ctx.fillStyle = 'rgb(255, 255, 255)';
            this.ctx.beginPath();
            this.ctx.arc(seed.x, seed.y, 6, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 99: Shattering Glass
     * Glass pane with cracks appearing on beats
     */
    renderShatteringGlass(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        if (!this.glassCracks) this.glassCracks = [];

        // Fade background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Glass pane (semi-transparent overlay)
        this.ctx.fillStyle = 'rgba(240, 220, 200, 0.3)';
        this.ctx.fillRect(100, 100, this.canvas.width - 200, this.canvas.height - 200);

        // Create cracks on strong beats
        if (bass > 0.65 && this.glassCracks.length < 50) {
            const crackCenter = {
                x: this.canvas.width / 2 + (Math.random() - 0.5) * 200,
                y: this.canvas.height / 2 + (Math.random() - 0.5) * 200
            };

            // Radiating crack lines
            const numLines = Math.floor(4 + bass * 8);
            for (let i = 0; i < numLines; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const length = 50 + bass * 150;

                const endX = crackCenter.x + Math.cos(angle) * length;
                const endY = crackCenter.y + Math.sin(angle) * length;

                this.glassCracks.push({
                    start: crackCenter,
                    end: { x: endX, y: endY },
                    complexity: treble
                });
            }
        }

        // Draw cracks
        for (const crack of this.glassCracks) {
            const thickness = 1 + crack.complexity * 3;
            this.ctx.strokeStyle = 'rgb(50, 50, 50)';
            this.ctx.lineWidth = thickness;
            this.ctx.beginPath();
            this.ctx.moveTo(crack.start.x, crack.start.y);
            this.ctx.lineTo(crack.end.x, crack.end.y);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 100: Sunrise Sunset
     * Gradient sky with pulsing sun and glittering stars
     */
    renderSunriseSunset(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const mids = magnitudes.slice(Math.floor(magnitudes.length * 0.25), Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.5);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Sky gradient (color mapped to mid-range)
        const skyHue = 20 + mids * 100;

        for (let y = 0; y < this.canvas.height; y++) {
            const gradientFactor = y / this.canvas.height;
            const saturation = 78 - gradientFactor * 39;
            const value = 100 - gradientFactor * 39;

            const color = this.hsvToRgb(skyHue, saturation, value);
            this.ctx.strokeStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.canvas.width, y);
            this.ctx.stroke();
        }

        // Sun/Moon (pulses with bass)
        if (!this.sunPosition) this.sunPosition = this.canvas.height * 0.3;
        this.sunPosition = this.canvas.height * 0.3 + Math.sin(this.frameCounter * 0.02) * 50;
        const sunRadius = 60 + bass * 50;

        const sunColor = mids < 0.5 ? 'rgb(255, 200, 100)' : 'rgb(255, 150, 50)';
        this.ctx.fillStyle = sunColor;
        this.ctx.beginPath();
        this.ctx.arc(this.canvas.width / 2, this.sunPosition, sunRadius, 0, Math.PI * 2);
        this.ctx.fill();

        this.ctx.strokeStyle = sunColor;
        this.ctx.lineWidth = 3;
        this.ctx.globalAlpha = 0.7;
        this.ctx.beginPath();
        this.ctx.arc(this.canvas.width / 2, this.sunPosition, sunRadius + 10, 0, Math.PI * 2);
        this.ctx.stroke();
        this.ctx.globalAlpha = 1;

        // Stars glitter on treble (visible when dark)
        if (mids < 0.3) {
            const numStars = Math.floor(treble * 50 + 10);
            for (let i = 0; i < numStars; i++) {
                const starX = Math.random() * this.canvas.width;
                const starY = Math.random() * (this.canvas.height / 2);
                const brightness = 200 + treble * 55;

                this.ctx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
                this.ctx.beginPath();
                this.ctx.arc(starX, starY, 2, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 101: Neural Pulse
     * Neural network with pulsing nodes and lighting connections
     */
    renderNeuralPulse(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const mids = magnitudes.slice(Math.floor(magnitudes.length * 0.25), Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.5);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Initialize neural network nodes
        if (!this.neuralNodes) {
            this.neuralNodes = [];
            for (let i = 0; i < 30; i++) {
                this.neuralNodes.push({
                    x: 100 + Math.random() * (this.canvas.width - 200),
                    y: 100 + Math.random() * (this.canvas.height - 200),
                    layer: i % 3,  // 3 layers
                    active: 0
                });
            }
        }

        // Fade background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Update node activation based on frequency bands
        for (const node of this.neuralNodes) {
            if (node.layer === 0) node.active = bass;
            else if (node.layer === 1) node.active = mids;
            else node.active = treble;
        }

        // Draw connections that flash with amplitude
        for (let i = 0; i < this.neuralNodes.length; i++) {
            const node1 = this.neuralNodes[i];
            for (let j = i + 1; j < this.neuralNodes.length; j++) {
                const node2 = this.neuralNodes[j];
                if (Math.abs(node1.layer - node2.layer) === 1) {
                    const intensity = (node1.active + node2.active) * 127.5;
                    if (intensity > 50) {
                        const thickness = intensity < 150 ? 1 : 2;
                        this.ctx.strokeStyle = `rgb(${intensity}, ${intensity * 0.5}, ${intensity + 50})`;
                        this.ctx.lineWidth = thickness;
                        this.ctx.beginPath();
                        this.ctx.moveTo(node1.x, node1.y);
                        this.ctx.lineTo(node2.x, node2.y);
                        this.ctx.stroke();
                    }
                }
            }
        }

        // Draw pulsing nodes
        for (const node of this.neuralNodes) {
            const radius = 8 + node.active * 20;
            const hue = 140 + node.layer * 30;
            const intensity = 200 + node.active * 55;
            const color = this.hsvToRgb(hue, 100, intensity / 255 * 100);

            this.ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
            this.ctx.beginPath();
            this.ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
            this.ctx.fill();

            this.ctx.strokeStyle = 'rgb(255, 255, 255)';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.arc(node.x, node.y, radius + 3, 0, Math.PI * 2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 102: Liquid Mercury
     * Metallic liquid that ripples with physics
     */
    renderLiquidMercury(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const mids = magnitudes.slice(Math.floor(magnitudes.length * 0.25), Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.5);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        if (!this.liquidMercuryParticles) this.liquidMercuryParticles = [];

        // Fade background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Get color scheme
        const scheme = COLOR_SCHEMES[this.settings.colorScheme];
        const color1 = scheme.primary;
        const color2 = scheme.secondary;

        // Spawn mercury droplets on high treble
        if (treble > 0.5 && this.frameCounter % 3 === 0) {
            this.liquidMercuryParticles.push({
                x: 100 + Math.random() * (this.canvas.width - 200),
                y: 100,
                vx: (Math.random() - 0.5) * 4,
                vy: 0,
                radius: 10 + treble * 20
            });
        }

        // Update and draw mercury particles
        const newParticles = [];
        for (const particle of this.liquidMercuryParticles) {
            particle.vy += 0.5;  // Gravity
            particle.y += particle.vy;
            particle.x += particle.vx;

            // Boundary bouncing
            if (particle.y > this.canvas.height - 100) {
                particle.vy *= -0.7;
                particle.y = this.canvas.height - 100;
            }

            if (particle.x < 50 || particle.x > this.canvas.width - 50) {
                particle.vx *= -0.7;
            }

            if (particle.y < this.canvas.height) {
                // Draw with color scheme
                this.ctx.fillStyle = `rgb(${color1[0]}, ${color1[1]}, ${color1[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                this.ctx.fill();

                // Highlight with lighter version of secondary color
                this.ctx.fillStyle = `rgb(${Math.min(255, color2[0] + 55)}, ${Math.min(255, color2[1] + 55)}, ${Math.min(255, color2[2] + 55)})`;
                this.ctx.beginPath();
                this.ctx.arc(particle.x - 5, particle.y - 5, particle.radius / 3, 0, Math.PI * 2);
                this.ctx.fill();

                newParticles.push(particle);
            }
        }
        this.liquidMercuryParticles = newParticles;

        // Mid-range creates surface ripples
        for (let i = 0; i < mids * 5; i++) {
            const rippleX = this.canvas.width / 2 + Math.sin(this.frameCounter * 0.1 + i) * 200;
            const rippleY = this.canvas.height - 100;
            const rippleRadius = 30 + i * 20 + mids * 30;
            const midColor = `rgb(${Math.round((color1[0] + color2[0]) / 2)}, ${Math.round((color1[1] + color2[1]) / 2)}, ${Math.round((color1[2] + color2[2]) / 2)})`;
            this.ctx.strokeStyle = midColor;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(rippleX, rippleY, rippleRadius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 103: Cosmic Strings
     * Vibrating strings in space like guitar strings
     */
    renderCosmicStrings(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Initialize strings
        if (!this.cosmicStrings) {
            this.cosmicStrings = [];
            for (let i = 0; i < 12; i++) {
                this.cosmicStrings.push({
                    y: 100 + i * (this.canvas.height - 200) / 12,
                    frequency: i + 1,
                    magnitude: 0
                });
            }
        }

        // Fade background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Update and draw vibrating strings
        for (let i = 0; i < this.cosmicStrings.length; i++) {
            const string = this.cosmicStrings[i];
            string.magnitude = magnitudes[Math.min(i * 10, magnitudes.length - 1)];

            const amplitude = string.magnitude * 100;

            // Gold and white glowing strings
            const hue = 30;  // Gold
            const intensity = 200 + string.magnitude * 55;
            const color = this.hsvToRgb(hue, 78, intensity / 255 * 100);

            this.ctx.strokeStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();

            for (let x = 0; x < this.canvas.width; x += 10) {
                const wave = Math.sin(x * 0.02 * string.frequency + this.frameCounter * 0.1);
                const y = string.y + wave * amplitude;

                if (x === 0) this.ctx.moveTo(x, y);
                else this.ctx.lineTo(x, y);
            }
            this.ctx.stroke();

            // Add glow
            this.ctx.strokeStyle = 'rgb(255, 255, 255)';
            this.ctx.lineWidth = 1;
            this.ctx.stroke();
        }
    }

    /**
     * Mode 104: Particle Swarm
     * Thousands of particles forming shapes
     */
    renderParticleSwarm(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const mids = magnitudes.slice(Math.floor(magnitudes.length * 0.25), Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.5);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Get parameters with defaults
        const particleCount = this.settings.particleSwarmParticleCount || 1000;
        const spawnRate = this.settings.particleSwarmSpawnRate || 10;
        const formationRadius = (this.settings.particleSwarmFormationRadius || 150) * this.scaleFactor;
        const movementSpeed = this.settings.particleSwarmMovementSpeed || 0.05;
        const trailLength = this.settings.particleSwarmTrailLength || 5;
        const particleSize = (this.settings.particleSwarmParticleSize || 2) * this.scaleFactor;
        const trailOpacity = this.settings.particleSwarmTrailOpacity || 0.05;

        if (!this.particleSwarmArray) this.particleSwarmArray = [];

        // Fade background (controlled by trailOpacity parameter)
        this.ctx.fillStyle = `rgba(0, 0, 0, ${trailOpacity})`;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;

        // Spawn particles (controlled by particleCount and spawnRate parameters)
        // Scale factor ensures consistent appearance in preview and final video
        if (this.particleSwarmArray.length < particleCount) {
            for (let i = 0; i < spawnRate; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const distance = Math.random() * formationRadius * 1.5;
                this.particleSwarmArray.push({
                    x: centerX + Math.cos(angle) * distance,
                    y: centerY + Math.sin(angle) * distance,
                    vx: 0,
                    vy: 0,
                    trail: [],
                    colorIndex: Math.floor(Math.random() * magnitudes.length)
                });
            }
        }

        // Calculate target radius based on bass and parameters (scaled for consistency)
        const targetRadius = formationRadius + bass * formationRadius * 1.5;

        // Get color scheme
        const scheme = COLOR_SCHEMES[this.settings.colorScheme];
        const numColors = magnitudes.length;

        // Update particle positions
        for (let i = 0; i < this.particleSwarmArray.length; i++) {
            const particle = this.particleSwarmArray[i];
            const dx = centerX - particle.x;
            const dy = centerY - particle.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 0) {
                const angle = Math.atan2(dy, dx);

                let targetX, targetY;
                if (bass > 0.5) {
                    // Form circular shape on strong bass
                    targetX = centerX + Math.cos(angle) * targetRadius;
                    targetY = centerY + Math.sin(angle) * targetRadius;
                } else {
                    // Create spiral/swirling motion on treble
                    const rotationSpeed = treble * Math.PI;
                    const expansionFactor = 1 + treble * 0.5;
                    targetX = centerX + Math.cos(angle + rotationSpeed) * (distance * expansionFactor);
                    targetY = centerY + Math.sin(angle + rotationSpeed) * (distance * expansionFactor);
                }

                // Apply movement speed parameter
                particle.vx = (targetX - particle.x) * movementSpeed;
                particle.vy = (targetY - particle.y) * movementSpeed;
            }

            particle.x += particle.vx;
            particle.y += particle.vy;

            // Update trail (length controlled by parameter)
            particle.trail.push({ x: particle.x, y: particle.y });
            if (particle.trail.length > trailLength) particle.trail.shift();

            // Get color from color scheme based on particle's velocity and position
            const velocity = Math.sqrt(particle.vx ** 2 + particle.vy ** 2);
            const velocityFactor = Math.min(velocity * 50, 1);

            // Blend between primary and secondary colors based on velocity
            const colorStr = this.getColor(particle.colorIndex, numColors);
            const color = this.parseRgbColor(colorStr);

            // Add velocity-based brightness
            const brightnessFactor = 0.7 + velocityFactor * 0.3;
            const r = Math.min(255, Math.floor(color[0] * brightnessFactor));
            const g = Math.min(255, Math.floor(color[1] * brightnessFactor));
            const b = Math.min(255, Math.floor(color[2] * brightnessFactor));

            // Draw trail with fading alpha
            if (particle.trail.length > 1 && trailLength > 0) {
                for (let t = 0; t < particle.trail.length - 1; t++) {
                    const alpha = (t / particle.trail.length) * 0.5;
                    this.ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.moveTo(particle.trail[t].x, particle.trail[t].y);
                    this.ctx.lineTo(particle.trail[t + 1].x, particle.trail[t + 1].y);
                    this.ctx.stroke();
                }
            }

            // Draw particle with size parameter
            const size = particleSize * (0.8 + velocityFactor * 0.4);
            this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
            this.ctx.beginPath();
            this.ctx.arc(particle.x, particle.y, size / 2, 0, Math.PI * 2);
            this.ctx.fill();

            // Add glow effect for brighter particles
            if (velocityFactor > 0.5) {
                this.ctx.fillStyle = `rgba(${Math.min(255, r + 50)}, ${Math.min(255, g + 50)}, ${Math.min(255, b + 50)}, 0.4)`;
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        // Remove excess particles if count was reduced
        if (this.particleSwarmArray.length > particleCount) {
            this.particleSwarmArray = this.particleSwarmArray.slice(0, particleCount);
        }
    }

    /**
     * Mode 105: Crystal Lattice
     * 3D crystal structure with pulsing nodes
     */
    renderCrystalLattice(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const mids = magnitudes.slice(Math.floor(magnitudes.length * 0.25), Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.5);

        // Initialize crystal lattice nodes
        if (!this.crystalLatticeNodes) {
            this.crystalLatticeNodes = [];
            const gridSize = 5;
            const spacing = Math.min(this.canvas.width, this.canvas.height) / (gridSize + 1);
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    for (let k = 0; k < gridSize; k++) {
                        this.crystalLatticeNodes.push({
                            x3d: (i - gridSize / 2) * spacing,
                            y3d: (j - gridSize / 2) * spacing,
                            z3d: (k - gridSize / 2) * spacing,
                            magnitude: 0
                        });
                    }
                }
            }
        }

        // Fade background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        const angle = this.frameCounter * 0.02;
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;

        // Update magnitudes and project nodes
        for (let i = 0; i < this.crystalLatticeNodes.length; i++) {
            const node = this.crystalLatticeNodes[i];
            node.magnitude = magnitudes[Math.min(i * 2, magnitudes.length - 1)];

            // 3D rotation
            let x = node.x3d;
            let y = node.y3d * Math.cos(angle) - node.z3d * Math.sin(angle);
            let z = node.y3d * Math.sin(angle) + node.z3d * Math.cos(angle);

            const xRot = x * Math.cos(angle) - z * Math.sin(angle);
            const zRot = x * Math.sin(angle) + z * Math.cos(angle);

            // Perspective projection
            const scale = 300 / (300 + zRot);
            node.x2d = centerX + xRot * scale;
            node.y2d = centerY + y * scale;
            node.z2d = zRot;
        }

        // Draw connections between nearby nodes
        for (let i = 0; i < this.crystalLatticeNodes.length; i++) {
            const node1 = this.crystalLatticeNodes[i];
            for (let j = i + 1; j < Math.min(i + 10, this.crystalLatticeNodes.length); j++) {
                const node2 = this.crystalLatticeNodes[j];
                const dist = Math.sqrt(
                    (node1.x3d - node2.x3d) ** 2 +
                    (node1.y3d - node2.y3d) ** 2 +
                    (node1.z3d - node2.z3d) ** 2
                );

                if (dist < 250) {
                    const intensity = (node1.magnitude + node2.magnitude) * 127.5;
                    if (intensity > 30) {
                        this.ctx.strokeStyle = `rgb(${intensity}, ${intensity}, ${intensity + 50})`;
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.moveTo(node1.x2d, node1.y2d);
                        this.ctx.lineTo(node2.x2d, node2.y2d);
                        this.ctx.stroke();
                    }
                }
            }
        }

        // Draw nodes
        for (const node of this.crystalLatticeNodes) {
            const radius = 5 + node.magnitude * 15;
            const hue = ((node.z2d + 300) / 600) * 180;
            const color = this.hsvToRgb(hue, 100, 100);

            this.ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
            this.ctx.beginPath();
            this.ctx.arc(node.x2d, node.y2d, radius, 0, Math.PI * 2);
            this.ctx.fill();

            this.ctx.strokeStyle = 'rgb(255, 255, 255)';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.arc(node.x2d, node.y2d, radius + 2, 0, Math.PI * 2);
            this.ctx.stroke();
        }
    }

    /**
     * Generate preview frame
     */

    /**
     * Placeholder renderer for modes under development
     */
    renderPlaceholder(magnitudes, modeName, modeNumber) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));

        // Draw circular bars as placeholder
        const numBars = this.settings.numBars || 72;
        const angleStep = (Math.PI * 2) / numBars;
        // Use the innerRadius from settings, respecting preview mode settings
        const innerRadius = this.getEffectiveInnerRadius() !== undefined ? this.getEffectiveInnerRadius() : 180;

        for (let i = 0; i < numBars; i++) {
            const magnitude = magnitudes[Math.floor((i / numBars) * magnitudes.length)] || 0;
            const angle = i * angleStep;
            const barLength = magnitude * this.maxRadius * 0.8;

            const startX = this.centerX + Math.cos(angle) * innerRadius;
            const startY = this.centerY + Math.sin(angle) * innerRadius;
            const endX = this.centerX + Math.cos(angle) * (innerRadius + barLength);
            const endY = this.centerY + Math.sin(angle) * (innerRadius + barLength);

            const color = this.getColor(i, numBars);

            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = (this.settings.barWidthMultiplier || 0.8) * 8;
            this.ctx.lineCap = 'round';

            this.ctx.beginPath();
            this.ctx.moveTo(startX, startY);
            this.ctx.lineTo(endX, endY);
            this.ctx.stroke();
        }

        // Display mode name and number
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        this.ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(`Mode ${modeNumber}: ${modeName}`, this.centerX, this.centerY);
    }

    /**
     * Mode 106: Aurora Waves
     * Mode 106: Aurora borealis flowing curtains
     */
        render116LightningStorm(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 117: Cellular Growth
     * Mode 117: Biological cell division and growth
     */
        render117CellularGrowth(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 118: Sound Ribbons
     * Mode 118: 3D ribbons twisting through space
     */
        render118SoundRibbons(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numWaves = Math.floor(8 * complexity);
        for (let i = 0; i < numWaves; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const baseY = this.centerY + (i - numWaves / 2) * 20;

            const hue = ((i * 40 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.lineWidth = 2 + magnitude * 3 * intensity;
            this.ctx.beginPath();

            for (let x = 0; x < this.canvas.width; x += 10) {
                const y = baseY + Math.sin(x * 0.02 + this.frameCounter * 0.05 * speed + i) * magnitude * 50 * intensity;
                if (x === 0) this.ctx.moveTo(x, y);
                else this.ctx.lineTo(x, y);
            }
            this.ctx.stroke();
        }
    }

    /**
     * Mode 119: Matrix Rain
     * Mode 119: Matrix code rain
     */
        render119MatrixRain(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 120: Fire Mandala
     * Mode 120: Circular mandala made of flames
     */
        render120FireMandala(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 121: Tessellation Shift
     * Mode 121: Escher-style morphing tessellations
     */
        render121TessellationShift(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 122: Seismic Waves
     * Mode 122: Seismograph readings with P-waves and S-waves
     */
        render122SeismicWaves(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 123: Neon City
     * Mode 123: Cyberpunk city with pulsing lights
     */
        render123NeonCity(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 124: Magnetic Field
     * Mode 124: Magnetic field lines with particle clustering
     */
        render124MagneticField(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 125: Bubble Fusion
     * Mode 125: Bubbles that float, merge, and pop
     */
        render125BubbleFusion(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 126: Tribal Drums
     * Mode 126: Tribal patterns pulsing like drum skins
     */
        render126TribalDrums(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 127: Glass Shatter
     * Mode 127: Glass forming and shattering
     */
        render127GlassShatter(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 128: Bioluminescence
     * Mode 128: Deep ocean bioluminescent creatures
     */
        render128Bioluminescence(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 129: Sound Architecture
     * Mode 129: Impossible architecture constructing/deconstructing
     */
        render129SoundArchitecture(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 130: Plasma Ball
     * Mode 130: Plasma globe with electrical tendrils
     */
        render130PlasmaBall(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 131: Sand Mandala
     * Mode 131: Tibetan sand mandala forming grain by grain
     */
        render131SandMandala(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 132: Laser Show
     * Mode 132: Concert laser beams sweeping and bouncing
     */
        render132LaserShow(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 133: Coral Reef
     * Mode 133: Growing coral reef with swaying polyps
     */
        render133CoralReef(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 134: Wireframe Morph
     * Mode 134: 3D wireframe objects morphing between shapes
     */
        render134WireframeMorph(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 135: Sound Garden
     * Mode 135: Abstract garden with blooming flowers
     */
        render135SoundGarden(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 136: Hologram Glitch
     * Mode 136: Glitching holographic interface
     */
        render136HologramGlitch(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 137: Pendulum Wave
     * Mode 137: Multiple pendulums creating wave patterns
     */
        render137PendulumWave(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 138: Volcano Eruption
     * Mode 138: Volcano erupting with lava and ash
     */
        render138VolcanoEruption(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 139: Butterfly Effect
     * Mode 139: Chaos theory Lorenz attractor
     */
        render139ButterflyEffect(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 140: Silk Weaving
     * Mode 140: Silk threads weaving patterns
     */
        render140SilkWeaving(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 141: Clock Gears
     * Mode 141: Interlocking clockwork gears turning
     */
        render141ClockGears(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 142: Smoke Signals
     * Mode 142: Rising smoke plumes forming patterns
     */
        render142SmokeSignals(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 143: Stained Glass
     * Mode 143: Glowing stained glass window
     */
        render143StainedGlass(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 144: String Theory
     * Mode 144: Theoretical strings vibrating in multiple dimensions
     */
        render144StringTheory(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 145: Paper Craft
     * Mode 145: Paper cutouts folding into 3D shapes
     */
        render145PaperCraft(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 146: Northern Lights
     * Mode 146: Realistic aurora borealis dancing
     */
        render146NorthernLights(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 147: Cellular Automata
     * Mode 147: Conway's Game of Life with audio triggers
     */
        render147CellularAutomata(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 148: Dragon Curve
     * Mode 148: Fractal dragon curve growing
     */
        render148DragonCurve(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 149: Rain Circles
     * Mode 149: Concentric circles like raindrops
     */
        render149RainCircles(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 150: Fourier Epicycles
     * Mode 150: Rotating circles tracing Fourier series
     */
        render150FourierEpicycles(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 151: Neon Halo Burst
     * Mode 151: Circular ring whose radius pulses with kick; emits radial spikes on snare
     */
        render151NeonHaloBurst(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 152: Twin Orbiters
     * Mode 152: Two dots orbit a center with elastic distance; trails draw lissajous figure
     */
        render152TwinOrbiters(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 153: Bar Spiral Galaxy
     * Mode 153: Bars arranged in a spiral. Each bar length follows its band
     */
        render153BarSpiralGalaxy(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numPoints = Math.floor(100 * complexity);
        const hue = (this.frameCounter % 360) / 360;
        const rgb = this.hsvToRgb(hue, 0.8, 0.9);

        this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.6)`;
        this.ctx.lineWidth = 2 * intensity;
        this.ctx.beginPath();

        for (let i = 0; i < numPoints; i++) {
            const t = i / numPoints;
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = t * Math.PI * 6 + this.frameCounter * 0.01 * speed;
            const radius = t * this.maxRadius * (0.8 + magnitude * 0.2) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            if (i === 0) this.ctx.moveTo(x, y);
            else this.ctx.lineTo(x, y);
        }
        this.ctx.stroke();
    }

    /**
     * Mode 154: Ribbon Wave
     * Mode 154: Wide ribbon undulates like cloth; bass lifts amplitude
     */
        render154RibbonWave(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 155: Voxel City
     * Mode 155: 3D grid of extruded cubes like skyline; building heights react per frequency
     */
        render155VoxelCity(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 156: Sunburst Dial
     * Mode 156: 360 radial meter with ticks; ticks bend outward on mids
     */
        render156SunburstDial(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 157: Waterline Oscilloscope
     * Mode 157: Horizontal waveform floats like water surface
     */
        render158LaserTunnel(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 159: Vector Field Sprites
     * Mode 159: Thousands of particles follow a noise flow; velocity multiplies on mids
     */
        render159VectorFieldSprites(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 160: Orbit Rings Meter
     * Mode 160: Nested orbits with dots; each ring maps to a band
     */
        render160OrbitRingsMeter(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 161: Stitch Bars
     * Mode 161: Stacked micro-bars like embroidered stitches
     */
        render161StitchBars(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 162: Aurora Curtain
     * Mode 162: Vertical curtains waving; bass widens curtain
     */
        render162AuroraCurtain(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 164: Polygon Heartbeat
     * Mode 164: Regular polygon in the center inflates on kicks
     */
        render164PolygonHeartbeat(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 165: Confetti Impulse
     * Mode 165: On peaks, spawn confetti bursts
     */
        render165ConfettiImpulse(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numWaves = Math.floor(8 * complexity);
        for (let i = 0; i < numWaves; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const baseY = this.centerY + (i - numWaves / 2) * 20;

            const hue = ((i * 40 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.lineWidth = 2 + magnitude * 3 * intensity;
            this.ctx.beginPath();

            for (let x = 0; x < this.canvas.width; x += 10) {
                const y = baseY + Math.sin(x * 0.02 + this.frameCounter * 0.05 * speed + i) * magnitude * 50 * intensity;
                if (x === 0) this.ctx.moveTo(x, y);
                else this.ctx.lineTo(x, y);
            }
            this.ctx.stroke();
        }
    }

    /**
     * Mode 166: Wireframe Dome
     * Mode 166: Hemispherical mesh; vertices displace along normals
     */
        render166WireframeDome(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 167: Pulse Dashes
     * Mode 167: Circular dashed stroke; dash length oscillates with mids
     */
        render167PulseDashes(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numWaves = Math.floor(8 * complexity);
        for (let i = 0; i < numWaves; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const baseY = this.centerY + (i - numWaves / 2) * 20;

            const hue = ((i * 40 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.lineWidth = 2 + magnitude * 3 * intensity;
            this.ctx.beginPath();

            for (let x = 0; x < this.canvas.width; x += 10) {
                const y = baseY + Math.sin(x * 0.02 + this.frameCounter * 0.05 * speed + i) * magnitude * 50 * intensity;
                if (x === 0) this.ctx.moveTo(x, y);
                else this.ctx.lineTo(x, y);
            }
            this.ctx.stroke();
        }
    }

    /**
     * Mode 168: Terrain Sweep
     * Mode 168: Scrolling heightmap like synthwave hills
     */
        render168TerrainSweep(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 169: Chromatic Bars Mirror
     * Mode 169: Mirrored bars with central symmetry; hue rotates
     */
        render169ChromaticBarsMirror(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 170: Bubble Choir
     * Mode 170: Bubbles rise; size from band energy; pop on snare
     */
        render170BubbleChoir(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 171: Starfield Quantizer
     * Mode 171: Stars quantized to a grid; cell brightness follows local band
     */
        render171StarfieldQuantizer(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 172: Dna Ladder
     * Mode 172: Two sinusoid strands; rung length follows mids
     */
        render172DnaLadder(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 173: Arc Meter Trio
     * Mode 173: Three concentric arcs for lows/mids/highs
     */
        render173ArcMeterTrio(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 174: Ink Splatter Scope
     * Mode 174: Oscilloscope line with ink-style splats at transients
     */
        render175HexCellBloom(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 176: Event Horizon Lattice
     * Mode 176: Event Horizon Lattice - warped grid bends toward a black hole; streaks on transients
     */
        render176EventHorizonLattice(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 177: Comet Conveyor
     * Mode 177: Comet Conveyor - endless belt carries comets; tails shear on treble
     */
        render177CometConveyor(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 178: Quantum Foam Micro
     * Mode 178: Quantum Foam Micro - foamy micro-bubbles pop; cascades on peaks
     */
        render178QuantumFoamMicro(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 179: Aurora Crown
     * Mode 179: Aurora Crown - polar aurora dome overhead; ribbons brighten by mids
     */
        render179AuroraCrown(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 180: Asteroid Excavator
     * Mode 180: Asteroid Excavator - drill depth increases with bass; debris size follows highs
     */
        render180AsteroidExcavator(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 181: Hyperloop Spectrotrain
     * Mode 181: Hyperloop Spectrotrain - car length scales to energy; station lights strobe
     */
        render181HyperloopSpectrotrain(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 182: Galactic Pinball
     * Mode 182: Galactic Pinball - bumpers map to bands; ball boosts on peaks
     */
        render182GalacticPinball(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 183: Nebula Inkblot
     * Mirrored volumetric smoke with hue by dominant band
     */
    render183NebulaInkblot(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        // Use Step 4 settings
        const barCount = this.settings.barCount || 72;
        const innerRadius = this.getEffectiveInnerRadius();

        // Calculate frequency bands
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        // Create volumetric smoke effect with fade trails
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
        this.ctx.fillRect(0, 0, this.width, this.height);

        // Determine dominant band for color influence
        let dominantBand = 0;
        if (bass > mids && bass > treble) dominantBand = 0; // Bass - more red
        else if (mids > bass && mids > treble) dominantBand = 0.5; // Mids - green
        else dominantBand = 1; // Treble - blue

        // Number of particles affected by barCount and complexity
        const numParticles = Math.floor(40 * complexity * (barCount / 72));

        // Initialize particle history if not exists
        if (!this.nebulaParticles || this.nebulaParticles.length !== numParticles) {
            this.nebulaParticles = [];
            for (let i = 0; i < numParticles; i++) {
                this.nebulaParticles.push({
                    angle: (i / numParticles) * Math.PI * 2,
                    offset: Math.random() * Math.PI * 2
                });
            }
        }

        for (let i = 0; i < numParticles; i++) {
            const particle = this.nebulaParticles[i];
            const magnitude = magnitudes[i % magnitudes.length];

            // Update particle position with flowing motion
            particle.angle += 0.005 * speed;
            const flowAngle = particle.angle + Math.sin(this.frameCounter * 0.02 + particle.offset) * 0.5;

            // Distance from center affected by innerRadius and magnitude
            const baseDistance = (innerRadius / 180) * 0.2 + 0.4;
            const distance = this.maxRadius * (baseDistance + Math.sin(this.frameCounter * 0.03 + particle.offset) * 0.2) * (0.5 + magnitude * 0.5) * intensity;

            // Calculate position
            const offsetX = Math.cos(flowAngle) * distance;
            const offsetY = Math.sin(flowAngle) * distance;

            const size = (3 + magnitude * 8 * intensity) * (Math.min(innerRadius, 120) / 120);

            // Get base color from gradient
            const baseColor = this.getColor(i, numParticles);
            const match = baseColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            let r = 150, g = 150, b = 200;
            if (match) {
                r = parseInt(match[1]);
                g = parseInt(match[2]);
                b = parseInt(match[3]);
            }

            // Apply dominant band color shift
            const bandInfluence = 0.5 + magnitude * 0.3;
            if (dominantBand < 0.3) { // Bass - enhance red
                r = Math.min(255, r * (1 + bandInfluence * 0.5));
                b = Math.max(0, b * (1 - bandInfluence * 0.3));
            } else if (dominantBand > 0.7) { // Treble - enhance blue
                b = Math.min(255, b * (1 + bandInfluence * 0.5));
                r = Math.max(0, r * (1 - bandInfluence * 0.3));
            } else { // Mids - enhance green
                g = Math.min(255, g * (1 + bandInfluence * 0.4));
            }

            const opacity = (0.3 + magnitude * 0.5) * intensity;
            this.ctx.fillStyle = `rgba(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)}, ${opacity})`;
            this.ctx.shadowBlur = 15 * intensity * (1 + magnitude);
            this.ctx.shadowColor = `rgba(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)}, 0.6)`;

            // Draw mirrored particles (Rorschach inkblot effect)
            // Right side
            this.ctx.beginPath();
            this.ctx.arc(this.centerX + offsetX, this.centerY + offsetY, size, 0, Math.PI * 2);
            this.ctx.fill();

            // Left side (mirrored)
            this.ctx.beginPath();
            this.ctx.arc(this.centerX - offsetX, this.centerY + offsetY, size, 0, Math.PI * 2);
            this.ctx.fill();

            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 184: Satellite Telemetry Rings
     * Mode 184: Satellite Telemetry Rings - rippling rings with dashed spectrum
     */
        render184SatelliteTelemetryRings(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 185: Wormhole Origami
     * Mode 185: Wormhole Origami - sheet folds into portal; depth by bass
     */
        render185WormholeOrigami(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 186: Holographic Jellyfish
     * Mode 186: Holographic Jellyfish - bell pulsates with lows; tentacles sparkle with highs
     */
        render186HolographicJellyfish(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 187: Moon Quarry Crane
     * Mode 187: Moon Quarry Crane - bins heights equal band magnitude; dust on kicks
     */
        render187MoonQuarryCrane(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 188: Constellation Typoplot
     * Mode 188: Constellation TypoPlot - letters as stars; lines draw when band is hot
     */
        render188ConstellationTypoplot(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 189: Cryo Crystal Garden
     * Mode 189: Cryo Crystal Garden - crystals grow per frequency slice; flare on treble
     */
        render189CryoCrystalGarden(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 190: Meteorite Blueprint
     * Mode 190: Meteorite Blueprint - technical UI; callouts to bands; red stamp on peaks
     */
        render190MeteoriteBlueprint(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 191: Lunar Tide Pool
     * Mode 191: Lunar Tide Pool - water level by bass; caustics sharpen with highs
     */
        render191LunarTidePool(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 192: Orbital Barcode Slicer
     * Mode 192: Orbital Barcode Slicer - rings slice vertical barcode; brightness per band
     */
        render192OrbitalBarcodeSlicer(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 193: Satellite Swarm Flocking
     * Mode 193: Satellite Swarm Flocking - simple flock; thrust bursts on kick
     */
        render193SatelliteSwarmFlocking(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 194: Astro Pulse Weave
     * Mode 194: Astro Pulse Weave - two opposing spiral waves; brightness sum of bands
     */
        render194AstroPulseWeave(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numWaves = Math.floor(8 * complexity);
        for (let i = 0; i < numWaves; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const baseY = this.centerY + (i - numWaves / 2) * 20;

            const hue = ((i * 40 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.lineWidth = 2 + magnitude * 3 * intensity;
            this.ctx.beginPath();

            for (let x = 0; x < this.canvas.width; x += 10) {
                const y = baseY + Math.sin(x * 0.02 + this.frameCounter * 0.05 * speed + i) * magnitude * 50 * intensity;
                if (x === 0) this.ctx.moveTo(x, y);
                else this.ctx.lineTo(x, y);
            }
            this.ctx.stroke();
        }
    }

    /**
     * Mode 195: Zero G Paint Spheres
     * Mode 195: Zero-G Paint Spheres - spheres merge on peaks and split on highs
     */
        render195ZeroGPaintSpheres(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 196: Supernova Countdown
     * Mode 196: Supernova Countdown - star swells with energy; blasts at threshold
     */
        render196SupernovaCountdown(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 197: Martian Wind Harp
     * Mode 197: Martian Wind Harp - dunes as strings; ripples by mids; dust devils on snares
     */
        render197MartianWindHarp(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 198: Teleporting Bar Choir
     * Mode 198: Teleporting Bar Choir - bars pop at random radial positions; decay persists
     */
        render198TeleportingBarChoir(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 199: Cosmic Vinyl Halo
     * Mode 199: Cosmic Vinyl Halo - record edge-on; grooves shimmer with spectrum
     */
        render199CosmicVinylHalo(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 200: Photon Origination Chamber
     * Mode 200: Photon Origination Chamber - photons exit slits; rate per band bucket
     */
        render200PhotonOriginationChamber(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 201: Meteor Net
     * Mode 201: Meteor Net - hex net catches meteors; nodes glow by band
     */
        render301ForestCanopy(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 302: Ocean Waves
     * Mode 302: Flowing ocean waves with foam
     */
        render302OceanWaves(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 303: Coral Reef
     * Mode 303: Coral formations with flowing tentacles
     */
        render303CoralReef(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 304: Butterfly Swarm
     * Mode 304: Butterflies dancing to music
     */
        render304ButterflySwarm(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 305: Mountain Peaks
     * Mode 305: Mountain ranges responding to frequencies
     */
        render305MountainPeaks(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 306: Fireflies
     * Mode 306: Fireflies glowing and flickering
     */
        render306Fireflies(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 307: Flower Bloom
     * Mode 307: Flowers blooming radially
     */
        render307FlowerBloom(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 308: Rain Ripples
     * Mode 308: Rain creating ripples on water surface
     */
        render308RainRipples(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 309: Leaf Fall
     * Mode 309: Autumn leaves falling
     */
        render309LeafFall(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 310: Tree Rings
     * Mode 310: Growth rings of a tree
     */
        render310TreeRings(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 311: Lightning Storm
     * Mode 311: Lightning bolts during storm
     */
        render311LightningStorm(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 312: Pond Koi
     * Mode 312: Koi fish swimming in pond
     */
        render312PondKoi(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 313: Moss Growth
     * Mode 313: Moss spreading organically
     */
        render313MossGrowth(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 314: Aurora Forest
     * Mode 314: Northern lights over forest
     */
        render314AuroraForest(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 315: Dandelion Seeds
     * Mode 315: Dandelion seeds floating in wind
     */
        render315DandelionSeeds(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 316: Fern Fractals
     * Mode 316: Fractal fern patterns
     */
        render316FernFractals(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 317: Beehive Cells
     * Mode 317: Hexagonal honeycomb pattern
     */
        render317BeehiveCells(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 318: Wheat Field
     * Mode 318: Wheat swaying in wind
     */
        render318WheatField(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 319: Spider Web
     * Mode 319: Spider web with dew drops
     */
        render319SpiderWeb(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 320: Mushroom Spores
     * Mode 320: Mushroom spores floating
     */
        render320MushroomSpores(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 321: Bamboo Forest
     * Mode 321: Bamboo stalks swaying
     */
        render321BambooForest(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 322: Tide Pools
     * Mode 322: Tide pools with sea life
     */
        render322TidePools(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 323: Vine Tendrils
     * Mode 323: Growing vine tendrils
     */
        render323VineTendrils(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 324: Crystal Cave
     * Mode 324: Crystalline cave formations
     */
        render324CrystalCave(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 325: Bird Murmuration
     * Mode 325: Flock of birds in murmuration
     */
        render325BirdMurmuration(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 326: River Flow
     * Mode 326: River flowing with currents
     */
        render326RiverFlow(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numWaves = Math.floor(8 * complexity);
        for (let i = 0; i < numWaves; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const baseY = this.centerY + (i - numWaves / 2) * 20;

            const hue = ((i * 40 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.lineWidth = 2 + magnitude * 3 * intensity;
            this.ctx.beginPath();

            for (let x = 0; x < this.canvas.width; x += 10) {
                const y = baseY + Math.sin(x * 0.02 + this.frameCounter * 0.05 * speed + i) * magnitude * 50 * intensity;
                if (x === 0) this.ctx.moveTo(x, y);
                else this.ctx.lineTo(x, y);
            }
            this.ctx.stroke();
        }
    }

    /**
     * Mode 327: Seed Pods
     * Mode 327: Seed pods bursting open
     */
        render327SeedPods(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 328: Algae Bloom
     * Mode 328: Algae blooming in water
     */
        render328AlgaeBloom(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 329: Cactus Spines
     * Mode 329: Cactus with radiating spines
     */
        render329CactusSpines(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 330: Snowflakes
     * Mode 330: Unique snowflakes falling
     */
        render330Snowflakes(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 331: Lava Flow
     * Mode 331: Molten lava flowing
     */
        render331LavaFlow(magnitudes) {
        // Get parameters with defaults
        const lavaLayers = this.settings.mode331LavaFlowLavaLayers || 6;
        const flowSpeed = this.settings.mode331LavaFlowFlowSpeed || 1.5;
        const viscosity = this.settings.mode331LavaFlowViscosity || 0.03;
        const waveAmplitude = (this.settings.mode331LavaFlowWaveAmplitude || 40) * this.scaleFactor;
        const glowIntensity = this.settings.mode331LavaFlowGlowIntensity || 1;
        const trailOpacity = this.settings.mode331LavaFlowTrailOpacity || 0.15;

        // Calculate audio bands
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        // Initialize lava flow particles
        if (!this.lavaFlowParticles) {
            this.lavaFlowParticles = [];
        }

        // Fade background for trail effect
        this.ctx.fillStyle = `rgba(10, 0, 0, ${trailOpacity})`;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.frameCounter = (this.frameCounter || 0) + flowSpeed * 0.02;

        // Get color scheme
        const scheme = COLOR_SCHEMES[this.settings.colorScheme];
        const color1 = scheme.primary;
        const color2 = scheme.secondary;

        // Create lava-specific warm gradient from color scheme
        // Shift colors toward red/orange/yellow for lava effect
        const lavaColor1 = [
            Math.min(255, color1[0] + 50),  // Add red
            Math.max(0, color1[1] - 20),     // Reduce green
            Math.max(0, color1[2] - 50)      // Reduce blue
        ];
        const lavaColor2 = [
            Math.min(255, color2[0] + 80),   // More red
            Math.min(200, color2[1] + 30),   // Add some yellow
            Math.max(0, color2[2] - 80)      // Much less blue
        ];

        // Spawn lava bubbles on strong bass
        if (bass > 0.4 && Math.random() < bass * 0.3) {
            const spawnY = this.canvas.height - 50 * this.scaleFactor;
            const spawnX = Math.random() * this.canvas.width;
            this.lavaFlowParticles.push({
                x: spawnX,
                y: spawnY,
                vy: -(2 + bass * 4) * this.scaleFactor,
                vx: (Math.random() - 0.5) * 2 * this.scaleFactor,
                size: (5 + bass * 10) * this.scaleFactor,
                life: 1.0,
                colorIndex: Math.floor(Math.random() * magnitudes.length)
            });
        }

        // Draw flowing lava layers
        const layerSpacing = this.canvas.height / (lavaLayers + 1);

        for (let layer = 0; layer < lavaLayers; layer++) {
            const baseY = this.canvas.height - layerSpacing * (layer + 1);
            const magnitude = magnitudes[Math.floor((layer / lavaLayers) * magnitudes.length)];

            // Calculate wave properties
            const waveFrequency = viscosity * (layer + 1);
            const phaseShift = layer * 0.5;

            // Interpolate between lava colors based on layer depth
            const colorBlend = layer / lavaLayers;
            const r = Math.floor(lavaColor1[0] * (1 - colorBlend) + lavaColor2[0] * colorBlend);
            const g = Math.floor(lavaColor1[1] * (1 - colorBlend) + lavaColor2[1] * colorBlend);
            const b = Math.floor(lavaColor1[2] * (1 - colorBlend) + lavaColor2[2] * colorBlend);

            // Add heat glow based on magnitude
            const heatBoost = magnitude * glowIntensity;
            const glowR = Math.min(255, r + heatBoost * 50);
            const glowG = Math.min(255, g + heatBoost * 30);
            const glowB = Math.max(0, b);

            // Draw flowing lava wave
            this.ctx.beginPath();
            this.ctx.moveTo(0, this.canvas.height);

            for (let x = 0; x <= this.canvas.width; x += 5) {
                const wave1 = Math.sin(x * waveFrequency + this.frameCounter + phaseShift) * waveAmplitude;
                const wave2 = Math.sin(x * waveFrequency * 1.5 + this.frameCounter * 0.7) * waveAmplitude * 0.5;
                const audioReactive = magnitude * waveAmplitude * 0.5;
                const y = baseY + wave1 + wave2 + audioReactive;

                this.ctx.lineTo(x, y);
            }

            this.ctx.lineTo(this.canvas.width, this.canvas.height);
            this.ctx.closePath();

            // Fill with gradient
            const gradient = this.ctx.createLinearGradient(0, baseY - waveAmplitude, 0, baseY + waveAmplitude);
            gradient.addColorStop(0, `rgba(${glowR}, ${glowG}, ${glowB}, ${0.3 + magnitude * 0.4})`);
            gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, ${0.6 + magnitude * 0.3})`);

            this.ctx.fillStyle = gradient;
            this.ctx.fill();

            // Add glow on top
            if (glowIntensity > 0.5) {
                this.ctx.strokeStyle = `rgba(${glowR}, ${glowG}, ${glowB}, ${0.4 * magnitude})`;
                this.ctx.lineWidth = 2 * this.scaleFactor;
                this.ctx.stroke();
            }
        }

        // Update and draw lava bubbles/splashes
        const newParticles = [];
        for (const particle of this.lavaFlowParticles) {
            particle.x += particle.vx;
            particle.y += particle.vy;
            particle.vy += 0.3 * this.scaleFactor; // Gravity
            particle.life -= 0.02;

            if (particle.life > 0 && particle.y < this.canvas.height) {
                // Get color from scheme
                const colorStr = this.getColor(particle.colorIndex, magnitudes.length);
                const color = this.parseRgbColor(colorStr);

                // Make it lava-colored
                const lavaR = Math.min(255, color[0] + 80);
                const lavaG = Math.min(180, color[1]);
                const lavaB = Math.max(0, color[2] - 80);

                const alpha = particle.life * 0.8;
                const size = particle.size * particle.life;

                // Draw bubble with glow
                this.ctx.shadowBlur = 20 * this.scaleFactor * glowIntensity;
                this.ctx.shadowColor = `rgba(${lavaR}, ${Math.min(255, lavaG + 50)}, ${lavaB}, ${alpha})`;

                this.ctx.fillStyle = `rgba(${lavaR}, ${lavaG}, ${lavaB}, ${alpha})`;
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                this.ctx.fill();

                // Bright core
                this.ctx.fillStyle = `rgba(255, ${200 + mids * 55}, ${100 + treble * 100}, ${alpha * 0.6})`;
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, size * 0.5, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.shadowBlur = 0;

                newParticles.push(particle);
            }
        }
        this.lavaFlowParticles = newParticles;

        // Add heat distortion effect on strong audio
        if (bass > 0.6 || treble > 0.7) {
            const numHeatWaves = Math.floor(3 + (bass + treble) * 5);
            for (let i = 0; i < numHeatWaves; i++) {
                const x = Math.random() * this.canvas.width;
                const y = this.canvas.height - Math.random() * this.canvas.height * 0.3;
                const size = (10 + Math.random() * 30) * this.scaleFactor;

                const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, size);
                gradient.addColorStop(0, 'rgba(255, 150, 0, 0.1)');
                gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');

                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 332: Ice Crystals
     * Mode 332: Ice crystal formations
     */
        render332IceCrystals(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 333: Pine Cones
     * Mode 333: Pine cone spiral patterns
     */
        render333PineCones(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 334: Geyser Eruption
     * Mode 334: Geyser water erupting
     */
        render334GeyserEruption(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 335: Pollen Cloud
     * Mode 335: Pollen drifting in air
     */
        render335PollenCloud(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 336: Desert Dunes
     * Mode 336: Sand dunes in wind
     */
        render336DesertDunes(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 337: Lily Pads
     * Mode 337: Water lilies on pond
     */
        render337LilyPads(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 338: Termite Mound
     * Mode 338: Termite mound structure
     */
        render338TermiteMound(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 339: Cherry Blossoms
     * Mode 339: Cherry blossom petals falling
     */
        render339CherryBlossoms(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 340: Root System
     * Mode 340: Underground root network
     */
        render340RootSystem(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 341: Plankton Swarm
     * Mode 341: Bioluminescent plankton
     */
        render341PlanktonSwarm(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 342: Frost Patterns
     * Mode 342: Frost forming on glass
     */
        render342FrostPatterns(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 343: Ant Trails
     * Mode 343: Ant colony foraging trails
     */
        render343AntTrails(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 344: Seaweed Sway
     * Mode 344: Seaweed swaying underwater
     */
        render344SeaweedSway(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 345: Volcano Ash
     * Mode 345: Volcanic ash cloud
     */
        render345VolcanoAsh(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 346: Dragonfly Wings
     * Mode 346: Dragonfly wing patterns
     */
        render346DragonflyWings(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 347: Pebble Ripples
     * Mode 347: Pebbles dropping in water
     */
        render347PebbleRipples(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numWaves = Math.floor(8 * complexity);
        for (let i = 0; i < numWaves; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const baseY = this.centerY + (i - numWaves / 2) * 20;

            const hue = ((i * 40 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.lineWidth = 2 + magnitude * 3 * intensity;
            this.ctx.beginPath();

            for (let x = 0; x < this.canvas.width; x += 10) {
                const y = baseY + Math.sin(x * 0.02 + this.frameCounter * 0.05 * speed + i) * magnitude * 50 * intensity;
                if (x === 0) this.ctx.moveTo(x, y);
                else this.ctx.lineTo(x, y);
            }
            this.ctx.stroke();
        }
    }

    /**
     * Mode 348: Moss Tendrils
     * Mode 348: Moss growing on stone
     */
        render348MossTendrils(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 349: Starfish Arms
     * Mode 349: Starfish with moving arms
     */
        render349StarfishArms(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 350: Venus Flytrap
     * Mode 350: Venus flytrap opening and closing
     */
        render350VenusFlytrap(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 351: Rainbow Mist
     * Mode 351: Rainbow appearing in mist
     */
        render351RainbowMist(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 352: Geode Crystals
     * Mode 352: Crystal formations inside geode
     */
        render352GeodeCrystals(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 353: Snake Scales
     * Mode 353: Snake skin scale pattern
     */
        render353SnakeScales(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 354: Whirlpool
     * Mode 354: Water spiraling into whirlpool
     */
        render354Whirlpool(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numPoints = Math.floor(100 * complexity);
        const hue = (this.frameCounter % 360) / 360;
        const rgb = this.hsvToRgb(hue, 0.8, 0.9);

        this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.6)`;
        this.ctx.lineWidth = 2 * intensity;
        this.ctx.beginPath();

        for (let i = 0; i < numPoints; i++) {
            const t = i / numPoints;
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = t * Math.PI * 6 + this.frameCounter * 0.01 * speed;
            const radius = t * this.maxRadius * (0.8 + magnitude * 0.2) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            if (i === 0) this.ctx.moveTo(x, y);
            else this.ctx.lineTo(x, y);
        }
        this.ctx.stroke();
    }

    /**
     * Mode 355: Owl Eyes
     * Mode 355: Owl eyes blinking
     */
        render355OwlEyes(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 356: Tornado Funnel
     * Mode 356: Tornado funnel with debris
     */
        render356TornadoFunnel(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 357: Peacock Feathers
     * Mode 357: Peacock tail feather display
     */
        render357PeacockFeathers(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 358: Jellyfish Pulse
     * Mode 358: Jellyfish pulsating
     */
        render358JellyfishPulse(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 359: Sand Ripples
     * Mode 359: Ripples in sand from wind
     */
        render359SandRipples(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numWaves = Math.floor(8 * complexity);
        for (let i = 0; i < numWaves; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const baseY = this.centerY + (i - numWaves / 2) * 20;

            const hue = ((i * 40 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.lineWidth = 2 + magnitude * 3 * intensity;
            this.ctx.beginPath();

            for (let x = 0; x < this.canvas.width; x += 10) {
                const y = baseY + Math.sin(x * 0.02 + this.frameCounter * 0.05 * speed + i) * magnitude * 50 * intensity;
                if (x === 0) this.ctx.moveTo(x, y);
                else this.ctx.lineTo(x, y);
            }
            this.ctx.stroke();
        }
    }

    /**
     * Mode 360: Bat Swarm
     * Mode 360: Bats swarming from cave
     */
        render360BatSwarm(magnitudes) {
        const params = this.settings.parameters || {};
        // Use mode-specific parameters
        const batCount = params.batCount || 50;
        const swarmSpeed = params.swarmSpeed || 0.08;
        const wingSpan = params.wingSpan || 12;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        // Use Step 4 settings
        const barCount = this.settings.barCount || 72;
        const innerRadius = this.getEffectiveInnerRadius();

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        this.frameCounter = (this.frameCounter || 0) + swarmSpeed * speed;

        // Get color scheme
        const scheme = COLOR_SCHEMES[this.settings.colorScheme];
        const caveColor = scheme.primary;

        // Cave entrance at bottom center (size affected by innerRadius setting)
        const caveX = this.centerX;
        const caveY = this.canvas.height - 50;
        const caveWidth = 60 + (innerRadius / 180) * 40;  // 60-100px based on innerRadius
        const caveHeight = caveWidth * 0.5;

        // Draw cave entrance with scheme color (darker version)
        this.ctx.fillStyle = `rgba(${caveColor[0] * 0.3}, ${caveColor[1] * 0.3}, ${caveColor[2] * 0.3}, 0.8)`;
        this.ctx.beginPath();
        this.ctx.ellipse(caveX, caveY, caveWidth, caveHeight, 0, 0, Math.PI * 2);
        this.ctx.fill();

        // Draw bats swarming out (affected by barCount setting)
        const numBats = Math.floor(batCount * (0.5 + energy * 0.5) * (barCount / 72));
        for (let i = 0; i < numBats; i++) {
            const magnitude = magnitudes[i % magnitudes.length];

            // Spiral motion from cave
            const phase = this.frameCounter + i * 0.2;
            const spiralAngle = phase * (1 + complexity * 0.1);
            const spiralDist = Math.min(phase * 15, this.maxRadius * 0.8);

            // Add some randomness to make it organic
            const wobbleX = Math.sin(phase * 3 + i) * 20 * magnitude;
            const wobbleY = Math.cos(phase * 2.3 + i) * 15 * magnitude;

            const x = caveX + Math.sin(spiralAngle) * spiralDist + wobbleX;
            const y = caveY - spiralDist * 0.6 + Math.cos(spiralAngle * 0.7) * spiralDist * 0.3 + wobbleY;

            // Only draw bats that are visible on screen
            if (x >= 0 && x <= this.canvas.width && y >= 0 && y <= this.canvas.height) {
                // Get color from scheme with gradient
                const batColor = this.getColor(i, numBats);

                // Parse RGB from the color string
                const match = batColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                let r = 20, g = 20, b = 20;
                if (match) {
                    r = parseInt(match[1]);
                    g = parseInt(match[2]);
                    b = parseInt(match[3]);
                }

                const opacity = Math.min(1, spiralDist / 100) * (0.6 + magnitude * 0.4);
                this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                this.ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                this.ctx.lineWidth = 2;

                // Wing flap animation
                const wingFlap = Math.sin(phase * 8) * 0.3 + 0.7; // Oscillates between 0.4 and 1.0
                const currentWingSpan = wingSpan * wingFlap;

                // Draw bat shape (body + wings)
                this.ctx.beginPath();
                // Left wing
                this.ctx.moveTo(x - currentWingSpan, y);
                this.ctx.lineTo(x, y - 5);
                // Right wing
                this.ctx.lineTo(x + currentWingSpan, y);
                this.ctx.stroke();

                // Bat body
                this.ctx.beginPath();
                this.ctx.arc(x, y, 2, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 361: Tide Motion
     * Mode 361: Tidal motion advancing and retreating
     */
        render361TideMotion(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 362: Lichen Growth
     * Mode 362: Lichen spreading on rock
     */
        render362LichenGrowth(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 363: Eagle Soar
     * Mode 363: Eagle soaring in thermals
     */
        render363EagleSoar(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 364: Mangrove Roots
     * Mode 364: Mangrove root system
     */
        render364MangroveRoots(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 365: Aurora Waves
     * Mode 365: Aurora borealis curtain waves
     */
        render365AuroraWaves(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 366: Dolphin Leap
     * Mode 366: Dolphins leaping from water
     */
        render366DolphinLeap(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 367: Tumbleweed Roll
     * Mode 367: Tumbleweed rolling across desert
     */
        render367TumbleweedRoll(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 368: Coral Polyps
     * Mode 368: Coral polyps extending tentacles
     */
        render368CoralPolyps(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 369: Smoke Wisps
     * Mode 369: Smoke wisps rising
     */
        render369SmokeWisps(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 370: Nautilus Shell
     * Mode 370: Nautilus shell spiral
     */
        render370NautilusShell(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 371: Wolf Howl
     * Mode 371: Wolf howling at moon with sound waves
     */
        render371WolfHowl(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 372: Seashell Patterns
     * Mode 372: Various seashell patterns
     */
        render372SeashellPatterns(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 373: Grass Blades
     * Mode 373: Individual grass blades swaying
     */
        render373GrassBlades(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 374: Stalactites
     * Mode 374: Cave stalactites and stalagmites
     */
        render374Stalactites(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 375: Amoeba Movement
     * Mode 375: Amoeba-like organic movement
     */
        render375AmoebaMovement(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 376: Pine Needles
     * Mode 376: Pine needle clusters
     */
        render376PineNeedles(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 377: Water Droplet
     * Mode 377: Water droplet impact and splash
     */
        render377WaterDroplet(magnitudes) {
        // Get parameters with defaults
        const dropletSize = (this.settings.mode377WaterDropletDropletSize || 8) * this.scaleFactor;
        const dropFrequency = this.settings.mode377WaterDropletDropFrequency || 0.1;
        const splashIntensity = this.settings.mode377WaterDropletSplashIntensity || 1;
        const rippleCount = this.settings.mode377WaterDropletRippleCount || 5;
        const impactThreshold = this.settings.mode377WaterDropletImpactThreshold || 0.4;
        const trailOpacity = this.settings.mode377WaterDropletTrailOpacity || 0.08;

        // Calculate audio bands
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        // Initialize droplet arrays
        if (!this.waterDroplets) this.waterDroplets = [];
        if (!this.waterRipples) this.waterRipples = [];
        if (!this.waterSplashes) this.waterSplashes = [];

        // Fade background for trail effect
        this.ctx.fillStyle = `rgba(0, 5, 15, ${trailOpacity})`;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Get color scheme (make it water-themed)
        const scheme = COLOR_SCHEMES[this.settings.colorScheme];
        const color1 = scheme.primary;
        const color2 = scheme.secondary;

        // Create water-specific colors (shift toward blue/cyan)
        const waterColor1 = [
            Math.max(0, color1[0] - 50),      // Reduce red
            Math.min(255, color1[1] + 30),    // Add green
            Math.min(255, color1[2] + 80)     // Add blue
        ];
        const waterColor2 = [
            Math.max(0, color2[0] - 80),      // Much less red
            Math.min(255, color2[1] + 50),    // More green
            Math.min(255, color2[2] + 100)    // Much more blue
        ];

        // Spawn water droplets
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const spawnChance = dropFrequency * (0.5 + avgMagnitude * 0.5);

        if (Math.random() < spawnChance || (bass > impactThreshold && Math.random() < 0.3)) {
            const x = this.centerX + (Math.random() - 0.5) * this.canvas.width * 0.6;
            const colorIndex = Math.floor(Math.random() * magnitudes.length);
            this.waterDroplets.push({
                x: x,
                y: 0,
                vy: (2 + Math.random() * 3) * this.scaleFactor,
                size: dropletSize * (0.7 + Math.random() * 0.6),
                colorIndex: colorIndex
            });
        }

        // Water surface level
        const waterLevel = this.canvas.height * 0.7;

        // Update and draw falling droplets
        const newDroplets = [];
        for (const droplet of this.waterDroplets) {
            droplet.y += droplet.vy;
            droplet.vy += 0.2 * this.scaleFactor; // Gravity

            // Check if droplet hits water surface
            if (droplet.y >= waterLevel) {
                // Create splash
                const splashSize = droplet.size * splashIntensity;
                const numSplashParticles = Math.floor(8 + bass * 12);

                for (let i = 0; i < numSplashParticles; i++) {
                    const angle = (i / numSplashParticles) * Math.PI - Math.PI / 2;
                    const speed = (2 + Math.random() * 4) * splashIntensity * this.scaleFactor;
                    this.waterSplashes.push({
                        x: droplet.x,
                        y: waterLevel,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: splashSize * (0.5 + Math.random() * 0.5),
                        life: 1.0,
                        colorIndex: droplet.colorIndex
                    });
                }

                // Create ripples
                this.waterRipples.push({
                    x: droplet.x,
                    y: waterLevel,
                    radius: 0,
                    maxRadius: (50 + bass * 100) * this.scaleFactor,
                    life: 1.0,
                    colorIndex: droplet.colorIndex
                });
            } else if (droplet.y < waterLevel) {
                // Draw falling droplet
                const colorStr = this.getColor(droplet.colorIndex, magnitudes.length);
                const color = this.parseRgbColor(colorStr);

                // Make it water-colored
                const waterR = Math.max(0, color[0] - 50);
                const waterG = Math.min(255, color[1] + 30);
                const waterB = Math.min(255, color[2] + 80);

                // Draw droplet with motion blur
                this.ctx.fillStyle = `rgba(${waterR}, ${waterG}, ${waterB}, 0.7)`;
                this.ctx.beginPath();
                this.ctx.ellipse(droplet.x, droplet.y, droplet.size * 0.6, droplet.size, 0, 0, Math.PI * 2);
                this.ctx.fill();

                // Highlight
                this.ctx.fillStyle = `rgba(${Math.min(255, waterR + 100)}, ${Math.min(255, waterG + 100)}, 255, 0.6)`;
                this.ctx.beginPath();
                this.ctx.arc(droplet.x - droplet.size * 0.2, droplet.y - droplet.size * 0.2, droplet.size * 0.3, 0, Math.PI * 2);
                this.ctx.fill();

                newDroplets.push(droplet);
            }
        }
        this.waterDroplets = newDroplets;

        // Update and draw splash particles
        const newSplashes = [];
        for (const splash of this.waterSplashes) {
            splash.x += splash.vx;
            splash.y += splash.vy;
            splash.vy += 0.3 * this.scaleFactor; // Gravity
            splash.life -= 0.02;

            if (splash.life > 0 && splash.y < waterLevel + 50 * this.scaleFactor) {
                const colorStr = this.getColor(splash.colorIndex, magnitudes.length);
                const color = this.parseRgbColor(colorStr);

                const waterR = Math.max(0, color[0] - 50);
                const waterG = Math.min(255, color[1] + 30);
                const waterB = Math.min(255, color[2] + 80);

                const alpha = splash.life * 0.7;
                const size = splash.size * splash.life;

                this.ctx.fillStyle = `rgba(${waterR}, ${waterG}, ${waterB}, ${alpha})`;
                this.ctx.beginPath();
                this.ctx.arc(splash.x, splash.y, size, 0, Math.PI * 2);
                this.ctx.fill();

                newSplashes.push(splash);
            }
        }
        this.waterSplashes = newSplashes;

        // Update and draw ripples
        const newRipples = [];
        for (const ripple of this.waterRipples) {
            ripple.radius += (ripple.maxRadius / 50) * this.scaleFactor;
            ripple.life -= 0.015;

            if (ripple.life > 0 && ripple.radius < ripple.maxRadius) {
                const colorStr = this.getColor(ripple.colorIndex, magnitudes.length);
                const color = this.parseRgbColor(colorStr);

                const waterR = Math.max(0, color[0] - 50);
                const waterG = Math.min(255, color[1] + 30);
                const waterB = Math.min(255, color[2] + 80);

                // Draw multiple concentric ripples
                for (let i = 0; i < rippleCount; i++) {
                    const rippleRadius = ripple.radius - i * 20 * this.scaleFactor;
                    if (rippleRadius > 0) {
                        const alpha = ripple.life * (0.3 - i * 0.05);
                        const lineWidth = (2 + mids * 3) * this.scaleFactor;

                        this.ctx.strokeStyle = `rgba(${waterR}, ${waterG}, ${waterB}, ${alpha})`;
                        this.ctx.lineWidth = lineWidth;
                        this.ctx.beginPath();
                        this.ctx.arc(ripple.x, ripple.y, rippleRadius, 0, Math.PI * 2);
                        this.ctx.stroke();

                        // Bright highlight
                        this.ctx.strokeStyle = `rgba(${Math.min(255, waterR + 100)}, ${Math.min(255, waterG + 100)}, 255, ${alpha * 0.5})`;
                        this.ctx.lineWidth = lineWidth * 0.5;
                        this.ctx.stroke();
                    }
                }

                newRipples.push(ripple);
            }
        }
        this.waterRipples = newRipples;

        // Draw water surface
        this.ctx.strokeStyle = `rgba(${waterColor1[0]}, ${waterColor1[1]}, ${waterColor1[2]}, 0.3)`;
        this.ctx.lineWidth = 2 * this.scaleFactor;
        this.ctx.beginPath();

        for (let x = 0; x <= this.canvas.width; x += 5) {
            const wave = Math.sin(x * 0.02 + this.frameCounter * 0.1) * 5 * this.scaleFactor * mids;
            const y = waterLevel + wave;
            if (x === 0) this.ctx.moveTo(x, y);
            else this.ctx.lineTo(x, y);
        }
        this.ctx.stroke();

        // Add shimmer effect on water surface
        if (treble > 0.5) {
            const numShimmers = Math.floor(3 + treble * 7);
            for (let i = 0; i < numShimmers; i++) {
                const x = Math.random() * this.canvas.width;
                const size = (5 + Math.random() * 15) * this.scaleFactor;

                const gradient = this.ctx.createRadialGradient(x, waterLevel, 0, x, waterLevel, size);
                gradient.addColorStop(0, `rgba(${Math.min(255, waterColor2[0] + 100)}, ${Math.min(255, waterColor2[1] + 100)}, 255, 0.4)`);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(x, waterLevel, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        this.frameCounter = (this.frameCounter || 0) + 1;
    }

    /**
     * Mode 378: Succulent Rosette
     * Mode 378: Succulent plant rosette pattern
     */
        render378SucculentRosette(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 379: Salmon Upstream
     * Mode 379: Salmon swimming upstream
     */
        render379SalmonUpstream(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numWaves = Math.floor(8 * complexity);
        for (let i = 0; i < numWaves; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const baseY = this.centerY + (i - numWaves / 2) * 20;

            const hue = ((i * 40 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.lineWidth = 2 + magnitude * 3 * intensity;
            this.ctx.beginPath();

            for (let x = 0; x < this.canvas.width; x += 10) {
                const y = baseY + Math.sin(x * 0.02 + this.frameCounter * 0.05 * speed + i) * magnitude * 50 * intensity;
                if (x === 0) this.ctx.moveTo(x, y);
                else this.ctx.lineTo(x, y);
            }
            this.ctx.stroke();
        }
    }

    /**
     * Mode 380: Cloud Formation
     * Mode 380: Clouds forming and dispersing
     */
        render380CloudFormation(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 381: Fox Tail
     * Mode 381: Fox tail swishing
     */
        render381FoxTail(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 382: Clover Field
     * Mode 382: Field of four-leaf clovers
     */
        render382CloverField(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 383: Geyser Field
     * Mode 383: Multiple geysers erupting
     */
        render383GeyserField(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 384: Insect Compound Eye
     * Mode 384: Compound eye of an insect
     */
        render384InsectCompoundEye(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 385: Moonflower Bloom
     * Mode 385: Moonflower blooming at night
     */
        render385MoonflowerBloom(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 386: Sand Dollar
     * Mode 386: Sand dollar pattern
     */
        render386SandDollar(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 387: Glacier Crevasse
     * Mode 387: Deep crevasse in glacier
     */
        render387GlacierCrevasse(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 388: Antler Growth
     * Mode 388: Deer antler branching pattern
     */
        render388AntlerGrowth(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 389: Plume Worm
     * Mode 389: Feather duster worm plume
     */
        render389PlumeWorm(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 390: Reed Marsh
     * Mode 390: Reeds swaying in marsh
     */
        render390ReedMarsh(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 391: Beetle Shell
     * Mode 391: Iridescent beetle shell pattern
     */
        render391BeetleShell(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 392: Tide Anemone
     * Mode 392: Sea anemone in tidal zone
     */
        render392TideAnemone(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 393: Earthquake Waves
     * Mode 393: Seismic waves propagating
     */
        render393EarthquakeWaves(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 394: Butterfly Lifecycle
     * Mode 394: Butterfly metamorphosis stages
     */
        render394ButterflyLifecycle(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 395: Coconut Palm
     * Mode 395: Palm tree with coconuts
     */
        render395CoconutPalm(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 396: Frost Ferns
     * Mode 396: Frost fern patterns on window
     */
        render396FrostFerns(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 397: Bioluminescent Bay
     * Mode 397: Bioluminescent organisms in bay
     */
        render397BioluminescentBay(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 398: Erosion Patterns
     * Mode 398: Water erosion creating patterns
     */
        render398ErosionPatterns(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 399: Hedge Maze
     * Mode 399: Hedge maze from above
     */
        render399HedgeMaze(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 400: Water Lily Reflection
     * Mode 400: Water lily with mirror reflection
     */
        render701BinaryRain(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 702: Hexadecimal Grid
     * Mode 702: Hexadecimal grid visualization
     */
        render702HexadecimalGrid(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 703: Circuit Board
     * Mode 703: Circuit board visualization
     */
        render703CircuitBoard(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 704: Data Flow
     * Mode 704: Data flow visualization
     */
        render704DataFlow(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 705: Packet Transmission
     * Mode 705: Packet transmission visualization
     */
        render705PacketTransmission(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 706: Network Topology
     * Mode 706: Network topology visualization
     */
        render706NetworkTopology(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 707: Server Cluster
     * Mode 707: Server cluster visualization
     */
        render707ServerCluster(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 708: Cloud Computing
     * Mode 708: Cloud computing visualization
     */
        render708CloudComputing(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 709: Distributed System
     * Mode 709: Distributed system visualization
     */
        render709DistributedSystem(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 710: Peer To Peer
     * Mode 710: Peer-to-peer visualization
     */
        render710PeerToPeer(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 711: Blockchain
     * Mode 711: Blockchain visualization
     */
        render711Blockchain(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 712: Hash Function
     * Mode 712: Hash function visualization
     */
        render712HashFunction(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 713: Encryption
     * Mode 713: Encryption visualization
     */
        render713Encryption(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 714: Public Key
     * Mode 714: Public key visualization
     */
        render714PublicKey(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 715: Digital Signature
     * Mode 715: Digital signature visualization
     */
        render715DigitalSignature(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 716: Zero Knowledge Proof
     * Mode 716: Zero knowledge proof visualization
     */
        render716ZeroKnowledgeProof(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 717: Homomorphic Encryption
     * Mode 717: Homomorphic encryption visualization
     */
        render717HomomorphicEncryption(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 718: Secure Multiparty Computation
     * Mode 718: Secure multiparty computation visualization
     */
        render718SecureMultipartyComputation(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 719: Differential Privacy
     * Mode 719: Differential privacy visualization
     */
        render719DifferentialPrivacy(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 720: Federated Learning
     * Mode 720: Federated learning visualization
     */
        render720FederatedLearning(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 721: Neural Network
     * Mode 721: Neural network visualization
     */
        render721NeuralNetwork(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 722: Deep Learning
     * Mode 722: Deep learning visualization
     */
        render722DeepLearning(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 723: Convolutional Layer
     * Mode 723: Convolutional layer visualization
     */
        render723ConvolutionalLayer(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 724: Recurrent Connection
     * Mode 724: Recurrent connection visualization
     */
        render724RecurrentConnection(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numWaves = Math.floor(8 * complexity);
        for (let i = 0; i < numWaves; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const baseY = this.centerY + (i - numWaves / 2) * 20;

            const hue = ((i * 40 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.lineWidth = 2 + magnitude * 3 * intensity;
            this.ctx.beginPath();

            for (let x = 0; x < this.canvas.width; x += 10) {
                const y = baseY + Math.sin(x * 0.02 + this.frameCounter * 0.05 * speed + i) * magnitude * 50 * intensity;
                if (x === 0) this.ctx.moveTo(x, y);
                else this.ctx.lineTo(x, y);
            }
            this.ctx.stroke();
        }
    }

    /**
     * Mode 725: Attention Mechanism
     * Mode 725: Attention mechanism visualization
     */
        render725AttentionMechanism(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 726: Transformer Architecture
     * Mode 726: Transformer architecture visualization
     */
        render726TransformerArchitecture(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 727: Residual Connection
     * Mode 727: Residual connection visualization
     */
        render727ResidualConnection(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 728: Skip Connection
     * Mode 728: Skip connection visualization
     */
        render728SkipConnection(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 729: Batch Normalization
     * Mode 729: Batch normalization visualization
     */
        render729BatchNormalization(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 730: Dropout Regularization
     * Mode 730: Dropout regularization visualization
     */
        render730DropoutRegularization(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 731: Activation Function
     * Mode 731: Activation function visualization
     */
        render731ActivationFunction(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 732: Gradient Descent
     * Mode 732: Gradient descent visualization
     */
        render732GradientDescent(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 733: Backpropagation
     * Mode 733: Backpropagation visualization
     */
        render733Backpropagation(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 734: Loss Landscape
     * Mode 734: Loss landscape visualization
     */
        render734LossLandscape(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 735: Optimizer Trajectory
     * Mode 735: Optimizer trajectory visualization
     */
        render735OptimizerTrajectory(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 736: Learning Rate Schedule
     * Mode 736: Learning rate schedule visualization
     */
        render736LearningRateSchedule(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 737: Momentum
     * Mode 737: Momentum visualization
     */
        render737Momentum(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 738: Adaptive Learning
     * Mode 738: Adaptive learning visualization
     */
        render738AdaptiveLearning(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 739: Weight Decay
     * Mode 739: Weight decay visualization
     */
        render739WeightDecay(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 740: Early Stopping
     * Mode 740: Early stopping visualization
     */
        render740EarlyStopping(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 741: Cross Validation
     * Mode 741: Cross validation visualization
     */
        render741CrossValidation(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 742: Ensemble Method
     * Mode 742: Ensemble method visualization
     */
        render742EnsembleMethod(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 743: Boosting
     * Mode 743: Boosting visualization
     */
        render743Boosting(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 744: Bagging
     * Mode 744: Bagging visualization
     */
        render744Bagging(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 745: Random Forest
     * Mode 745: Random forest visualization
     */
        render745RandomForest(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 746: Decision Tree
     * Mode 746: Decision tree visualization
     */
        render746DecisionTree(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 747: Support Vector Machine
     * Mode 747: Support vector machine visualization
     */
        render747SupportVectorMachine(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 748: Kernel Trick
     * Mode 748: Kernel trick visualization
     */
        render748KernelTrick(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 749: Feature Space
     * Mode 749: Feature space visualization
     */
        render749FeatureSpace(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 750: Dimensionality Reduction
     * Mode 750: Dimensionality reduction visualization
     */
        render750DimensionalityReduction(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 751: Principal Component Analysis
     * Mode 751: Principal component analysis visualization
     */
        render751PrincipalComponentAnalysis(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 752: T Sne Embedding
     * Mode 752: T-sne embedding visualization
     */
        render752TSneEmbedding(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 753: Autoencoder Latent Space
     * Mode 753: Autoencoder latent space visualization
     */
        render753AutoencoderLatentSpace(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 754: Variational Autoencoder
     * Mode 754: Variational autoencoder visualization
     */
        render754VariationalAutoencoder(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 755: Generative Adversarial Network
     * Mode 755: Generative adversarial network visualization
     */
        render755GenerativeAdversarialNetwork(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 756: Discriminator Network
     * Mode 756: Discriminator network visualization
     */
        render756DiscriminatorNetwork(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 757: Generator Network
     * Mode 757: Generator network visualization
     */
        render757GeneratorNetwork(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 758: Style Transfer
     * Mode 758: Style transfer visualization
     */
        render758StyleTransfer(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 759: Content Loss
     * Mode 759: Content loss visualization
     */
        render759ContentLoss(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 760: Gram Matrix
     * Mode 760: Gram matrix visualization
     */
        render760GramMatrix(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 761: Perceptual Loss
     * Mode 761: Perceptual loss visualization
     */
        render761PerceptualLoss(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 762: Adversarial Loss
     * Mode 762: Adversarial loss visualization
     */
        render762AdversarialLoss(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 763: Cycle Consistency
     * Mode 763: Cycle consistency visualization
     */
        render763CycleConsistency(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 764: Identity Loss
     * Mode 764: Identity loss visualization
     */
        render764IdentityLoss(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 765: Reconstruction Loss
     * Mode 765: Reconstruction loss visualization
     */
        render765ReconstructionLoss(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 766: Kl Divergence
     * Mode 766: Kl divergence visualization
     */
        render766KlDivergence(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 767: Wasserstein Distance
     * Mode 767: Wasserstein distance visualization
     */
        render767WassersteinDistance(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 768: Earth Mover Distance
     * Mode 768: Earth mover distance visualization
     */
        render768EarthMoverDistance(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 769: Inception Score
     * Mode 769: Inception score visualization
     */
        render769InceptionScore(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 770: Frechet Inception Distance
     * Mode 770: Frechet inception distance visualization
     */
        render770FrechetInceptionDistance(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 771: Bleu Score
     * Mode 771: Bleu score visualization
     */
        render771BleuScore(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 772: Rouge Score
     * Mode 772: Rouge score visualization
     */
        render772RougeScore(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 773: Perplexity
     * Mode 773: Perplexity visualization
     */
        render773Perplexity(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 774: Cross Entropy
     * Mode 774: Cross entropy visualization
     */
        render774CrossEntropy(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 775: Mutual Information
     * Mode 775: Mutual information visualization
     */
        render775MutualInformation(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 776: Information Bottleneck
     * Mode 776: Information bottleneck visualization
     */
        render776InformationBottleneck(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 777: Rate Distortion
     * Mode 777: Rate distortion visualization
     */
        render777RateDistortion(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 778: Source Coding
     * Mode 778: Source coding visualization
     */
        render778SourceCoding(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 779: Channel Coding
     * Mode 779: Channel coding visualization
     */
        render779ChannelCoding(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 780: Error Correction
     * Mode 780: Error correction visualization
     */
        render780ErrorCorrection(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 781: Hamming Distance
     * Mode 781: Hamming distance visualization
     */
        render781HammingDistance(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 782: Reed Solomon
     * Mode 782: Reed solomon visualization
     */
        render782ReedSolomon(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 783: Turbo Code
     * Mode 783: Turbo code visualization
     */
        render783TurboCode(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 784: Ldpc Code
     * Mode 784: Ldpc code visualization
     */
        render784LdpcCode(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 785: Polar Code
     * Mode 785: Polar code visualization
     */
        render785PolarCode(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 786: Quantum Error Correction
     * Mode 786: Quantum error correction visualization
     */
        render786QuantumErrorCorrection(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 787: Surface Code
     * Mode 787: Surface code visualization
     */
        render787SurfaceCode(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 788: Toric Code
     * Mode 788: Toric code visualization
     */
        render788ToricCode(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 789: Color Code
     * Mode 789: Color code visualization
     */
        render789ColorCode(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 790: Stabilizer Formalism
     * Mode 790: Stabilizer formalism visualization
     */
        render790StabilizerFormalism(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 791: Clifford Gate
     * Mode 791: Clifford gate visualization
     */
        render791CliffordGate(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 792: Pauli Group
     * Mode 792: Pauli group visualization
     */
        render792PauliGroup(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 793: Measurement Based Quantum Computing
     * Mode 793: Measurement based quantum computing visualization
     */
        render793MeasurementBasedQuantumComputing(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 794: One Way Quantum Computer
     * Mode 794: One way quantum computer visualization
     */
        render794OneWayQuantumComputer(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 795: Adiabatic Quantum Computation
     * Mode 795: Adiabatic quantum computation visualization
     */
        render795AdiabaticQuantumComputation(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 796: Quantum Annealing
     * Mode 796: Quantum annealing visualization
     */
        render796QuantumAnnealing(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 797: Variational Quantum Eigensolver
     * Mode 797: Variational quantum eigensolver visualization
     */
        render797VariationalQuantumEigensolver(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 798: Quantum Approximate Optimization
     * Mode 798: Quantum approximate optimization visualization
     */
        render798QuantumApproximateOptimization(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 799: Quantum Phase Estimation
     * Mode 799: Quantum phase estimation visualization
     */
        render799QuantumPhaseEstimation(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 800: Quantum Fourier Transform
     * Mode 800: Quantum fourier transform visualization
     */
        render800QuantumFourierTransform(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 801: Mandala
     * Mode 801: Mandala visualization
     */
    render801Mandala(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 802: Yantra
     * Mode 802: Yantra visualization
     */
    render802Yantra(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 803: Lotus
     * Mode 803: Lotus visualization
     */
    render803Lotus(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 804: Om Symbol
     * Mode 804: Om symbol visualization
     */
    render804OmSymbol(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 805: Chakra
     * Mode 805: Chakra visualization
     */
    render805Chakra(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 806: Aura Field
     * Mode 806: Aura field visualization
     */
    render806AuraField(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 807: Third Eye
     * Mode 807: Third eye visualization
     */
    render807ThirdEye(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 808: Kundalini
     * Mode 808: Kundalini visualization
     */
    render808Kundalini(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 809: Merkaba
     * Mode 809: Merkaba visualization
     */
    render809Merkaba(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 810: Flower Of Life
     * Mode 810: Flower of life visualization
     */
    render810FlowerOfLife(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 811: Seed Of Life
     * Mode 811: Seed of life visualization
     */
    render811SeedOfLife(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 812: Tree Of Life
     * Mode 812: Tree of life visualization
     */
    render812TreeOfLife(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 813: Metatron Cube
     * Mode 813: Metatron cube visualization
     */
    render813MetatronCube(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 814: Sri Yantra
     * Mode 814: Sri yantra visualization
     */
    render814SriYantra(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 815: Shri Yantra
     * Mode 815: Shri yantra visualization
     */
    render815ShriYantra(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 816: Tibetan Sand Mandala
     * Mode 816: Tibetan sand mandala visualization
     */
    render816TibetanSandMandala(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 817: Zen Circle
     * Mode 817: Zen circle visualization
     */
    render817ZenCircle(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 818: Yin Yang
     * Mode 818: Yin yang visualization
     */
    render818YinYang(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 819: Tao Symbol
     * Mode 819: Tao symbol visualization
     */
    render819TaoSymbol(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 820: Bagua
     * Mode 820: Bagua visualization
     */
    render820Bagua(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 821: I Ching Hexagram
     * Mode 821: I ching hexagram visualization
     */
    render821IChingHexagram(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 822: Trigram
     * Mode 822: Trigram visualization
     */
    render822Trigram(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 823: Medicine Wheel
     * Mode 823: Medicine wheel visualization
     */
    render823MedicineWheel(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 824: Dreamcatcher
     * Mode 824: Dreamcatcher visualization
     */
    render824Dreamcatcher(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 825: Totem
     * Mode 825: Totem visualization
     */
    render825Totem(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 826: Spirit Animal
     * Mode 826: Spirit animal visualization
     */
    render826SpiritAnimal(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 827: Shamanic Journey
     * Mode 827: Shamanic journey visualization
     */
    render827ShamanicJourney(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 828: Ayahuasca Vision
     * Mode 828: Ayahuasca vision visualization
     */
    render828AyahuascaVision(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 829: Dmt Realm
     * Mode 829: Dmt realm visualization
     */
    render829DmtRealm(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 830: Astral Projection
     * Mode 830: Astral projection visualization
     */
    render830AstralProjection(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 831: Out Of Body Experience
     * Mode 831: Out of body experience visualization
     */
    render831OutOfBodyExperience(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 832: Near Death Experience
     * Mode 832: Near death experience visualization
     */
    render832NearDeathExperience(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 833: Tunnel Of Light
     * Mode 833: Tunnel of light visualization
     */
    render833TunnelOfLight(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 834: Life Review
     * Mode 834: Life review visualization
     */
    render834LifeReview(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 835: Soul Retrieval
     * Mode 835: Soul retrieval visualization
     */
    render835SoulRetrieval(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 836: Past Life Regression
     * Mode 836: Past life regression visualization
     */
    render836PastLifeRegression(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 837: Akashic Records
     * Mode 837: Akashic records visualization
     */
    render837AkashicRecords(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 838: Collective Unconscious
     * Mode 838: Collective unconscious visualization
     */
    render838CollectiveUnconscious(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 839: Archetypal Realm
     * Mode 839: Archetypal realm visualization
     */
    render839ArchetypalRealm(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 840: Synchronicity
     * Mode 840: Synchronicity visualization
     */
    render840Synchronicity(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 841: Meaningful Coincidence
     * Mode 841: Meaningful coincidence visualization
     */
    render841MeaningfulCoincidence(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 842: Serendipity
     * Mode 842: Serendipity visualization
     */
    render842Serendipity(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 843: Providence
     * Mode 843: Providence visualization
     */
    render843Providence(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 844: Fate
     * Mode 844: Fate visualization
     */
    render844Fate(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 845: Destiny
     * Mode 845: Destiny visualization
     */
    render845Destiny(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 846: Karma
     * Mode 846: Karma visualization
     */
    render846Karma(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 847: Dharma
     * Mode 847: Dharma visualization
     */
    render847Dharma(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 848: Samsara
     * Mode 848: Samsara visualization
     */
    render848Samsara(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 849: Nirvana
     * Mode 849: Nirvana visualization
     */
    render849Nirvana(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 850: Enlightenment
     * Mode 850: Enlightenment visualization
     */
    render850Enlightenment(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 851: Samadhi
     * Mode 851: Samadhi visualization
     */
    render851Samadhi(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 852: Satori
     * Mode 852: Satori visualization
     */
    render852Satori(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 853: Kensho
     * Mode 853: Kensho visualization
     */
    render853Kensho(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 854: Moksha
     * Mode 854: Moksha visualization
     */
    render854Moksha(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 855: Liberation
     * Mode 855: Liberation visualization
     */
    render855Liberation(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 856: Self Realization
     * Mode 856: Self realization visualization
     */
    render856SelfRealization(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 857: God Consciousness
     * Mode 857: God consciousness visualization
     */
    render857GodConsciousness(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 858: Cosmic Consciousness
     * Mode 858: Cosmic consciousness visualization
     */
    render858CosmicConsciousness(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 859: Unity Consciousness
     * Mode 859: Unity consciousness visualization
     */
    render859UnityConsciousness(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 860: Non Dual Awareness
     * Mode 860: Non-dual awareness visualization
     */
    render860NonDualAwareness(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 861: Witness Consciousness
     * Mode 861: Witness consciousness visualization
     */
    render861WitnessConsciousness(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 862: Pure Awareness
     * Mode 862: Pure awareness visualization
     */
    render862PureAwareness(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 863: Presence
     * Mode 863: Presence visualization
     */
    render863Presence(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 864: Now Moment
     * Mode 864: Now moment visualization
     */
    render864NowMoment(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 865: Eternal Present
     * Mode 865: Eternal present visualization
     */
    render865EternalPresent(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 866: Timeless Being
     * Mode 866: Timeless being visualization
     */
    render866TimelessBeing(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 867: Infinite Space
     * Mode 867: Infinite space visualization
     */
    render867InfiniteSpace(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 868: Boundless Compassion
     * Mode 868: Boundless compassion visualization
     */
    render868BoundlessCompassion(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 869: Unconditional Love
     * Mode 869: Unconditional love visualization
     */
    render869UnconditionalLove(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 870: Divine Grace
     * Mode 870: Divine grace visualization
     */
    render870DivineGrace(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 871: Holy Spirit
     * Mode 871: Holy spirit visualization
     */
    render871HolySpirit(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 872: Shekinah
     * Mode 872: Shekinah visualization
     */
    render872Shekinah(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 873: Divine Feminine
     * Mode 873: Divine feminine visualization
     */
    render873DivineFeminine(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 874: Goddess Energy
     * Mode 874: Goddess energy visualization
     */
    render874GoddessEnergy(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 875: Sacred Masculine
     * Mode 875: Sacred masculine visualization
     */
    render875SacredMasculine(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 876: Hieros Gamos
     * Mode 876: Hieros gamos visualization
     */
    render876HierosGamos(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 877: Alchemical Wedding
     * Mode 877: Alchemical wedding visualization
     */
    render877AlchemicalWedding(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 878: Coniunctio
     * Mode 878: Coniunctio visualization
     */
    render878Coniunctio(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 879: Philosopher Stone
     * Mode 879: Philosopher stone visualization
     */
    render879PhilosopherStone(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 880: Prima Materia
     * Mode 880: Prima materia visualization
     */
    render880PrimaMateria(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 881: Nigredo
     * Mode 881: Nigredo visualization
     */
    render881Nigredo(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 882: Albedo
     * Mode 882: Albedo visualization
     */
    render882Albedo(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 883: Citrinitas
     * Mode 883: Citrinitas visualization
     */
    render883Citrinitas(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 884: Rubedo
     * Mode 884: Rubedo visualization
     */
    render884Rubedo(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 885: Seven Stages
     * Mode 885: Seven stages visualization
     */
    render885SevenStages(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 886: Hermetic Principle
     * Mode 886: Hermetic principle visualization
     */
    render886HermeticPrinciple(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 887: As Above So Below
     * Mode 887: As above so below visualization
     */
    render887AsAboveSoBelow(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 888: Microcosm Macrocosm
     * Mode 888: Microcosm macrocosm visualization
     */
    render888MicrocosmMacrocosm(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 889: Correspondence
     * Mode 889: Correspondence visualization
     */
    render889Correspondence(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 890: Vibration
     * Mode 890: Vibration visualization
     */
    render890Vibration(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 891: Polarity
     * Mode 891: Polarity visualization
     */
    render891Polarity(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 892: Rhythm
     * Mode 892: Rhythm visualization
     */
    render892Rhythm(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 893: Cause And Effect
     * Mode 893: Cause and effect visualization
     */
    render893CauseAndEffect(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 894: Gender Principle
     * Mode 894: Gender principle visualization
     */
    render894GenderPrinciple(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 895: Mentalism
     * Mode 895: Mentalism visualization
     */
    render895Mentalism(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 896: Emerald Tablet
     * Mode 896: Emerald tablet visualization
     */
    render896EmeraldTablet(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 897: Kybalion
     * Mode 897: Kybalion visualization
     */
    render897Kybalion(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 898: Corpus Hermeticum
     * Mode 898: Corpus hermeticum visualization
     */
    render898CorpusHermeticum(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 899: Gnostic Vision
     * Mode 899: Gnostic vision visualization
     */
    render899GnosticVision(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 900: Sophia
     * Mode 900: Sophia visualization
     */
    render900Sophia(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 901: Spiral Vortex
     * Mode 901: Spiral vortex visualization
     */
    render901SpiralVortex(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const brightness = Math.floor(100 + mag * 155);

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 902: Concentric Circles
     * Mode 902: Concentric circles visualization
     */
    render902ConcentricCircles(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 903: Expanding Rings
     * Mode 903: Expanding rings visualization
     */
    render903ExpandingRings(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 904: Contracting Circles
     * Mode 904: Contracting circles visualization
     */
    render904ContractingCircles(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (1 - i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 905: Pulsing Orb
     * Mode 905: Pulsing orb visualization
     */
    render905PulsingOrb(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 906: Oscillating Wave
     * Mode 906: Oscillating wave visualization
     */
    render906OscillatingWave(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 907: Pendulum Swing
     * Mode 907: Pendulum swing visualization
     */
    render907PendulumSwing(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numPendulums = Math.floor(complexity * 10);
        for (let i = 0; i < numPendulums; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numPendulums);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 908: Hypnotic Swirl
     * Mode 908: Hypnotic swirl visualization
     */
    render908HypnoticSwirl(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numSwirls = Math.floor(complexity * 10);
        for (let i = 0; i < numSwirls; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numSwirls);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 909: Tunnel Zoom
     * Mode 909: Tunnel zoom visualization
     */
    render909TunnelZoom(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numCircles = Math.floor(complexity * 10);
        for (let i = 0; i < numCircles; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numCircles);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 910: Perspective Shift
     * Mode 910: Perspective shift visualization
     */
    render910PerspectiveShift(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 911: Rotating Polygon
     * Mode 911: Rotating polygon visualization
     */
    render911RotatingPolygon(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 912: Morphing Shape
     * Mode 912: Morphing shape visualization
     */
    render912MorphingShape(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 913: Flowing Liquid
     * Mode 913: Flowing liquid visualization
     */
    render913FlowingLiquid(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 914: Ripple Effect
     * Mode 914: Ripple effect visualization
     */
    render914RippleEffect(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 915: Interference Pattern
     * Mode 915: Interference pattern visualization
     */
    render915InterferencePattern(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 916: Moire Effect
     * Mode 916: Moire effect visualization
     */
    render916MoireEffect(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 917: Strobing Light
     * Mode 917: Strobing light visualization
     */
    render917StrobingLight(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 918: Flickering
     * Mode 918: Flickering visualization
     */
    render918Flickering(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 919: Pulsating
     * Mode 919: Pulsating visualization
     */
    render919Pulsating(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 920: Breathing Pattern
     * Mode 920: Breathing pattern visualization
     */
    render920BreathingPattern(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 921: Expansion Contraction
     * Mode 921: Expansion contraction visualization
     */
    render921ExpansionContraction(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 922: Growth Decay
     * Mode 922: Growth decay visualization
     */
    render922GrowthDecay(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 923: Birth Death
     * Mode 923: Birth death visualization
     */
    render923BirthDeath(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 924: Ebb Flow
     * Mode 924: Ebb flow visualization
     */
    render924EbbFlow(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 925: Inhale Exhale
     * Mode 925: Inhale exhale visualization
     */
    render925InhaleExhale(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 926: Systole Diastole
     * Mode 926: Systole diastole visualization
     */
    render926SystoleDiastole(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 927: Tension Release
     * Mode 927: Tension release visualization
     */
    render927TensionRelease(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 928: Charge Discharge
     * Mode 928: Charge discharge visualization
     */
    render928ChargeDischarge(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 929: Loading Unloading
     * Mode 929: Loading unloading visualization
     */
    render929LoadingUnloading(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 930: Compression Rarefaction
     * Mode 930: Compression rarefaction visualization
     */
    render930CompressionRarefaction(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 931: Dense Sparse
     * Mode 931: Dense sparse visualization
     */
    render931DenseSparse(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 932: Thick Thin
     * Mode 932: Thick thin visualization
     */
    render932ThickThin(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 933: Heavy Light
     * Mode 933: Heavy light visualization
     */
    render933HeavyLight(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 934: Dark Bright
     * Mode 934: Dark bright visualization
     */
    render934DarkBright(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 935: Shadow Highlight
     * Mode 935: Shadow highlight visualization
     */
    render935ShadowHighlight(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 936: Positive Negative
     * Mode 936: Positive negative visualization
     */
    render936PositiveNegative(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 937: Convex Concave
     * Mode 937: Convex concave visualization
     */
    render937ConvexConcave(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 938: Inside Outside
     * Mode 938: Inside outside visualization
     */
    render938InsideOutside(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 939: Figure Ground
     * Mode 939: Figure ground visualization
     */
    render939FigureGround(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 940: Foreground Background
     * Mode 940: Foreground background visualization
     */
    render940ForegroundBackground(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 941: Solid Void
     * Mode 941: Solid void visualization
     */
    render941SolidVoid(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 942: Matter Antimatter
     * Mode 942: Matter antimatter visualization
     */
    render942MatterAntimatter(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 943: Particle Wave
     * Mode 943: Particle wave visualization
     */
    render943ParticleWave(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 944: Discrete Continuous
     * Mode 944: Discrete continuous visualization
     */
    render944DiscreteContinuous(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 945: Quantized Smooth
     * Mode 945: Quantized smooth visualization
     */
    render945QuantizedSmooth(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 946: Digital Analog
     * Mode 946: Digital analog visualization
     */
    render946DigitalAnalog(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 947: Binary Fluid
     * Mode 947: Binary fluid visualization
     */
    render947BinaryFluid(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 948: On Off
     * Mode 948: On off visualization
     */
    render948OnOff(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 949: Yes No
     * Mode 949: Yes no visualization
     */
    render949YesNo(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 950: Zero One
     * Mode 950: Zero one visualization
     */
    render950ZeroOne(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 951: Presence Absence
     * Mode 951: Presence absence visualization
     */
    render951PresenceAbsence(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 952: Being Nothingness
     * Mode 952: Being nothingness visualization
     */
    render952BeingNothingness(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 953: Existence Void
     * Mode 953: Existence void visualization
     */
    render953ExistenceVoid(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 954: Form Emptiness
     * Mode 954: Form emptiness visualization
     */
    render954FormEmptiness(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 955: Substance Essence
     * Mode 955: Substance essence visualization
     */
    render955SubstanceEssence(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 956: Appearance Reality
     * Mode 956: Appearance reality visualization
     */
    render956AppearanceReality(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 957: Illusion Truth
     * Mode 957: Illusion truth visualization
     */
    render957IllusionTruth(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 958: Maya Brahman
     * Mode 958: Maya brahman visualization
     */
    render958MayaBrahman(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 959: Phenomena Noumena
     * Mode 959: Phenomena noumena visualization
     */
    render959PhenomenaNoumena(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 960: Relative Absolute
     * Mode 960: Relative absolute visualization
     */
    render960RelativeAbsolute(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 961: Changing Unchanging
     * Mode 961: Changing unchanging visualization
     */
    render961ChangingUnchanging(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 962: Temporal Eternal
     * Mode 962: Temporal eternal visualization
     */
    render962TemporalEternal(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 963: Finite Infinite
     * Mode 963: Finite infinite visualization
     */
    render963FiniteInfinite(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 964: Limited Boundless
     * Mode 964: Limited boundless visualization
     */
    render964LimitedBoundless(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 965: Mortal Immortal
     * Mode 965: Mortal immortal visualization
     */
    render965MortalImmortal(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 966: Perishable Imperishable
     * Mode 966: Perishable imperishable visualization
     */
    render966PerishableImperishable(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 967: Transient Permanent
     * Mode 967: Transient permanent visualization
     */
    render967TransientPermanent(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 968: Fleeting Lasting
     * Mode 968: Fleeting lasting visualization
     */
    render968FleetingLasting(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 969: Ephemeral Enduring
     * Mode 969: Ephemeral enduring visualization
     */
    render969EphemeralEnduring(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 970: Momentary Timeless
     * Mode 970: Momentary timeless visualization
     */
    render970MomentaryTimeless(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 971: Local Universal
     * Mode 971: Local universal visualization
     */
    render971LocalUniversal(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 972: Particular General
     * Mode 972: Particular general visualization
     */
    render972ParticularGeneral(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 973: Specific Generic
     * Mode 973: Specific generic visualization
     */
    render973SpecificGeneric(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 974: Unique Common
     * Mode 974: Unique common visualization
     */
    render974UniqueCommon(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 975: Individual Collective
     * Mode 975: Individual collective visualization
     */
    render975IndividualCollective(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 976: One Many
     * Mode 976: One many visualization
     */
    render976OneMany(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 977: Unity Multiplicity
     * Mode 977: Unity multiplicity visualization
     */
    render977UnityMultiplicity(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 978: Simple Complex
     * Mode 978: Simple complex visualization
     */
    render978SimpleComplex(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 979: Elementary Composite
     * Mode 979: Elementary composite visualization
     */
    render979ElementaryComposite(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 980: Atomic Molecular
     * Mode 980: Atomic molecular visualization
     */
    render980AtomicMolecular(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 981: Fundamental Derived
     * Mode 981: Fundamental derived visualization
     */
    render981FundamentalDerived(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 982: Primary Secondary
     * Mode 982: Primary secondary visualization
     */
    render982PrimarySecondary(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 983: Essential Accidental
     * Mode 983: Essential accidental visualization
     */
    render983EssentialAccidental(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 984: Necessary Contingent
     * Mode 984: Necessary contingent visualization
     */
    render984NecessaryContingent(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 985: A Priori A Posteriori
     * Mode 985: A priori a posteriori visualization
     */
    render985APrioriAPosteriori(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 986: Analytic Synthetic
     * Mode 986: Analytic synthetic visualization
     */
    render986AnalyticSynthetic(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 987: Deductive Inductive
     * Mode 987: Deductive inductive visualization
     */
    render987DeductiveInductive(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 988: Logical Empirical
     * Mode 988: Logical empirical visualization
     */
    render988LogicalEmpirical(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 989: Rational Experiential
     * Mode 989: Rational experiential visualization
     */
    render989RationalExperiential(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 990: Abstract Concrete
     * Mode 990: Abstract concrete visualization
     */
    render990AbstractConcrete(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 991: Theoretical Practical
     * Mode 991: Theoretical practical visualization
     */
    render991TheoreticalPractical(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 992: Ideal Real
     * Mode 992: Ideal real visualization
     */
    render992IdealReal(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 993: Conceptual Actual
     * Mode 993: Conceptual actual visualization
     */
    render993ConceptualActual(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 994: Possible Necessary
     * Mode 994: Possible necessary visualization
     */
    render994PossibleNecessary(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 995: Potential Actual
     * Mode 995: Potential actual visualization
     */
    render995PotentialActual(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 996: Virtual Real
     * Mode 996: Virtual real visualization
     */
    render996VirtualReal(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 997: Simulated Genuine
     * Mode 997: Simulated genuine visualization
     */
    render997SimulatedGenuine(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 998: Artificial Natural
     * Mode 998: Artificial natural visualization
     */
    render998ArtificialNatural(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 999: Synthetic Organic
     * Mode 999: Synthetic organic visualization
     */
    render999SyntheticOrganic(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 1000: Mechanical Living
     * Mode 1000: Mechanical living visualization
     */
    render1000MechanicalLiving(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Helper method to adjust color brightness
     */
    adjustBrightness(color, amount) {
        // Extract RGB values from color string
        const match = color.match(/\d+/g);
        if (!match || match.length < 3) return color;

        let [r, g, b] = match.map(Number);

        // Adjust brightness
        r = Math.max(0, Math.min(255, r + amount));
        g = Math.max(0, Math.min(255, g + amount));
        b = Math.max(0, Math.min(255, b + amount));

        return `rgb(${r}, ${g}, ${b})`;
    }


    // ========================================
    // GENERATED MISSING RENDER METHODS
    // ========================================

    /**
     * Mode 107: DnaHelix
     * Dna Helix visualization with configurable parameters
     */
    render107DnaHelix(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 108: FractalBloom
     * Fractal Bloom visualization with configurable parameters
     */
    render108FractalBloom(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 109: CircuitBoard
     * Circuit Board visualization with configurable parameters
     */
    render109CircuitBoard(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 110: QuantumField
     * Quantum Field visualization with configurable parameters
     */
    render110QuantumField(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 111: OrigamiUnfold
     * Origami Unfold visualization with configurable parameters
     */
    render111OrigamiUnfold(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 112: GalaxySpiral
     * Galaxy Spiral visualization with configurable parameters
     */
    render112GalaxySpiral(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 113: RubberBands
     * Rubber Bands visualization with configurable parameters
     */
    render113RubberBands(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 114: InkDiffusion
     * Ink Diffusion visualization with configurable parameters
     */
    render114InkDiffusion(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 115: GeometricKaleidoscope
     * Geometric Kaleidoscope visualization with configurable parameters
     */
    render115GeometricKaleidoscope(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 157: WaterlineOscilloscope
     * Waterline Oscilloscope visualization with configurable parameters
     */
    render157WaterlineOscilloscope(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 174: InkSplatterScope
     * Ink Splatter Scope visualization with configurable parameters
     */
    render174InkSplatterScope(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 201: MeteorNet
     * Meteor Net visualization with configurable parameters
     */
    render201Meteornet(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 202: DeepSpaceGardenHose
     * Deep Space Garden Hose visualization with configurable parameters
     */
    render202DeepSpaceGardenHose(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 203: HorizonMonoliths
     * Horizon Monoliths visualization with configurable parameters
     */
    render203HorizonMonoliths(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 204: GravitySlingshotTrails
     * Gravity Slingshot Trails visualization with configurable parameters
     */
    render204GravitySlingshotTrails(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 205: SolarFlareNotches
     * Solar Flare Notches visualization with configurable parameters
     */
    render205SolarFlareNotches(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 206: TesseractWindow
     * Tesseract Window visualization with configurable parameters
     */
    render206TesseractWindow(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 207: InterstellarPostcards
     * Interstellar Postcards visualization with configurable parameters
     */
    render207InterstellarPostcards(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 208: CosmicBraille
     * Cosmic Braille visualization with configurable parameters
     */
    render208CosmicBraille(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 209: StellarHarpoon
     * Stellar Harpoon visualization with configurable parameters
     */
    render209StellarHarpoon(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 210: GalaxyTickerTape
     * Galaxy Ticker Tape visualization with configurable parameters
     */
    render210GalaxyTickerTape(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 211: AntimatterChess
     * Antimatter Chess visualization with configurable parameters
     */
    render211AntimatterChess(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 212: StarNurseryConveyor
     * Star Nursery Conveyor visualization with configurable parameters
     */
    render212StarNurseryConveyor(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 213: MagnetarLines
     * Magnetar Lines visualization with configurable parameters
     */
    render213MagnetarLines(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 214: ZeroKelvinDiamonds
     * Zero Kelvin Diamonds visualization with configurable parameters
     */
    render214ZeroKelvinDiamonds(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 215: OrbitalTimeGarden
     * Orbital Time Garden visualization with configurable parameters
     */
    render215OrbitalTimeGarden(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 216: SubspaceRibbonPrinter
     * Subspace Ribbon Printer visualization with configurable parameters
     */
    render216SubspaceRibbonPrinter(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 217: DarkMatterDrizzle
     * Dark Matter Drizzle visualization with configurable parameters
     */
    render217DarkMatterDrizzle(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 218: MeteorChoirCones
     * Meteor Choir Cones visualization with configurable parameters
     */
    render218MeteorChoirCones(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 219: FoldedGalaxyMap
     * Folded Galaxy Map visualization with configurable parameters
     */
    render219FoldedGalaxyMap(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 220: IonThrusterPlume
     * Ion Thruster Plume visualization with configurable parameters
     */
    render220IonThrusterPlume(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 221: CosmicDominoes
     * Cosmic Dominoes visualization with configurable parameters
     */
    render221CosmicDominoes(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 222: SpacesuitHud
     * Spacesuit Hud visualization with configurable parameters
     */
    render222SpacesuitHud(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 223: PulsarBarcodeBeam
     * Pulsar Barcode Beam visualization with configurable parameters
     */
    render223PulsarBarcodeBeam(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 224: AstroTerrarium
     * Astro Terrarium visualization with configurable parameters
     */
    render224AstroTerrarium(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 225: MicrometeorSparkCurtain
     * Micrometeor Spark Curtain visualization with configurable parameters
     */
    render225MicrometeorSparkCurtain(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 276: QuantumLattice
     * Quantum Lattice visualization with configurable parameters
     */
    render276QuantumLattice(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 277: PrismRays
     * Prism Rays visualization with configurable parameters
     */
    render277PrismRays(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 278: LiquidNitrogen
     * Liquid Nitrogen visualization with configurable parameters
     */
    render278LiquidNitrogen(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 279: SilkRoadCaravan
     * Silk Road Caravan visualization with configurable parameters
     */
    render279SilkRoadCaravan(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 280: SteampunkGears
     * Steampunk Gears visualization with configurable parameters
     */
    render280SteampunkGears(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 281: DragonScales
     * Dragon Scales visualization with configurable parameters
     */
    render281DragonScales(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 282: TimeDilationGrid
     * Time Dilation Grid visualization with configurable parameters
     */
    render282TimeDilationGrid(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 283: FiberBundle
     * Fiber Bundle visualization with configurable parameters
     */
    render283FiberBundle(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 284: MothWingShimmer
     * Moth Wing Shimmer visualization with configurable parameters
     */
    render284MothWingShimmer(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 285: CathedralRose
     * Cathedral Rose visualization with configurable parameters
     */
    render285CathedralRose(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 286: NeonVeinsPulse
     * Neon Veins Pulse visualization with configurable parameters
     */
    render286NeonVeinsPulse(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 287: GlacialCrack
     * Glacial Crack visualization with configurable parameters
     */
    render287GlacialCrack(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 288: QuantumDots
     * Quantum Dots visualization with configurable parameters
     */
    render288QuantumDots(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 289: OrigamiCraneFlight
     * Origami Crane Flight visualization with configurable parameters
     */
    render289OrigamiCraneFlight(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 290: MagmaChamber
     * Magma Chamber visualization with configurable parameters
     */
    render290MagmaChamber(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 291: SpiderWebDew
     * Spider Web Dew visualization with configurable parameters
     */
    render291SpiderWebDew(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 292: NebulaBirth
     * Nebula Birth visualization with configurable parameters
     */
    render292NebulaBirth(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 293: CircuitBoardLive
     * Circuit Board Live visualization with configurable parameters
     */
    render293CircuitBoardLive(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 294: BioluminescentTide
     * Bioluminescent Tide visualization with configurable parameters
     */
    render294BioluminescentTide(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 295: TesseractProjection
     * Tesseract Projection visualization with configurable parameters
     */
    render295TesseractProjection(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 296: FrostCrystalGrowth
     * Frost Crystal Growth visualization with configurable parameters
     */
    render296FrostCrystalGrowth(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 297: SoundWaveInterference
     * Sound Wave Interference visualization with configurable parameters
     */
    render297SoundWaveInterference(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 298: HolographicFracture
     * Holographic Fracture visualization with configurable parameters
     */
    render298HolographicFracture(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 299: PlasmaBallArc
     * Plasma Ball Arc visualization with configurable parameters
     */
    render299PlasmaBallArc(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 300: EternalFlameDance
     * Eternal Flame Dance visualization with configurable parameters
     */
    render300EternalFlameDance(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 400: WaterLilyReflection
     * Water Lily Reflection visualization with configurable parameters
     */
    render400WaterLilyReflection(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 401: AtomModel
     * Atom Model visualization with configurable parameters
     */
    render401AtomModel(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 402: DoubleHelix
     * Double Helix visualization with configurable parameters
     */
    render402DoubleHelix(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 403: MagneticField
     * Magnetic Field visualization with configurable parameters
     */
    render403MagneticField(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 404: WaveInterference
     * Wave Interference visualization with configurable parameters
     */
    render404WaveInterference(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 406: CrystalLattice
     * Crystal Lattice visualization with configurable parameters
     */
    render406CrystalLattice(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 407: ElectromagneticWave
     * Electromagnetic Wave visualization with configurable parameters
     */
    render407ElectromagneticWave(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 408: QuantumTunneling
     * Quantum Tunneling visualization with configurable parameters
     */
    render408QuantumTunneling(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 409: FissionReaction
     * Fission Reaction visualization with configurable parameters
     */
    render409FissionReaction(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 410: DopplerEffect
     * Doppler Effect visualization with configurable parameters
     */
    render410DopplerEffect(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 411: GravityWell
     * Gravity Well visualization with configurable parameters
     */
    render411GravityWell(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 412: PrismSpectrum
     * Prism Spectrum visualization with configurable parameters
     */
    render412PrismSpectrum(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 413: MolecularBonds
     * Molecular Bonds visualization with configurable parameters
     */
    render413MolecularBonds(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 414: StandingWave
     * Standing Wave visualization with configurable parameters
     */
    render414StandingWave(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 415: BrownianMotion
     * Brownian Motion visualization with configurable parameters
     */
    render415BrownianMotion(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 416: TeslaCoil
     * Tesla Coil visualization with configurable parameters
     */
    render416TeslaCoil(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 417: PhaseTransition
     * Phase Transition visualization with configurable parameters
     */
    render417PhaseTransition(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 418: Superconductor
     * Superconductor visualization with configurable parameters
     */
    render418Superconductor(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 419: NeuronFiring
     * Neuron Firing visualization with configurable parameters
     */
    render419NeuronFiring(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 420: ResonanceModes
     * Resonance Modes visualization with configurable parameters
     */
    render420ResonanceModes(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 421: FractalDiffusion
     * Fractal Diffusion visualization with configurable parameters
     */
    render421FractalDiffusion(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 422: PlasmaBall
     * Plasma Ball visualization with configurable parameters
     */
    render422PlasmaBall(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 423: CoriolisEffect
     * Coriolis Effect visualization with configurable parameters
     */
    render423CoriolisEffect(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 424: PhotoelectricEffect
     * Photoelectric Effect visualization with configurable parameters
     */
    render424PhotoelectricEffect(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 425: LorenzAttractor
     * Lorenz Attractor visualization with configurable parameters
     */
    render425LorenzAttractor(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 426: SpinPrecession
     * Spin Precession visualization with configurable parameters
     */
    render426SpinPrecession(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 427: ComptonScattering
     * Compton Scattering visualization with configurable parameters
     */
    render427ComptonScattering(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 428: Ferrofluid
     * Ferrofluid visualization with configurable parameters
     */
    render428Ferrofluid(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 429: Sonoluminescence
     * Sonoluminescence visualization with configurable parameters
     */
    render429Sonoluminescence(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 430: CherenkovRadiation
     * Cherenkov Radiation visualization with configurable parameters
     */
    render430CherenkovRadiation(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 431: HallEffect
     * Hall Effect visualization with configurable parameters
     */
    render431HallEffect(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 432: Cymatics
     * Cymatics visualization with configurable parameters
     */
    render432Cymatics(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 433: KleinBottle
     * Klein Bottle visualization with configurable parameters
     */
    render433KleinBottle(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 434: RamanScattering
     * Raman Scattering visualization with configurable parameters
     */
    render434RamanScattering(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 435: VortexShedding
     * Vortex Shedding visualization with configurable parameters
     */
    render435VortexShedding(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 436: Polarization
     * Polarization visualization with configurable parameters
     */
    render436Polarization(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 437: HiggsField
     * Higgs Field visualization with configurable parameters
     */
    render437HiggsField(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 438: BoseEinstein
     * Bose Einstein visualization with configurable parameters
     */
    render438BoseEinstein(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 439: SchrodingerCat
     * Schrodinger Cat visualization with configurable parameters
     */
    render439SchrodingerCat(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 440: StringVibration
     * String Vibration visualization with configurable parameters
     */
    render440StringVibration(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 441: ElectronCloud
     * Electron Cloud visualization with configurable parameters
     */
    render441ElectronCloud(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 442: Thermoelectric
     * Thermoelectric visualization with configurable parameters
     */
    render442Thermoelectric(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 443: PhotonEntanglement
     * Photon Entanglement visualization with configurable parameters
     */
    render443PhotonEntanglement(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 444: Superfluidity
     * Superfluidity visualization with configurable parameters
     */
    render444Superfluidity(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 445: Piezoelectric
     * Piezoelectric visualization with configurable parameters
     */
    render445Piezoelectric(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 446: ZeemanEffect
     * Zeeman Effect visualization with configurable parameters
     */
    render446ZeemanEffect(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 447: CyclotronMotion
     * Cyclotron Motion visualization with configurable parameters
     */
    render447CyclotronMotion(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 448: FusionReactor
     * Fusion Reactor visualization with configurable parameters
     */
    render448FusionReactor(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 449: Antimatter
     * Antimatter visualization with configurable parameters
     */
    render449Antimatter(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 450: HawkingRadiation
     * Hawking Radiation visualization with configurable parameters
     */
    render450HawkingRadiation(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 451: HeisenbergUncertainty
     * Heisenberg Uncertainty visualization with configurable parameters
     */
    render451HeisenbergUncertainty(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 453: LaserCavity
     * Laser Cavity visualization with configurable parameters
     */
    render453LaserCavity(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 454: DielectricBreakdown
     * Dielectric Breakdown visualization with configurable parameters
     */
    render454DielectricBreakdown(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 455: CasimirEffect
     * Casimir Effect visualization with configurable parameters
     */
    render455CasimirEffect(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 456: Sonochemistry
     * Sonochemistry visualization with configurable parameters
     */
    render456Sonochemistry(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 457: PhononPropagation
     * Phonon Propagation visualization with configurable parameters
     */
    render457PhononPropagation(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 458: PairProduction
     * Pair Production visualization with configurable parameters
     */
    render458PairProduction(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 459: StefanBoltzmann
     * Stefan Boltzmann visualization with configurable parameters
     */
    render459StefanBoltzmann(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 460: EddyCurrents
     * Eddy Currents visualization with configurable parameters
     */
    render460EddyCurrents(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 461: WavefunctionCollapse
     * Wavefunction Collapse visualization with configurable parameters
     */
    render461WavefunctionCollapse(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 462: QedFeynman
     * Qed Feynman visualization with configurable parameters
     */
    render462QedFeynman(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 463: Holography
     * Holography visualization with configurable parameters
     */
    render463Holography(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 464: Metamaterial
     * Metamaterial visualization with configurable parameters
     */
    render464Metamaterial(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 465: Photodiode
     * Photodiode visualization with configurable parameters
     */
    render465Photodiode(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 466: Bremsstrahlung
     * Bremsstrahlung visualization with configurable parameters
     */
    render466Bremsstrahlung(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 467: Optogenetics
     * Optogenetics visualization with configurable parameters
     */
    render467Optogenetics(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 468: TopologicalInsulator
     * Topological Insulator visualization with configurable parameters
     */
    render468TopologicalInsulator(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 469: NernstEquation
     * Nernst Equation visualization with configurable parameters
     */
    render469NernstEquation(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 470: MriPrecession
     * Mri Precession visualization with configurable parameters
     */
    render470MriPrecession(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 471: JosephsonJunction
     * Josephson Junction visualization with configurable parameters
     */
    render471JosephsonJunction(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 472: LiquidCrystal
     * Liquid Crystal visualization with configurable parameters
     */
    render472LiquidCrystal(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 473: RydbergAtoms
     * Rydberg Atoms visualization with configurable parameters
     */
    render473RydbergAtoms(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 474: CavityQed
     * Cavity Qed visualization with configurable parameters
     */
    render474CavityQed(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 475: QuantumDots
     * Quantum Dots visualization with configurable parameters
     */
    render475QuantumDots(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 476: SolitonWave
     * Soliton Wave visualization with configurable parameters
     */
    render476SolitonWave(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 477: AcousticLevitation
     * Acoustic Levitation visualization with configurable parameters
     */
    render477AcousticLevitation(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 478: MosfetChannel
     * Mosfet Channel visualization with configurable parameters
     */
    render478MosfetChannel(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 479: Spintronics
     * Spintronics visualization with configurable parameters
     */
    render479Spintronics(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 480: Electrochemistry
     * Electrochemistry visualization with configurable parameters
     */
    render480Electrochemistry(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 481: LangmuirWave
     * Langmuir Wave visualization with configurable parameters
     */
    render481LangmuirWave(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 482: BlochSphere
     * Bloch Sphere visualization with configurable parameters
     */
    render482BlochSphere(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 483: CurieTemperature
     * Curie Temperature visualization with configurable parameters
     */
    render483CurieTemperature(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 484: DysonSphere
     * Dyson Sphere visualization with configurable parameters
     */
    render484DysonSphere(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 485: GrapheneLattice
     * Graphene Lattice visualization with configurable parameters
     */
    render485GrapheneLattice(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 486: Memristor
     * Memristor visualization with configurable parameters
     */
    render486Memristor(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 487: QuantumHall
     * Quantum Hall visualization with configurable parameters
     */
    render487QuantumHall(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 488: Optomechanics
     * Optomechanics visualization with configurable parameters
     */
    render488Optomechanics(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 489: Exciton
     * Exciton visualization with configurable parameters
     */
    render489Exciton(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 490: PhotonicCrystal
     * Photonic Crystal visualization with configurable parameters
     */
    render490PhotonicCrystal(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 491: Skyrmion
     * Skyrmion visualization with configurable parameters
     */
    render491Skyrmion(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 492: MottInsulator
     * Mott Insulator visualization with configurable parameters
     */
    render492MottInsulator(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 493: Squeezing
     * Squeezing visualization with configurable parameters
     */
    render493Squeezing(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 494: AndreevReflection
     * Andreev Reflection visualization with configurable parameters
     */
    render494AndreevReflection(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 495: CasimirPolder
     * Casimir Polder visualization with configurable parameters
     */
    render495CasimirPolder(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 496: FanoResonance
     * Fano Resonance visualization with configurable parameters
     */
    render496FanoResonance(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 497: QuantumZeno
     * Quantum Zeno visualization with configurable parameters
     */
    render497QuantumZeno(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 498: RabiOscillation
     * Rabi Oscillation visualization with configurable parameters
     */
    render498RabiOscillation(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 499: AharonovBohm
     * Aharonov Bohm visualization with configurable parameters
     */
    render499AharonovBohm(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 500: BerryPhase
     * Berry Phase visualization with configurable parameters
     */
    render500BerryPhase(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 501: Impressionist
     * Impressionist visualization with configurable parameters
     */
    render501Impressionist(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 502: Cubist
     * Cubist visualization with configurable parameters
     */
    render502Cubist(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 503: Surreal
     * Surreal visualization with configurable parameters
     */
    render503Surreal(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 504: AbstractExpressionist
     * Abstract Expressionist visualization with configurable parameters
     */
    render504AbstractExpressionist(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 505: PopArt
     * Pop Art visualization with configurable parameters
     */
    render505PopArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 506: Minimalist
     * Minimalist visualization with configurable parameters
     */
    render506Minimalist(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 507: Pointillist
     * Pointillist visualization with configurable parameters
     */
    render507Pointillist(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 508: ArtDeco
     * Art Deco visualization with configurable parameters
     */
    render508ArtDeco(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 509: ArtNouveau
     * Art Nouveau visualization with configurable parameters
     */
    render509ArtNouveau(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 510: Bauhaus
     * Bauhaus visualization with configurable parameters
     */
    render510Bauhaus(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 511: Futurist
     * Futurist visualization with configurable parameters
     */
    render511Futurist(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 512: Dadaist
     * Dadaist visualization with configurable parameters
     */
    render512Dadaist(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 513: Expressionist
     * Expressionist visualization with configurable parameters
     */
    render513Expressionist(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 514: Fauvism
     * Fauvism visualization with configurable parameters
     */
    render514Fauvism(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 515: Constructivist
     * Constructivist visualization with configurable parameters
     */
    render515Constructivist(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 516: Suprematist
     * Suprematist visualization with configurable parameters
     */
    render516Suprematist(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 517: Vorticism
     * Vorticism visualization with configurable parameters
     */
    render517Vorticism(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 518: Orphism
     * Orphism visualization with configurable parameters
     */
    render518Orphism(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 519: Rayonism
     * Rayonism visualization with configurable parameters
     */
    render519Rayonism(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 520: Synchromism
     * Synchromism visualization with configurable parameters
     */
    render520Synchromism(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 521: Precisionism
     * Precisionism visualization with configurable parameters
     */
    render521Precisionism(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 522: Regionalism
     * Regionalism visualization with configurable parameters
     */
    render522Regionalism(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 523: SocialRealism
     * Social Realism visualization with configurable parameters
     */
    render523SocialRealism(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 524: NeoPlasticism
     * Neo Plasticism visualization with configurable parameters
     */
    render524NeoPlasticism(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 525: DeStijl
     * De Stijl visualization with configurable parameters
     */
    render525DeStijl(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 526: ColorField
     * Color Field visualization with configurable parameters
     */
    render526ColorField(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 527: HardEdge
     * Hard Edge visualization with configurable parameters
     */
    render527HardEdge(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 528: LyricalAbstraction
     * Lyrical Abstraction visualization with configurable parameters
     */
    render528LyricalAbstraction(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 529: Tachisme
     * Tachisme visualization with configurable parameters
     */
    render529Tachisme(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 530: ActionPainting
     * Action Painting visualization with configurable parameters
     */
    render530ActionPainting(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 531: StainPainting
     * Stain Painting visualization with configurable parameters
     */
    render531StainPainting(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 532: ShapedCanvas
     * Shaped Canvas visualization with configurable parameters
     */
    render532ShapedCanvas(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 533: Monochrome
     * Monochrome visualization with configurable parameters
     */
    render533Monochrome(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 534: KineticArt
     * Kinetic Art visualization with configurable parameters
     */
    render534KineticArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 535: OpArt
     * Op Art visualization with configurable parameters
     */
    render535OpArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 536: LightArt
     * Light Art visualization with configurable parameters
     */
    render536LightArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 537: LandArt
     * Land Art visualization with configurable parameters
     */
    render537LandArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 538: EarthArt
     * Earth Art visualization with configurable parameters
     */
    render538EarthArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 539: EnvironmentalArt
     * Environmental Art visualization with configurable parameters
     */
    render539EnvironmentalArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 540: InstallationArt
     * Installation Art visualization with configurable parameters
     */
    render540InstallationArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 541: VideoArt
     * Video Art visualization with configurable parameters
     */
    render541VideoArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 542: DigitalArt
     * Digital Art visualization with configurable parameters
     */
    render542DigitalArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 543: GlitchArt
     * Glitch Art visualization with configurable parameters
     */
    render543GlitchArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 544: PixelArt
     * Pixel Art visualization with configurable parameters
     */
    render544PixelArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 545: AsciiArt
     * Ascii Art visualization with configurable parameters
     */
    render545AsciiArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 546: VectorArt
     * Vector Art visualization with configurable parameters
     */
    render546VectorArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 547: FractalArt
     * Fractal Art visualization with configurable parameters
     */
    render547FractalArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 548: AlgorithmicArt
     * Algorithmic Art visualization with configurable parameters
     */
    render548AlgorithmicArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 549: GenerativeArt
     * Generative Art visualization with configurable parameters
     */
    render549GenerativeArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 550: DataArt
     * Data Art visualization with configurable parameters
     */
    render550DataArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 551: BioArt
     * Bio Art visualization with configurable parameters
     */
    render551BioArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 552: NetArt
     * Net Art visualization with configurable parameters
     */
    render552NetArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 553: SoftwareArt
     * Software Art visualization with configurable parameters
     */
    render553SoftwareArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 554: RoboticArt
     * Robotic Art visualization with configurable parameters
     */
    render554RoboticArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 555: InteractiveArt
     * Interactive Art visualization with configurable parameters
     */
    render555InteractiveArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 556: ProjectionMapping
     * Projection Mapping visualization with configurable parameters
     */
    render556ProjectionMapping(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 557: HolographicArt
     * Holographic Art visualization with configurable parameters
     */
    render557HolographicArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 558: AugmentedRealityArt
     * Augmented Reality Art visualization with configurable parameters
     */
    render558AugmentedRealityArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 559: VrArt
     * Vr Art visualization with configurable parameters
     */
    render559VrArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 560: ProceduralArt
     * Procedural Art visualization with configurable parameters
     */
    render560ProceduralArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 561: ParametricArt
     * Parametric Art visualization with configurable parameters
     */
    render561ParametricArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 562: MathematicalArt
     * Mathematical Art visualization with configurable parameters
     */
    render562MathematicalArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 563: GeometricArt
     * Geometric Art visualization with configurable parameters
     */
    render563GeometricArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 564: TessellationArt
     * Tessellation Art visualization with configurable parameters
     */
    render564TessellationArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 565: SymmetryArt
     * Symmetry Art visualization with configurable parameters
     */
    render565SymmetryArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 566: KaleidoscopeArt
     * Kaleidoscope Art visualization with configurable parameters
     */
    render566KaleidoscopeArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 567: MandalaArt
     * Mandala Art visualization with configurable parameters
     */
    render567MandalaArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 568: ZentangleArt
     * Zentangle Art visualization with configurable parameters
     */
    render568ZentangleArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 569: DoodleArt
     * Doodle Art visualization with configurable parameters
     */
    render569DoodleArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 570: StreetArt
     * Street Art visualization with configurable parameters
     */
    render570StreetArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 571: GraffitiArt
     * Graffiti Art visualization with configurable parameters
     */
    render571GraffitiArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 572: MuralArt
     * Mural Art visualization with configurable parameters
     */
    render572MuralArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 573: StencilArt
     * Stencil Art visualization with configurable parameters
     */
    render573StencilArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 574: WheatPasteArt
     * Wheat Paste Art visualization with configurable parameters
     */
    render574WheatPasteArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 575: SprayPaintArt
     * Spray Paint Art visualization with configurable parameters
     */
    render575SprayPaintArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 576: MosaicArt
     * Mosaic Art visualization with configurable parameters
     */
    render576MosaicArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 577: CollageArt
     * Collage Art visualization with configurable parameters
     */
    render577CollageArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 578: MixedMediaArt
     * Mixed Media Art visualization with configurable parameters
     */
    render578MixedMediaArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 579: AssemblageArt
     * Assemblage Art visualization with configurable parameters
     */
    render579AssemblageArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 580: FoundObjectArt
     * Found Object Art visualization with configurable parameters
     */
    render580FoundObjectArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 581: ReadymadeArt
     * Readymade Art visualization with configurable parameters
     */
    render581ReadymadeArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 582: AppropriationArt
     * Appropriation Art visualization with configurable parameters
     */
    render582AppropriationArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 583: SamplingArt
     * Sampling Art visualization with configurable parameters
     */
    render583SamplingArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 584: RemixArt
     * Remix Art visualization with configurable parameters
     */
    render584RemixArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 585: MashupArt
     * Mashup Art visualization with configurable parameters
     */
    render585MashupArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 586: Photomontage
     * Photomontage visualization with configurable parameters
     */
    render586Photomontage(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 587: CutUpTechnique
     * Cut Up Technique visualization with configurable parameters
     */
    render587CutUpTechnique(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 588: ExquisiteCorpse
     * Exquisite Corpse visualization with configurable parameters
     */
    render588ExquisiteCorpse(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 589: AutomaticDrawing
     * Automatic Drawing visualization with configurable parameters
     */
    render589AutomaticDrawing(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 590: ChanceArt
     * Chance Art visualization with configurable parameters
     */
    render590ChanceArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 591: IndeterminacyArt
     * Indeterminacy Art visualization with configurable parameters
     */
    render591IndeterminacyArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 592: AleatoryArt
     * Aleatory Art visualization with configurable parameters
     */
    render592AleatoryArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 593: StochasticArt
     * Stochastic Art visualization with configurable parameters
     */
    render593StochasticArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 594: EntropyArt
     * Entropy Art visualization with configurable parameters
     */
    render594EntropyArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 595: ChaosArt
     * Chaos Art visualization with configurable parameters
     */
    render595ChaosArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 596: ComplexityArt
     * Complexity Art visualization with configurable parameters
     */
    render596ComplexityArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 597: EmergenceArt
     * Emergence Art visualization with configurable parameters
     */
    render597EmergenceArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 598: SelfOrganizationArt
     * Self Organization Art visualization with configurable parameters
     */
    render598SelfOrganizationArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 600: FlockingArt
     * Flocking Art visualization with configurable parameters
     */
    render600FlockingArt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 601: Nebula
     * Nebula visualization with configurable parameters
     */
    render601Nebula(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 602: GalaxySpiral
     * Galaxy Spiral visualization with configurable parameters
     */
    render602GalaxySpiral(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 603: BlackHole
     * Black Hole visualization with configurable parameters
     */
    render603BlackHole(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 604: Pulsar
     * Pulsar visualization with configurable parameters
     */
    render604Pulsar(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 605: Quasar
     * Quasar visualization with configurable parameters
     */
    render605Quasar(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 606: Supernova
     * Supernova visualization with configurable parameters
     */
    render606Supernova(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 607: StarCluster
     * Star Cluster visualization with configurable parameters
     */
    render607StarCluster(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 608: AsteroidBelt
     * Asteroid Belt visualization with configurable parameters
     */
    render608AsteroidBelt(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 609: CometTail
     * Comet Tail visualization with configurable parameters
     */
    render609CometTail(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 610: MeteorShower
     * Meteor Shower visualization with configurable parameters
     */
    render610MeteorShower(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 611: PlanetaryRings
     * Planetary Rings visualization with configurable parameters
     */
    render611PlanetaryRings(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 612: SolarFlare
     * Solar Flare visualization with configurable parameters
     */
    render612SolarFlare(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 613: CoronalMassEjection
     * Coronal Mass Ejection visualization with configurable parameters
     */
    render613CoronalMassEjection(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 614: CosmicRay
     * Cosmic Ray visualization with configurable parameters
     */
    render614CosmicRay(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 615: GammaRayBurst
     * Gamma Ray Burst visualization with configurable parameters
     */
    render615GammaRayBurst(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 616: GravitationalLens
     * Gravitational Lens visualization with configurable parameters
     */
    render616GravitationalLens(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 617: DarkMatterHalo
     * Dark Matter Halo visualization with configurable parameters
     */
    render617DarkMatterHalo(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 618: CosmicWeb
     * Cosmic Web visualization with configurable parameters
     */
    render618CosmicWeb(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 619: Void
     * Void visualization with configurable parameters
     */
    render619Void(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 620: FilamentStructure
     * Filament Structure visualization with configurable parameters
     */
    render620FilamentStructure(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 621: HubbleDeepField
     * Hubble Deep Field visualization with configurable parameters
     */
    render621HubbleDeepField(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 622: GalaxyCollision
     * Galaxy Collision visualization with configurable parameters
     */
    render622GalaxyCollision(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 623: TidalTail
     * Tidal Tail visualization with configurable parameters
     */
    render623TidalTail(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 624: StarburstGalaxy
     * Starburst Galaxy visualization with configurable parameters
     */
    render624StarburstGalaxy(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 625: ActiveGalacticNucleus
     * Active Galactic Nucleus visualization with configurable parameters
     */
    render625ActiveGalacticNucleus(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 626: Blazar
     * Blazar visualization with configurable parameters
     */
    render626Blazar(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 627: SeyfertGalaxy
     * Seyfert Galaxy visualization with configurable parameters
     */
    render627SeyfertGalaxy(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 628: RadioGalaxy
     * Radio Galaxy visualization with configurable parameters
     */
    render628RadioGalaxy(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 629: EllipticalGalaxy
     * Elliptical Galaxy visualization with configurable parameters
     */
    render629EllipticalGalaxy(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 630: IrregularGalaxy
     * Irregular Galaxy visualization with configurable parameters
     */
    render630IrregularGalaxy(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 631: DwarfGalaxy
     * Dwarf Galaxy visualization with configurable parameters
     */
    render631DwarfGalaxy(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 632: GlobularCluster
     * Globular Cluster visualization with configurable parameters
     */
    render632GlobularCluster(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 633: OpenCluster
     * Open Cluster visualization with configurable parameters
     */
    render633OpenCluster(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 634: ProtoplanetaryDisk
     * Protoplanetary Disk visualization with configurable parameters
     */
    render634ProtoplanetaryDisk(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 635: AccretionDisk
     * Accretion Disk visualization with configurable parameters
     */
    render635AccretionDisk(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 636: JetsFromBlackHole
     * Jets From Black Hole visualization with configurable parameters
     */
    render636JetsFromBlackHole(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 637: EventHorizon
     * Event Horizon visualization with configurable parameters
     */
    render637EventHorizon(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 638: PhotonSphere
     * Photon Sphere visualization with configurable parameters
     */
    render638PhotonSphere(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 639: Ergosphere
     * Ergosphere visualization with configurable parameters
     */
    render639Ergosphere(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 640: Singularity
     * Singularity visualization with configurable parameters
     */
    render640Singularity(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 641: Wormhole
     * Wormhole visualization with configurable parameters
     */
    render641Wormhole(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 642: WhiteHole
     * White Hole visualization with configurable parameters
     */
    render642WhiteHole(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 643: NakedSingularity
     * Naked Singularity visualization with configurable parameters
     */
    render643NakedSingularity(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 644: HawkingRadiation
     * Hawking Radiation visualization with configurable parameters
     */
    render644HawkingRadiation(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 645: InformationParadox
     * Information Paradox visualization with configurable parameters
     */
    render645InformationParadox(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 646: MultiverseBubble
     * Multiverse Bubble visualization with configurable parameters
     */
    render646MultiverseBubble(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.canvas.width + this.canvas.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.canvas.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.canvas.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.canvas.height - height, 40, height);
        }
    }
    /**
     * Mode 647: ParallelUniverse
     * Parallel Universe visualization with configurable parameters
     */
    render647ParallelUniverse(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 648: BraneCollision
     * Brane Collision visualization with configurable parameters
     */
    render648BraneCollision(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 649: ExtraDimensions
     * Extra Dimensions visualization with configurable parameters
     */
    render649ExtraDimensions(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 650: CalabiYauManifold
     * Calabi Yau Manifold visualization with configurable parameters
     */
    render650CalabiYauManifold(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 651: StringTheoryVibration
     * String Theory Vibration visualization with configurable parameters
     */
    render651StringTheoryVibration(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 652: QuantumFoam
     * Quantum Foam visualization with configurable parameters
     */
    render652QuantumFoam(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 653: PlanckScale
     * Planck Scale visualization with configurable parameters
     */
    render653PlanckScale(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 654: BigBang
     * Big Bang visualization with configurable parameters
     */
    render654BigBang(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 655: CosmicMicrowaveBackground
     * Cosmic Microwave Background visualization with configurable parameters
     */
    render655CosmicMicrowaveBackground(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 656: InflationField
     * Inflation Field visualization with configurable parameters
     */
    render656InflationField(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 657: DensityFluctuations
     * Density Fluctuations visualization with configurable parameters
     */
    render657DensityFluctuations(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 658: BaryonAcousticOscillations
     * Baryon Acoustic Oscillations visualization with configurable parameters
     */
    render658BaryonAcousticOscillations(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 659: DarkEnergy
     * Dark Energy visualization with configurable parameters
     */
    render659DarkEnergy(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 660: CosmologicalConstant
     * Cosmological Constant visualization with configurable parameters
     */
    render660CosmologicalConstant(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 661: QuintessenceField
     * Quintessence Field visualization with configurable parameters
     */
    render661QuintessenceField(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 662: HeatDeath
     * Heat Death visualization with configurable parameters
     */
    render662HeatDeath(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 663: BigRip
     * Big Rip visualization with configurable parameters
     */
    render663BigRip(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 664: BigCrunch
     * Big Crunch visualization with configurable parameters
     */
    render664BigCrunch(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 665: BigBounce
     * Big Bounce visualization with configurable parameters
     */
    render665BigBounce(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 666: CyclicUniverse
     * Cyclic Universe visualization with configurable parameters
     */
    render666CyclicUniverse(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 667: ConformalCyclicCosmology
     * Conformal Cyclic Cosmology visualization with configurable parameters
     */
    render667ConformalCyclicCosmology(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 668: EternalInflation
     * Eternal Inflation visualization with configurable parameters
     */
    render668EternalInflation(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 669: LandscapeMultiverse
     * Landscape Multiverse visualization with configurable parameters
     */
    render669LandscapeMultiverse(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 670: QuantumDecoherence
     * Quantum Decoherence visualization with configurable parameters
     */
    render670QuantumDecoherence(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 671: ManyWorlds
     * Many Worlds visualization with configurable parameters
     */
    render671ManyWorlds(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 672: PilotWave
     * Pilot Wave visualization with configurable parameters
     */
    render672PilotWave(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 673: SpontaneousCollapse
     * Spontaneous Collapse visualization with configurable parameters
     */
    render673SpontaneousCollapse(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 674: TransactionalInterpretation
     * Transactional Interpretation visualization with configurable parameters
     */
    render674TransactionalInterpretation(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 675: RelationalQuantumMechanics
     * Relational Quantum Mechanics visualization with configurable parameters
     */
    render675RelationalQuantumMechanics(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 676: QuantumBayesianism
     * Quantum Bayesianism visualization with configurable parameters
     */
    render676QuantumBayesianism(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 677: ConsistentHistories
     * Consistent Histories visualization with configurable parameters
     */
    render677ConsistentHistories(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 678: BohemianMechanics
     * Bohemian Mechanics visualization with configurable parameters
     */
    render678BohemianMechanics(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 679: StochasticMechanics
     * Stochastic Mechanics visualization with configurable parameters
     */
    render679StochasticMechanics(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 680: QuantumDarwinism
     * Quantum Darwinism visualization with configurable parameters
     */
    render680QuantumDarwinism(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 681: Einselection
     * Einselection visualization with configurable parameters
     */
    render681Einselection(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 682: PointerStates
     * Pointer States visualization with configurable parameters
     */
    render682PointerStates(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 683: BranchingSpacetime
     * Branching Spacetime visualization with configurable parameters
     */
    render683BranchingSpacetime(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 684: Worldline
     * Worldline visualization with configurable parameters
     */
    render684Worldline(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 685: LightCone
     * Light Cone visualization with configurable parameters
     */
    render685LightCone(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 686: CauchySurface
     * Cauchy Surface visualization with configurable parameters
     */
    render686CauchySurface(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 687: SpacelikeHypersurface
     * Spacelike Hypersurface visualization with configurable parameters
     */
    render687SpacelikeHypersurface(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 688: TimelikeCurve
     * Timelike Curve visualization with configurable parameters
     */
    render688TimelikeCurve(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 689: ClosedTimelikeCurve
     * Closed Timelike Curve visualization with configurable parameters
     */
    render689ClosedTimelikeCurve(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 690: ChronologyProtection
     * Chronology Protection visualization with configurable parameters
     */
    render690ChronologyProtection(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 691: NovikovSelfConsistency
     * Novikov Self Consistency visualization with configurable parameters
     */
    render691NovikovSelfConsistency(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 692: GrandfatherParadox
     * Grandfather Paradox visualization with configurable parameters
     */
    render692GrandfatherParadox(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 693: BootstrapParadox
     * Bootstrap Paradox visualization with configurable parameters
     */
    render693BootstrapParadox(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 694: PredestinationParadox
     * Predestination Paradox visualization with configurable parameters
     */
    render694PredestinationParadox(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 695: CausalLoop
     * Causal Loop visualization with configurable parameters
     */
    render695CausalLoop(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 696: Retrocausality
     * Retrocausality visualization with configurable parameters
     */
    render696Retrocausality(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 697: AdvancedWave
     * Advanced Wave visualization with configurable parameters
     */
    render697AdvancedWave(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 698: WheelerFeynmanAbsorber
     * Wheeler Feynman Absorber visualization with configurable parameters
     */
    render698WheelerFeynmanAbsorber(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 699: TransactionalInterpretation
     * Transactional Interpretation visualization with configurable parameters
     */
    render699TransactionalInterpretation(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 700: TwoStateVector
     * Two State Vector visualization with configurable parameters
     */
    render700TwoStateVector(magnitudes) {
        const params = this.settings.parameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }


    generatePreview(magnitudes) {
        if (!magnitudes) {
            // Generate demo data
            magnitudes = new Float32Array(this.settings.numBars);
            for (let i = 0; i < magnitudes.length; i++) {
                magnitudes[i] = Math.random() * 0.5 + 0.3;
            }
        }
    }

    // ========================================
    // AUTO-GENERATED MODE IMPLEMENTATIONS (401-500)
    // ========================================

    renderMode401_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 401 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode402_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 402 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode403_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 403 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode404_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 404 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode405_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 405 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode406_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 406 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode407_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 407 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode408_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 408 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode409_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 409 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode410_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 410 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode411_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 411 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode412_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 412 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode413_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 413 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode414_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 414 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode415_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 415 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode416_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 416 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode417_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 417 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode418_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 418 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode419_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 419 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode420_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 420 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode421_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 421 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode422_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 422 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode423_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 423 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode424_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 424 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode425_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 425 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode426_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 426 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode427_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 427 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode428_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 428 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode429_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 429 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode430_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 430 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode431_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 431 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode432_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 432 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode433_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 433 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode434_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 434 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode435_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 435 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode436_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 436 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode437_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 437 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode438_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 438 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode439_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 439 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode440_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 440 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode441_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 441 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode442_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 442 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode443_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 443 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode444_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 444 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode445_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 445 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode446_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 446 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode447_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 447 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode448_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 448 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode449_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 449 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode450_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 450 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode451_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 451 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode452_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 452 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode453_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 453 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode454_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 454 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode455_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 455 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode456_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 456 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode457_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 457 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode458_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 458 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode459_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 459 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode460_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 460 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode461_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 461 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode462_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 462 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode463_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 463 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode464_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 464 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode465_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 465 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode466_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 466 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode467_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 467 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode468_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 468 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode469_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 469 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode470_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 470 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode471_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 471 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode472_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 472 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode473_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 473 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode474_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 474 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode475_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 475 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode476_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 476 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode477_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 477 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode478_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 478 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode479_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 479 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode480_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 480 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode481_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 481 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode482_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 482 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode483_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 483 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode484_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 484 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode485_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 485 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode486_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 486 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode487_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 487 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode488_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 488 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode489_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 489 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode490_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 490 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode491_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 491 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode492_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 492 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode493_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 493 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode494_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 494 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode495_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 495 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode496_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 496 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode497_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 497 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode498_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 498 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode499_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 499 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode500_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 500 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    /**
     * Convert HSV to RGB
     * @param {number} h - Hue (0-360)
     * @param {number} s - Saturation (0-100)
     * @param {number} v - Value (0-100)
     * @returns {Array} RGB array [r, g, b] (0-255)
     */
    hsvToRgb(h, s, v) {
        h = h / 360;
        s = s / 100;
        v = v / 100;

        let r, g, b;
        const i = Math.floor(h * 6);
        const f = h * 6 - i;
        const p = v * (1 - s);
        const q = v * (1 - f * s);
        const t = v * (1 - (1 - f) * s);

        switch (i % 6) {
            case 0: r = v; g = t; b = p; break;
            case 1: r = q; g = v; b = p; break;
            case 2: r = p; g = v; b = t; break;
            case 3: r = p; g = q; b = v; break;
            case 4: r = t; g = p; b = v; break;
            case 5: r = v; g = p; b = q; break;
        }

        return [
            Math.round(r * 255),
            Math.round(g * 255),
            Math.round(b * 255)
        ];
    }

    /**
     * Shared implementation for modes 401-500
     * Provides audio-reactive circular visualization
     */
    renderMode401_500_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Enhanced stub implementation - generates unique visualizations based on mode
        const modeId = this.settings.mode || '';
        const modeNum = parseInt(modeId.match(/\d+/)?.[0] || '0');

        // Use mode number as seed for variation
        const seed = modeNum;
        const variant = seed % 10;

        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const numBars = Math.min(magnitudes.length, this.settings.numBars || 64);

        // Generate unique visualization based on mode variant
        switch (variant) {
            case 0: // Orbital rings
                this.renderOrbitalRings(magnitudes, bass, mids, treble, intensity, speed, complexity, seed);
                break;
            case 1: // Spiral waves
                this.renderSpiralWaves(magnitudes, bass, mids, treble, intensity, speed, complexity, seed);
                break;
            case 2: // Radial burst
                this.renderRadialBurst(magnitudes, bass, mids, treble, intensity, speed, complexity, seed);
                break;
            case 3: // Wave interference
                this.renderWaveInterferencePattern(magnitudes, bass, mids, treble, intensity, speed, complexity, seed);
                break;
            case 4: // Particle field
                this.renderParticleField(magnitudes, bass, mids, treble, intensity, speed, complexity, seed);
                break;
            case 5: // Geometric patterns
                this.renderGeometricPattern(magnitudes, bass, mids, treble, intensity, speed, complexity, seed);
                break;
            case 6: // Energy pulses
                this.renderEnergyPulses(magnitudes, bass, mids, treble, intensity, speed, complexity, seed);
                break;
            case 7: // Frequency bands
                this.renderFrequencyBands(magnitudes, bass, mids, treble, intensity, speed, complexity, seed);
                break;
            case 8: // Circular flow
                this.renderCircularFlow(magnitudes, bass, mids, treble, intensity, speed, complexity, seed);
                break;
            case 9: // Crystal formation
                this.renderCrystalFormation(magnitudes, bass, mids, treble, intensity, speed, complexity, seed);
                break;
        }

        this.ctx.globalAlpha = 1;
    }

    // Variant implementations for mode stub system
    renderOrbitalRings(magnitudes, bass, mids, treble, intensity, speed, complexity, seed) {
        const numRings = 3 + Math.floor(complexity / 3);
        for (let ring = 0; ring < numRings; ring++) {
            const ringRadius = this.maxRadius * (0.2 + ring * 0.15);
            const numPoints = 16 + ring * 8;
            for (let i = 0; i < numPoints; i++) {
                const mag = magnitudes[i % magnitudes.length];
                const angle = (i / numPoints) * Math.PI * 2 + this.frameCounter * 0.02 * speed * (1 + ring * 0.5);
                const r = ringRadius + mag * 40 * intensity;
                const x = this.centerX + Math.cos(angle) * r;
                const y = this.centerY + Math.sin(angle) * r;
                const size = 2 + mag * 6 * intensity;
                this.ctx.fillStyle = this.getColor(i + ring * 20, numPoints * numRings);
                this.ctx.globalAlpha = 0.6 + mag * 0.4;
                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    renderSpiralWaves(magnitudes, bass, mids, treble, intensity, speed, complexity, seed) {
        const numSpirals = 2 + Math.floor(complexity / 4);
        for (let spiral = 0; spiral < numSpirals; spiral++) {
            const spiralOffset = (spiral / numSpirals) * Math.PI * 2;
            for (let i = 0; i < magnitudes.length; i++) {
                const mag = magnitudes[i];
                const t = i / magnitudes.length;
                const angle = spiralOffset + t * Math.PI * 4 + this.frameCounter * 0.01 * speed;
                const r = this.maxRadius * (0.2 + t * 0.6) + mag * 50 * intensity;
                const x = this.centerX + Math.cos(angle) * r;
                const y = this.centerY + Math.sin(angle) * r;
                const size = 2 + mag * 5 * intensity;
                this.ctx.fillStyle = this.getColor(i, magnitudes.length);
                this.ctx.globalAlpha = 0.5 + mag * 0.5;
                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    renderRadialBurst(magnitudes, bass, mids, treble, intensity, speed, complexity, seed) {
        const numRays = Math.min(magnitudes.length, 72);
        for (let i = 0; i < numRays; i++) {
            const mag = magnitudes[i];
            const angle = (i / numRays) * Math.PI * 2;
            const baseR = this.maxRadius * 0.15;
            const maxR = baseR + mag * this.maxRadius * 0.7 * intensity;

            // Draw ray as line of circles
            const steps = 10 + Math.floor(complexity);
            for (let step = 0; step < steps; step++) {
                const t = step / steps;
                const r = Utils.lerp(baseR, maxR, t);
                const x = this.centerX + Math.cos(angle) * r;
                const y = this.centerY + Math.sin(angle) * r;
                const size = (1 + mag * 4 * intensity) * (1 - t * 0.5);
                this.ctx.fillStyle = this.getColor(i, numRays);
                this.ctx.globalAlpha = (0.7 - t * 0.5) * (0.5 + mag * 0.5);
                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    renderWaveInterferencePattern(magnitudes, bass, mids, treble, intensity, speed, complexity, seed) {
        const gridSize = 8 + Math.floor(complexity);
        const cellSize = (this.maxRadius * 2) / gridSize;

        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                const x = this.centerX - this.maxRadius + i * cellSize;
                const y = this.centerY - this.maxRadius + j * cellSize;
                const dx = x - this.centerX;
                const dy = y - this.centerY;
                const dist = Math.sqrt(dx * dx + dy * dy) / this.maxRadius;
                const magIndex = Math.floor(dist * magnitudes.length) % magnitudes.length;
                const mag = magnitudes[magIndex];
                const wave = Math.sin(dist * 8 - this.frameCounter * 0.05 * speed + mag * 2) * 0.5 + 0.5;
                const size = cellSize * 0.3 * wave * mag * intensity;

                if (size > 1) {
                    this.ctx.fillStyle = this.getColor(magIndex, magnitudes.length);
                    this.ctx.globalAlpha = 0.4 + mag * 0.6;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
        }
    }

    renderParticleField(magnitudes, bass, mids, treble, intensity, speed, complexity, seed) {
        const numParticles = Math.min(magnitudes.length * 2, 128);
        for (let i = 0; i < numParticles; i++) {
            const mag = magnitudes[i % magnitudes.length];
            const angle1 = (i / numParticles) * Math.PI * 2;
            const angle2 = angle1 + this.frameCounter * 0.02 * speed;
            const r1 = this.maxRadius * (0.3 + Math.sin(this.frameCounter * 0.01 + i) * 0.2);
            const r2 = r1 + mag * 100 * intensity;
            const x = this.centerX + Math.cos(angle2) * r2;
            const y = this.centerY + Math.sin(angle2) * r2;
            const size = 1 + mag * 4 * intensity;
            this.ctx.fillStyle = this.getColor(i, numParticles);
            this.ctx.globalAlpha = 0.4 + mag * 0.6;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    renderGeometricPattern(magnitudes, bass, mids, treble, intensity, speed, complexity, seed) {
        const numShapes = 6 + Math.floor(complexity);
        for (let i = 0; i < numShapes; i++) {
            const mag = magnitudes[Math.floor((i / numShapes) * magnitudes.length)];
            const angle = (i / numShapes) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const r = this.maxRadius * (0.3 + mag * 0.4 * intensity);
            const x = this.centerX + Math.cos(angle) * r;
            const y = this.centerY + Math.sin(angle) * r;
            const sides = 3 + (i % 5);
            const size = 20 + mag * 40 * intensity;

            this.ctx.strokeStyle = this.getColor(i, numShapes);
            this.ctx.lineWidth = 2 + mag * 3 * intensity;
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            for (let s = 0; s <= sides; s++) {
                const a = (s / sides) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
                const px = x + Math.cos(a) * size;
                const py = y + Math.sin(a) * size;
                if (s === 0) this.ctx.moveTo(px, py);
                else this.ctx.lineTo(px, py);
            }
            this.ctx.stroke();
        }
    }

    renderEnergyPulses(magnitudes, bass, mids, treble, intensity, speed, complexity, seed) {
        const numPulses = 5 + Math.floor(complexity / 2);
        for (let i = 0; i < numPulses; i++) {
            const mag = bass * (i % 2) + mids * ((i + 1) % 2);
            const t = (this.frameCounter * 0.02 * speed + i * 0.3) % 1;
            const r = this.maxRadius * t * (0.5 + mag * 0.5 * intensity);
            const alpha = (1 - t) * (0.3 + mag * 0.7);

            this.ctx.strokeStyle = this.getColor(i * 30, numPulses * 30);
            this.ctx.lineWidth = 2 + mag * 4 * intensity;
            this.ctx.globalAlpha = alpha;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, r, 0, Math.PI * 2);
            this.ctx.stroke();
        }
    }

    renderFrequencyBands(magnitudes, bass, mids, treble, intensity, speed, complexity, seed) {
        const bands = 5 + Math.floor(complexity / 2);
        const bandSize = magnitudes.length / bands;

        for (let band = 0; band < bands; band++) {
            const start = Math.floor(band * bandSize);
            const end = Math.floor((band + 1) * bandSize);
            const bandMag = magnitudes.slice(start, end).reduce((a, b) => a + b, 0) / bandSize;

            const innerR = this.maxRadius * (0.2 + band * 0.15);
            const outerR = innerR + bandMag * 80 * intensity;
            const numBars = 24 + band * 12;

            for (let i = 0; i < numBars; i++) {
                const angle = (i / numBars) * Math.PI * 2 + this.frameCounter * 0.01 * speed * (1 + band * 0.2);
                const x1 = this.centerX + Math.cos(angle) * innerR;
                const y1 = this.centerY + Math.sin(angle) * innerR;
                const x2 = this.centerX + Math.cos(angle) * outerR;
                const y2 = this.centerY + Math.sin(angle) * outerR;

                this.ctx.strokeStyle = this.getColor(band * 30 + i, bands * 30 + numBars);
                this.ctx.lineWidth = 2 + bandMag * 3 * intensity;
                this.ctx.globalAlpha = 0.5 + bandMag * 0.5;
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x2, y2);
                this.ctx.stroke();
            }
        }
    }

    renderCircularFlow(magnitudes, bass, mids, treble, intensity, speed, complexity, seed) {
        const numFlows = 3 + Math.floor(complexity / 3);
        for (let flow = 0; flow < numFlows; flow++) {
            const flowAngle = (flow / numFlows) * Math.PI * 2;
            const numPoints = 32;

            for (let i = 0; i < numPoints; i++) {
                const mag = magnitudes[Math.floor((i / numPoints) * magnitudes.length)];
                const t = i / numPoints;
                const angle = flowAngle + t * Math.PI * 2 + this.frameCounter * 0.03 * speed * (flow + 1);
                const baseR = this.maxRadius * (0.25 + flow * 0.15);
                const r = baseR + Math.sin(t * Math.PI * 4 + this.frameCounter * 0.1) * 30 * mag * intensity;
                const x = this.centerX + Math.cos(angle) * r;
                const y = this.centerY + Math.sin(angle) * r;
                const size = 2 + mag * 5 * intensity;

                this.ctx.fillStyle = this.getColor(flow * 40 + i, numFlows * 40 + numPoints);
                this.ctx.globalAlpha = 0.5 + mag * 0.5;
                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    renderCrystalFormation(magnitudes, bass, mids, treble, intensity, speed, complexity, seed) {
        const numCrystals = 8 + Math.floor(complexity);
        for (let i = 0; i < numCrystals; i++) {
            const angle = (i / numCrystals) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const mag = magnitudes[Math.floor((i / numCrystals) * magnitudes.length)];
            const r = this.maxRadius * (0.3 + mag * 0.4 * intensity);
            const x = this.centerX + Math.cos(angle) * r;
            const y = this.centerY + Math.sin(angle) * r;

            // Draw crystal shape
            const size = 15 + mag * 35 * intensity;
            const points = 6;
            this.ctx.fillStyle = this.getColor(i, numCrystals);
            this.ctx.globalAlpha = 0.4 + mag * 0.6;
            this.ctx.beginPath();
            for (let p = 0; p < points; p++) {
                const pa = (p / points) * Math.PI * 2;
                const pr = size * (p % 2 === 0 ? 1 : 0.5);
                const px = x + Math.cos(pa) * pr;
                const py = y + Math.sin(pa) * pr;
                if (p === 0) this.ctx.moveTo(px, py);
                else this.ctx.lineTo(px, py);
            }
            this.ctx.closePath();
            this.ctx.fill();
        }
    }

    /**
     * Mode 405: Particle Accelerator
     * Particles accelerating in a ring with speed trails
     */
    render405ParticleAccelerator(magnitudes) {
        const numParticles = magnitudes.length;
        const innerRadius = this.getEffectiveInnerRadius();
        const maxRadius = this.maxRadius;

        // Initialize particle positions if not exists
        if (!this.acceleratorParticles) {
            this.acceleratorParticles = [];
            for (let i = 0; i < numParticles; i++) {
                this.acceleratorParticles.push({
                    angle: (i / numParticles) * Math.PI * 2,
                    speed: 0.01 + Math.random() * 0.02,
                    radius: innerRadius + Math.random() * (maxRadius - innerRadius) * 0.5,
                    trail: []
                });
            }
        }

        // Draw acceleration ring
        this.ctx.strokeStyle = this.getColor(0, numParticles);
        this.ctx.lineWidth = 2 * this.scaleFactor;
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, innerRadius + (maxRadius - innerRadius) * 0.3, 0, Math.PI * 2);
        this.ctx.stroke();

        // Update and draw particles with trails
        this.acceleratorParticles.forEach((particle, i) => {
            const magnitude = magnitudes[i];

            // Accelerate particle based on audio
            particle.speed += magnitude * 0.001;
            particle.speed = Math.min(particle.speed, 0.1); // Cap speed
            particle.angle += particle.speed;

            // Calculate position
            const x = this.centerX + Math.cos(particle.angle) * particle.radius;
            const y = this.centerY + Math.sin(particle.angle) * particle.radius;

            // Add to trail
            particle.trail.push({ x, y, alpha: 1.0 });
            if (particle.trail.length > 20) particle.trail.shift();

            // Draw trail
            particle.trail.forEach((point, j) => {
                const alpha = (j / particle.trail.length) * 0.5;
                const size = (magnitude * 4 + 2) * this.scaleFactor * (j / particle.trail.length);
                this.ctx.fillStyle = this.getColor(i, numParticles).replace('rgb', 'rgba').replace(')', `, ${alpha})`);
                this.ctx.beginPath();
                this.ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                this.ctx.fill();
            });

            // Draw particle
            const particleSize = (magnitude * 6 + 3) * this.scaleFactor;
            this.ctx.fillStyle = this.getColor(i, numParticles);
            this.ctx.shadowBlur = 10 * this.scaleFactor;
            this.ctx.shadowColor = this.getColor(i, numParticles);
            this.ctx.beginPath();
            this.ctx.arc(x, y, particleSize, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        });
    }

    /**
     * Mode 452: Particle Decay
     * Radioactive particle decay chain with fading particles
     */
    render452ParticleDecay(magnitudes) {
        const numParticles = magnitudes.length * 2;
        const centerRadius = this.maxRadius * 0.3;

        // Initialize decay particles if not exists
        if (!this.decayParticles) {
            this.decayParticles = [];
        }

        // Spawn new particles based on audio magnitude
        magnitudes.forEach((magnitude, i) => {
            if (magnitude > 0.3 && Math.random() < magnitude * 0.5) {
                const angle = (i / magnitudes.length) * Math.PI * 2;
                const speed = (magnitude * 3 + 1) * this.scaleFactor;
                this.decayParticles.push({
                    x: this.centerX,
                    y: this.centerY,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    decay: 0.015 + Math.random() * 0.01,
                    size: (magnitude * 8 + 4) * this.scaleFactor,
                    colorIndex: i
                });
            }
        });

        // Draw nucleus glow
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const glowSize = (avgMagnitude * 30 + 20) * this.scaleFactor;
        const gradient = this.ctx.createRadialGradient(
            this.centerX, this.centerY, 0,
            this.centerX, this.centerY, glowSize
        );
        gradient.addColorStop(0, this.getColor(0, magnitudes.length).replace('rgb', 'rgba').replace(')', ', 0.8)'));
        gradient.addColorStop(0.5, this.getColor(Math.floor(magnitudes.length / 2), magnitudes.length).replace('rgb', 'rgba').replace(')', ', 0.3)'));
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        this.ctx.fillStyle = gradient;
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, glowSize, 0, Math.PI * 2);
        this.ctx.fill();

        // Update and draw decay particles
        this.decayParticles = this.decayParticles.filter(particle => {
            // Update position
            particle.x += particle.vx;
            particle.y += particle.vy;

            // Apply decay
            particle.life -= particle.decay;
            particle.vx *= 0.98; // Slow down
            particle.vy *= 0.98;

            // Draw particle
            if (particle.life > 0) {
                const alpha = particle.life;
                const size = particle.size * particle.life;
                this.ctx.fillStyle = this.getColor(particle.colorIndex, magnitudes.length)
                    .replace('rgb', 'rgba').replace(')', `, ${alpha})`);
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                this.ctx.fill();

                // Draw decay trail
                this.ctx.strokeStyle = this.getColor(particle.colorIndex, magnitudes.length)
                    .replace('rgb', 'rgba').replace(')', `, ${alpha * 0.3})`);
                this.ctx.lineWidth = size * 0.5;
                this.ctx.beginPath();
                this.ctx.moveTo(particle.x, particle.y);
                this.ctx.lineTo(particle.x - particle.vx * 2, particle.y - particle.vy * 2);
                this.ctx.stroke();
            }

            return particle.life > 0;
        });
    }

    /**
     * Mode 599: Swarm Art
     * Particle swarm with flocking behavior
     */
    render599SwarmArt(magnitudes) {
        const numSwarmers = magnitudes.length * 3;

        // Initialize swarm if not exists
        if (!this.swarmParticles || this.swarmParticles.length !== numSwarmers) {
            this.swarmParticles = [];
            for (let i = 0; i < numSwarmers; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * this.maxRadius * 0.5;
                this.swarmParticles.push({
                    x: this.centerX + Math.cos(angle) * distance,
                    y: this.centerY + Math.sin(angle) * distance,
                    vx: (Math.random() - 0.5) * 2 * this.scaleFactor,
                    vy: (Math.random() - 0.5) * 2 * this.scaleFactor,
                    colorIndex: Math.floor(i / 3)
                });
            }
        }

        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Update swarm particles with flocking behavior
        this.swarmParticles.forEach((particle, i) => {
            // Get magnitude for this particle
            const magnitude = magnitudes[particle.colorIndex % magnitudes.length];

            // Calculate center pull (cohesion)
            const dx = this.centerX - particle.x;
            const dy = this.centerY - particle.y;
            const distToCenter = Math.sqrt(dx * dx + dy * dy);
            const centerPull = 0.02 * magnitude * this.scaleFactor;
            particle.vx += (dx / distToCenter) * centerPull;
            particle.vy += (dy / distToCenter) * centerPull;

            // Swirl around center based on audio
            const angle = Math.atan2(dy, dx);
            const swirlStrength = magnitude * 0.05 * this.scaleFactor;
            particle.vx += Math.cos(angle + Math.PI / 2) * swirlStrength;
            particle.vy += Math.sin(angle + Math.PI / 2) * swirlStrength;

            // Neighbor interaction (alignment + separation)
            let neighborVx = 0, neighborVy = 0, neighborCount = 0;
            const neighborDist = 50 * this.scaleFactor;

            this.swarmParticles.forEach((other, j) => {
                if (i !== j) {
                    const odx = other.x - particle.x;
                    const ody = other.y - particle.y;
                    const dist = Math.sqrt(odx * odx + ody * ody);

                    if (dist < neighborDist && dist > 0) {
                        // Separation
                        particle.vx -= (odx / dist) * 0.1 * this.scaleFactor;
                        particle.vy -= (ody / dist) * 0.1 * this.scaleFactor;

                        // Alignment
                        neighborVx += other.vx;
                        neighborVy += other.vy;
                        neighborCount++;
                    }
                }
            });

            if (neighborCount > 0) {
                particle.vx += (neighborVx / neighborCount - particle.vx) * 0.05;
                particle.vy += (neighborVy / neighborCount - particle.vy) * 0.05;
            }

            // Apply velocity limits
            const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
            const maxSpeed = (3 + magnitude * 2) * this.scaleFactor;
            if (speed > maxSpeed) {
                particle.vx = (particle.vx / speed) * maxSpeed;
                particle.vy = (particle.vy / speed) * maxSpeed;
            }

            // Update position
            particle.x += particle.vx;
            particle.y += particle.vy;

            // Bounce off edges
            const margin = 20 * this.scaleFactor;
            if (particle.x < margin || particle.x > this.canvas.width - margin) particle.vx *= -0.8;
            if (particle.y < margin || particle.y > this.canvas.height - margin) particle.vy *= -0.8;
        });

        // Draw swarm connections
        this.ctx.lineWidth = 1 * this.scaleFactor;
        const connectionDist = 80 * this.scaleFactor;
        this.swarmParticles.forEach((particle, i) => {
            this.swarmParticles.forEach((other, j) => {
                if (i < j) {
                    const dx = other.x - particle.x;
                    const dy = other.y - particle.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < connectionDist) {
                        const alpha = (1 - dist / connectionDist) * 0.3;
                        this.ctx.strokeStyle = this.getColor(particle.colorIndex, magnitudes.length)
                            .replace('rgb', 'rgba').replace(')', `, ${alpha})`);
                        this.ctx.beginPath();
                        this.ctx.moveTo(particle.x, particle.y);
                        this.ctx.lineTo(other.x, other.y);
                        this.ctx.stroke();
                    }
                }
            });
        });

        // Draw swarm particles
        this.swarmParticles.forEach(particle => {
            const magnitude = magnitudes[particle.colorIndex % magnitudes.length];
            const size = (magnitude * 5 + 3) * this.scaleFactor;

            this.ctx.fillStyle = this.getColor(particle.colorIndex, magnitudes.length);
            this.ctx.shadowBlur = 8 * this.scaleFactor;
            this.ctx.shadowColor = this.getColor(particle.colorIndex, magnitudes.length);
            this.ctx.beginPath();
            this.ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        });
    }

    dispose() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
        this.clear();
    }
}
