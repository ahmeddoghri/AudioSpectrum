/**
 * Audio Spectrum Visualizer - Visualization Engine
 * Implements various visualization modes with Apple minimalist design
 */

class Visualizer {
    constructor(canvas, settings = {}) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.settings = { ...DEFAULT_SETTINGS, ...settings };

        // Map parameters to modeParameters for consistency
        if (settings.parameters) {
            this.settings.modeParameters = settings.parameters;
        }

        this.centerX = canvas.width / 2;
        this.centerY = canvas.height / 2;

        // Calculate scale factor: ratio of current canvas size to target video dimensions
        // This ensures preview renders proportionally to final video
        const targetSize = Math.min(this.settings.width || 1080, this.settings.height || 1080);
        const currentSize = Math.min(canvas.width, canvas.height);
        this.scaleFactor = currentSize / targetSize;

        this.maxRadius = Math.min(canvas.width, canvas.height) / 2 - (80 * this.scaleFactor);

        this.frameCounter = 0;
        this.animationId = null;

        // Mode-specific particle systems
        this.rainParticles = [];
        this.fireworkParticles = [];

        // Mode-specific state
        this.cassetteReelAngle = 0;
    }

    /**
     * Update canvas dimensions
     */
    updateDimensions(width, height) {
        this.canvas.width = width;
        this.canvas.height = height;
        this.centerX = width / 2;
        this.centerY = height / 2;

        // Recalculate scale factor for new dimensions
        const targetSize = Math.min(this.settings.width || 1080, this.settings.height || 1080);
        const currentSize = Math.min(width, height);
        this.scaleFactor = currentSize / targetSize;

        this.maxRadius = Math.min(width, height) / 2 - (80 * this.scaleFactor);
    }

    /**
     * Get effective inner radius (scaled proportionally for all canvas sizes)
     */
    getEffectiveInnerRadius() {
        const baseInnerRadius = this.settings.innerRadius || 180;
        // Scale inner radius proportionally based on canvas size
        const effectiveRadius = baseInnerRadius * this.scaleFactor;

        if (this.frameCounter === 0) {
            console.log('[Visualizer] Scaling - baseInnerRadius:', baseInnerRadius,
                       'scaleFactor:', this.scaleFactor, 'effectiveRadius:', effectiveRadius);
        }

        return effectiveRadius;
    }

    /**
     * Update settings
     */
    updateSettings(newSettings) {
        this.settings = { ...this.settings, ...newSettings };

        // Map parameters to modeParameters for consistency
        if (newSettings.parameters) {
            this.settings.modeParameters = newSettings.parameters;
        }

        // Recalculate scale factor if width/height changed
        if (newSettings.width !== undefined || newSettings.height !== undefined) {
            const targetSize = Math.min(this.settings.width || 1080, this.settings.height || 1080);
            const currentSize = Math.min(this.canvas.width, this.canvas.height);
            this.scaleFactor = currentSize / targetSize;
            this.maxRadius = Math.min(this.canvas.width, this.canvas.height) / 2 - (80 * this.scaleFactor);
        }
    }

    /**
     * Clear canvas
     */
    clear() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }

    /**
     * Draw background
     */
    drawBackground() {
        const bgStyle = BACKGROUND_STYLES[this.settings.background];
        const color = bgStyle.color;

        if (this.settings.background === 'transparent') {
            this.clear();
        } else {
            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }

        // Apply subtle vignette for non-transparent backgrounds
        if (this.settings.background !== 'transparent') {
            this.applyVignette(0.15);
        }
    }

    /**
     * Apply vignette effect
     */
    applyVignette(strength = 0.3) {
        const r2 = Math.max(10, this.maxRadius * 2);
        const gradient = this.ctx.createRadialGradient(
            this.centerX, this.centerY, 0,
            this.centerX, this.centerY, r2
        );

        gradient.addColorStop(0, `rgba(0, 0, 0, 0)`);
        gradient.addColorStop(1, `rgba(0, 0, 0, ${strength})`);

        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }

    /**
     * Parse RGB color string to array
     */
    parseRgbColor(rgbString) {
        const match = rgbString.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (match) {
            return [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];
        }
        return [255, 255, 255]; // Default to white if parsing fails
    }

    /**
     * Get color for bar index
     */
    getColor(index, total) {
        const scheme = COLOR_SCHEMES[this.settings.colorScheme];

        if (!this.settings.gradient || !scheme.gradient) {
            const color = scheme.primary;
            return `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
        }

        // Create gradient
        const t = index / total;

        // Check if we have a 3-color gradient
        if (scheme.tertiary && scheme.colorCount === 3) {
            const color1 = scheme.primary;
            const color2 = scheme.secondary;
            const color3 = scheme.tertiary;

            let r, g, b;

            if (t < 0.5) {
                // Interpolate between primary and secondary (first half)
                const t1 = t * 2; // Map 0-0.5 to 0-1
                r = Math.round(Utils.lerp(color1[0], color2[0], t1));
                g = Math.round(Utils.lerp(color1[1], color2[1], t1));
                b = Math.round(Utils.lerp(color1[2], color2[2], t1));
            } else {
                // Interpolate between secondary and tertiary (second half)
                const t2 = (t - 0.5) * 2; // Map 0.5-1 to 0-1
                r = Math.round(Utils.lerp(color2[0], color3[0], t2));
                g = Math.round(Utils.lerp(color2[1], color3[1], t2));
                b = Math.round(Utils.lerp(color2[2], color3[2], t2));
            }

            return `rgb(${r}, ${g}, ${b})`;
        } else {
            // 2-color gradient
            const color1 = scheme.primary;
            const color2 = scheme.secondary;

            const r = Math.round(Utils.lerp(color1[0], color2[0], t));
            const g = Math.round(Utils.lerp(color1[1], color2[1], t));
            const b = Math.round(Utils.lerp(color1[2], color2[2], t));

            return `rgb(${r}, ${g}, ${b})`;
        }
    }

    /**
     * Apply easing function
     */
    ease(t) {
        return ANIMATION.easing.easeOutCubic(t);
    }

    /**
     * Render frame based on mode
     */
    render(magnitudes) {
        if (!magnitudes) {
            console.error('[Visualizer] No magnitudes provided to render');
            return;
        }

        if (this.frameCounter === 0) {
            console.log('[Visualizer] === First render ===');
            console.log('[Visualizer] Mode:', this.settings.mode);
            console.log('[Visualizer] Canvas:', this.canvas.width + 'x' + this.canvas.height);
            console.log('[Visualizer] Scale factor:', this.scaleFactor);
            console.log('[Visualizer] Canvas element:', this.canvas);
            console.log('[Visualizer] Canvas context:', this.ctx);
            console.log('[Visualizer] Magnitudes length:', magnitudes.length);
            console.log('[Visualizer] Settings:', JSON.stringify(this.settings, null, 2));
        }

        this.drawBackground();

        if (this.frameCounter === 0) {
            console.log('[Visualizer] Background drawn');
        }

        const modeId = this.settings.mode;
        const mode = Object.values(VISUALIZATION_MODES).find(m => m.id === modeId);

        if (!mode) {
            console.warn('[Visualizer] Mode not found:', modeId, '- using circular_bars');
            this.renderCircularBars(magnitudes);
            return;
        }

        try {
            switch (modeId) {
                // Classic Styles
                case 'circular_bars':
                    this.renderCircularBars(magnitudes);
                    break;
            case 'waves':
                this.renderWaves(magnitudes);
                break;
            case 'smooth_waveform':
                this.renderSmoothWaveform(magnitudes);
                break;
            case 'frequency_bars':
                this.renderFrequencyBars(magnitudes);
                break;
            case 'linear_spectrum':
                this.renderLinearSpectrum(magnitudes);
                break;
            case 'classic_particles':
                this.renderClassicParticles(magnitudes);
                break;
            case 'classic_polygon':
                this.renderClassicPolygon(magnitudes);
                break;
            case 'classic_spiral':
                this.renderClassicSpiral(magnitudes);
                break;
            case 'classic_dna_helix':
                this.renderClassicDNAHelix(magnitudes);
                break;
            case 'classic_kaleidoscope':
                this.renderClassicKaleidoscope(magnitudes);
                break;
            case 'classic_pulse_rings':
                this.renderClassicPulseRings(magnitudes);
                break;
            case 'classic_star_burst':
                this.renderClassicStarBurst(magnitudes);
                break;
            case 'classic_bars':
                this.renderClassicBars(magnitudes);
                break;
            case 'mirror_symmetry':
                this.renderMirrorSymmetry(magnitudes);
                break;
            case 'waterfall':
                this.renderWaterfall(magnitudes);
                break;
            case 'converging_lines':
                this.renderConvergingLines(magnitudes);
                break;
            case 'wave_morph':
                this.renderWaveMorph(magnitudes);
                break;
            case 'staggered_pulse':
                this.renderStaggeredPulse(magnitudes);
                break;
            case 'geometric_tunnel':
                this.renderGeometricTunnel(magnitudes);
                break;
            case 'dancing_ribbons':
                this.renderDancingRibbons(magnitudes);
                break;
            case 'particle_stream':
                this.renderParticleStream(magnitudes);
                break;
            case 'glitch_art':
                this.renderGlitchArt(magnitudes);
                break;
            case 'circular_waves':
                this.renderCircularWaves(magnitudes);
                break;
            case 'line_spectrum':
                this.renderLineSpectrum(magnitudes);
                break;
            case 'radial_pulse':
                this.renderRadialPulse(magnitudes);
                break;
            case 'double_helix':
                this.renderDoubleHelix(magnitudes);
                break;
            case 'spiral_bars':
                this.renderSpiralBars(magnitudes);
                break;

            // Particle Effects
            case 'jazzy_fireworks':
                this.renderJazzyFireworks(magnitudes);
                break;
            case 'particles':
                this.renderParticles(magnitudes);
                break;
            case 'fireworks':
                this.renderFireworks(magnitudes);
                break;
            case 'cosmic_dust':
                this.renderCosmicDust(magnitudes);
                break;
            case 'particle_rain':
                this.renderParticleRain(magnitudes);
                break;
            case 'snow_particles':
                this.renderSnowParticles(magnitudes);
                break;
            case 'fog_smoke':
                this.renderFogSmoke(magnitudes);
                break;
            case 'clouds':
                this.renderClouds(magnitudes);
                break;
            case 'aurora_borealis':
                this.renderAuroraBorealis(magnitudes);
                break;
            case 'fireflies':
                this.renderFireflies(magnitudes);
                break;

            // Retro & Vintage
            case 'neon_rain':
                this.renderNeonRain(magnitudes);
                break;
            case 'neon_tubes':
                this.renderNeonTubes(magnitudes);
                break;
            case 'vinyl_grooves':
                this.renderVinylGrooves(magnitudes);
                break;
            case 'pixel_clouds':
                this.renderPixelClouds(magnitudes);
                break;
            case 'neon_cityscape':
                this.renderNeonCityscape(magnitudes);
                break;

            // Fluid & Organic
            case 'soul_aura':
                this.renderSoulAura(magnitudes);
                break;
            case 'liquid_mercury':
                this.renderLiquidMercury(magnitudes);
                break;
            case 'lava_lamp':
                this.renderLavaLamp(magnitudes);
                break;
            case 'ink_drops':
                this.renderInkDrops(magnitudes);
                break;
            case 'water_ripples':
                this.renderWaterRipples(magnitudes);
                break;
            case 'organic_blob':
                this.renderOrganicBlob(magnitudes);
                break;
            case 'neon_contour':
                this.renderNeonContour(magnitudes);
                break;
            case 'circular_spectrum_bars':
                this.renderCircularSpectrumBars(magnitudes);
                break;
            case 'vinyl_record':
                this.renderVinylRecord(magnitudes);
                break;
            case 'pulse_ring':
                this.renderPulseRing(magnitudes);
                break;
            case 'sunburst_arc':
                this.renderSunburstArc(magnitudes);
                break;
            case 'gradient_waveform_circle':
                this.renderGradientWaveformCircle(magnitudes);
                break;
            case 'plasma_vortex':
                this.renderPlasmaVortex(magnitudes);
                break;
            case 'bubble_stream':
                this.renderBubbleStream(magnitudes);
                break;
            case 'minimal_audio_ring':
                this.renderMinimalAudioRing(magnitudes);
                break;
            case 'triangle_spectrum':
                this.renderTriangleSpectrum(magnitudes);
                break;
            case 'wavy_cloud_ring':
                this.renderWavyCloudRing(magnitudes);
                break;

            // Nature & Ethereal
            case 'aurora_waves':
                this.renderAuroraWaves(magnitudes);
                break;
            case 'crystal_growth':
                this.renderCrystalGrowth(magnitudes);
                break;
            case 'frequency_flowers':
                this.renderFrequencyFlowers(magnitudes);
                break;
            case 'fire_dance':
                this.renderFireDance(magnitudes);
                break;
            case 'bioluminescence':
                this.renderBioluminescence(magnitudes);
                break;

            // Geometric & Mathematical
            case 'mandala_growth':
                this.renderMandalaGrowth(magnitudes);
                break;
            case 'kaleidoscope':
                this.renderKaleidoscope(magnitudes);
                break;
            case 'fractal_bloom':
                this.renderFractalBloom(magnitudes);
                break;
            case 'morphing_geometry':
                this.renderMorphingGeometry(magnitudes);
                break;
            case 'spiral_galaxy':
                this.renderSpiralGalaxy(magnitudes);
                break;

            // Scientific & Physics
            case 'dna_helix':
                this.renderDnaHelix(magnitudes);
                break;
            case 'quantum_strings':
                this.renderQuantumStrings(magnitudes);
                break;
            case 'magnetic_fields':
                this.renderMagneticFields(magnitudes);
                break;
            case 'gravitational_lens':
                this.renderGravitationalLens(magnitudes);
                break;
            case 'seismic_waves':
                this.renderSeismicWaves(magnitudes);
                break;
            case 'particle_accelerator':
                this.renderParticleAccelerator(magnitudes);
                break;
            case 'neural_network':
                this.renderNeuralNetwork(magnitudes);
                break;
            case 'quantum_entanglement':
                this.renderQuantumEntanglement(magnitudes);
                break;
            case 'crystal_lattice':
                this.renderCrystalLattice(magnitudes);
                break;
            case 'bioluminescence_wave':
                this.renderBioluminescenceWave(magnitudes);
                break;
            case 'electromagnetic_spectrum':
                this.renderElectromagneticSpectrum(magnitudes);
                break;
            case 'solar_corona':
                this.renderSolarCorona(magnitudes);
                break;
            case 'cytoplasm_flow':
                this.renderCytoplasmFlow(magnitudes);
                break;

            // Tech & Futuristic
            case 'tunnel_vision':
                this.renderTunnelVision(magnitudes);
                break;
            case 'matrix_code':
                this.renderMatrixCode(magnitudes);
                break;
            case 'hologram_glitch':
                this.renderHologramGlitch(magnitudes);
                break;
            case 'circuit_board':
                this.renderCircuitBoard(magnitudes);
                break;
            case 'neural_network':
                this.renderNeuralNetwork(magnitudes);
                break;

            // Energy & Abstract
            case 'lightning_strikes':
                this.renderLightningStrikes(magnitudes);
                break;
            case 'plasma_storm':
                this.renderPlasmaStorm(magnitudes);
                break;
            case 'laser_show':
                this.renderLaserShow(magnitudes);
                break;
            case 'energy_pulses':
                this.renderEnergyPulses(magnitudes);
                break;
            case 'rainbow_prism':
                this.renderRainbowPrism(magnitudes);
                break;
            case 'voltage_surge':
                this.renderVoltageSurge(magnitudes);
                break;
            case 'particle_accelerator':
                this.renderParticleAccelerator(magnitudes);
                break;
            case 'supernova_burst':
                this.renderSupernovaBurst(magnitudes);
                break;
            case 'electric_web':
                this.renderElectricWeb(magnitudes);
                break;
            case 'kinetic_shockwave':
                this.renderKineticShockwave(magnitudes);
                break;

            // Extended Modes (51-60)
            case 'fractal_tree':
                this.renderFractalTree(magnitudes);
                break;
            case 'cityscape_extrusion':
                this.renderCityscapeExtrusion(magnitudes);
                break;
            case 'gravity_well':
                this.renderGravityWell(magnitudes);
                break;
            case 'metaball_fluid':
                this.renderMetaballFluid(magnitudes);
                break;
            case 'aurora_borealis':
                this.renderAuroraBorealis(magnitudes);
                break;
            case 'stained_glass':
                this.renderStainedGlass(magnitudes);
                break;
            case 'glitch_artifact':
                this.renderGlitchArtifact(magnitudes);
                break;
            case 'warp_tunnel':
                this.renderWarpTunnel(magnitudes);
                break;
            case 'conway_life':
                this.renderConwayLife(magnitudes);
                break;

            // Extended Modes (61-70)
            case 'ascii_art':
                this.renderAsciiArt(magnitudes);
                break;
            case 'rippling_water':
                this.renderRipplingWater(magnitudes);
                break;
            case 'terrain_flyover':
                this.renderTerrainFlyover(magnitudes);
                break;
            case 'string_art':
                this.renderStringArt(magnitudes);
                break;
            case 'fire_embers':
                this.renderFireEmbers(magnitudes);
                break;
            case 'radial_kaleidoscope':
                this.renderRadialKaleidoscope(magnitudes);
                break;
            case 'orbital_system':
                this.renderOrbitalSystem(magnitudes);
                break;
            case 'spectrum_cube':
                this.renderSpectrumCube(magnitudes);
                break;
            case 'typographic_flow':
                this.renderTypographicFlow(magnitudes);
                break;
            case 'sonar_ping':
                this.renderSonarPing(magnitudes);
                break;
            case 'vu_meters':
                this.renderVUMeters(magnitudes);
                break;
            case 'lightning_cloud':
                this.renderLightningCloud(magnitudes);
                break;
            case 'bouncing_balls':
                this.renderBouncingBalls(magnitudes);
                break;
            case 'liquid_ink':
                this.renderLiquidInk(magnitudes);
                break;
            case 'stereo_landscape':
                this.renderStereoLandscape(magnitudes);
                break;
            case 'ai_latent_walk':
                this.renderAILatentWalk(magnitudes);
                break;
            case 'pixel_storm':
                this.renderPixelStorm(magnitudes);
                break;
            case 'growing_vine':
                this.renderGrowingVine(magnitudes);
                break;
            case 'haunted_faces':
                this.renderHauntedFaces(magnitudes);
                break;
            case 'connecting_constellations':
                this.renderConnectingConstellations(magnitudes);
                break;
            case 'matrix_rain':
                this.renderMatrixRain(magnitudes);
                break;
            case 'voxel_world':
                this.renderVoxelWorld(magnitudes);
                break;
            case 'dna_helix_rungs':
                this.renderDNAHelixRungs(magnitudes);
                break;
            case 'audio_reactive_shader':
                this.renderAudioReactiveShader(magnitudes);
                break;
            case 'spirograph':
                this.renderSpirograph(magnitudes);
                break;
            case 'equalizer_tower':
                this.renderEqualizerTower(magnitudes);
                break;
            case 'audio_driven_doodles':
                this.renderAudioDrivenDoodles(magnitudes);
                break;
            case 'firework_show':
                this.renderFireworkShow(magnitudes);
                break;
            case 'microscopic_view':
                this.renderMicroscopicView(magnitudes);
                break;
            case 'burning_paper':
                this.renderBurningPaper(magnitudes);
                break;
            case 'swarm_intelligence':
                this.renderSwarmIntelligence(magnitudes);
                break;
            case 'pendulum_wave':
                this.renderPendulumWave(magnitudes);
                break;
            case 'retro_scanlines':
                this.renderRetroScanlines(magnitudes);
                break;
            case 'pulsing_polygon':
                this.renderPulsingPolygon(magnitudes);
                break;
            case 'chromatic_orb':
                this.renderChromaticOrb(magnitudes);
                break;
            case 'textured_bars':
                this.renderTexturedBars(magnitudes);
                break;
            case 'voronoi_tessellation':
                this.renderVoronoiTessellation(magnitudes);
                break;
            case 'shattering_glass':
                this.renderShatteringGlass(magnitudes);
                break;
            case 'sunrise_sunset':
                this.renderSunriseSunset(magnitudes);
                break;
            case 'neural_pulse':
                this.renderNeuralPulse(magnitudes);
                break;
            case 'liquid_mercury':
                this.renderLiquidMercury(magnitudes);
                break;
            case 'cosmic_strings':
                this.renderCosmicStrings(magnitudes);
                break;
            case 'particle_swarm':
                this.renderParticleSwarm(magnitudes);
                break;
            case 'crystal_lattice':
                this.renderCrystalLattice(magnitudes);
                break;

            case 'mode_106_aurora_waves':
                this.renderAuroraWaves(magnitudes);
                break;
            case 'mode_107_dna_helix':
                this.render107DnaHelix(magnitudes);
                break;
            case 'mode_108_fractal_bloom':
                this.render108FractalBloom(magnitudes);
                break;
            case 'mode_109_circuit_board':
                this.render109CircuitBoard(magnitudes);
                break;
            case 'mode_110_quantum_field':
                this.render110QuantumField(magnitudes);
                break;
            case 'mode_111_origami_unfold':
                this.render111OrigamiUnfold(magnitudes);
                break;
            case 'mode_112_galaxy_spiral':
                this.render112GalaxySpiral(magnitudes);
                break;
            case 'mode_113_rubber_bands':
                this.render113RubberBands(magnitudes);
                break;
            case 'mode_114_ink_diffusion':
                this.render114InkDiffusion(magnitudes);
                break;
            case 'mode_115_geometric_kaleidoscope':
                this.render115GeometricKaleidoscope(magnitudes);
                break;
            case 'mode_116_lightning_storm':
                this.render116LightningStorm(magnitudes);
                break;
            case 'mode_117_cellular_growth':
                this.render117CellularGrowth(magnitudes);
                break;
            case 'mode_118_sound_ribbons':
                this.render118SoundRibbons(magnitudes);
                break;
            case 'mode_119_matrix_rain':
                this.render119MatrixRain(magnitudes);
                break;
            case 'mode_120_fire_mandala':
                this.render120FireMandala(magnitudes);
                break;
            case 'mode_121_tessellation_shift':
                this.render121TessellationShift(magnitudes);
                break;
            case 'mode_122_seismic_waves':
                this.render122SeismicWaves(magnitudes);
                break;
            case 'mode_123_neon_city':
                this.render123NeonCity(magnitudes);
                break;
            case 'mode_124_magnetic_field':
                this.render124MagneticField(magnitudes);
                break;
            case 'mode_125_bubble_fusion':
                this.render125BubbleFusion(magnitudes);
                break;
            case 'mode_126_tribal_drums':
                this.render126TribalDrums(magnitudes);
                break;
            case 'mode_127_glass_shatter':
                this.render127GlassShatter(magnitudes);
                break;
            case 'mode_128_bioluminescence':
                this.render128Bioluminescence(magnitudes);
                break;
            case 'mode_129_sound_architecture':
                this.render129SoundArchitecture(magnitudes);
                break;
            case 'mode_130_plasma_ball':
                this.render130PlasmaBall(magnitudes);
                break;
            case 'mode_131_sand_mandala':
                this.render131SandMandala(magnitudes);
                break;
            case 'mode_132_laser_show':
                this.render132LaserShow(magnitudes);
                break;
            case 'mode_133_coral_reef':
                this.render133CoralReef(magnitudes);
                break;
            case 'mode_134_wireframe_morph':
                this.render134WireframeMorph(magnitudes);
                break;
            case 'mode_135_sound_garden':
                this.render135SoundGarden(magnitudes);
                break;
            case 'mode_136_hologram_glitch':
                this.render136HologramGlitch(magnitudes);
                break;
            case 'mode_137_pendulum_wave':
                this.render137PendulumWave(magnitudes);
                break;
            case 'mode_138_volcano_eruption':
                this.render138VolcanoEruption(magnitudes);
                break;
            case 'mode_139_butterfly_effect':
                this.render139ButterflyEffect(magnitudes);
                break;
            case 'mode_140_silk_weaving':
                this.render140SilkWeaving(magnitudes);
                break;
            case 'mode_141_clock_gears':
                this.render141ClockGears(magnitudes);
                break;
            case 'mode_142_smoke_signals':
                this.render142SmokeSignals(magnitudes);
                break;
            case 'mode_143_stained_glass':
                this.render143StainedGlass(magnitudes);
                break;
            case 'mode_144_string_theory':
                this.render144StringTheory(magnitudes);
                break;
            case 'mode_145_paper_craft':
                this.render145PaperCraft(magnitudes);
                break;
            case 'mode_146_northern_lights':
                this.render146NorthernLights(magnitudes);
                break;
            case 'mode_147_cellular_automata':
                this.render147CellularAutomata(magnitudes);
                break;
            case 'mode_148_dragon_curve':
                this.render148DragonCurve(magnitudes);
                break;
            case 'mode_149_rain_circles':
                this.render149RainCircles(magnitudes);
                break;
            case 'mode_150_fourier_epicycles':
                this.render150FourierEpicycles(magnitudes);
                break;
            case 'mode_151_neon_halo_burst':
                this.render151NeonHaloBurst(magnitudes);
                break;
            case 'mode_152_twin_orbiters':
                this.render152TwinOrbiters(magnitudes);
                break;
            case 'mode_153_bar_spiral_galaxy':
                this.render153BarSpiralGalaxy(magnitudes);
                break;
            case 'mode_154_ribbon_wave':
                this.render154RibbonWave(magnitudes);
                break;
            case 'mode_155_voxel_city':
                this.render155VoxelCity(magnitudes);
                break;
            case 'mode_156_sunburst_dial':
                this.render156SunburstDial(magnitudes);
                break;
            case 'mode_157_waterline_oscilloscope':
                this.render157WaterlineOscilloscope(magnitudes);
                break;
            case 'mode_158_laser_tunnel':
                this.render158LaserTunnel(magnitudes);
                break;
            case 'mode_159_vector_field_sprites':
                this.render159VectorFieldSprites(magnitudes);
                break;
            case 'mode_160_orbit_rings_meter':
                this.render160OrbitRingsMeter(magnitudes);
                break;
            case 'mode_161_stitch_bars':
                this.render161StitchBars(magnitudes);
                break;
            case 'mode_162_aurora_curtain':
                this.render162AuroraCurtain(magnitudes);
                break;
            case 'mode_164_polygon_heartbeat':
                this.render164PolygonHeartbeat(magnitudes);
                break;
            case 'mode_165_confetti_impulse':
                this.render165ConfettiImpulse(magnitudes);
                break;
            case 'mode_166_wireframe_dome':
                this.render166WireframeDome(magnitudes);
                break;
            case 'mode_167_pulse_dashes':
                this.render167PulseDashes(magnitudes);
                break;
            case 'mode_168_terrain_sweep':
                this.render168TerrainSweep(magnitudes);
                break;
            case 'mode_169_chromatic_bars_mirror':
                this.render169ChromaticBarsMirror(magnitudes);
                break;
            case 'mode_170_bubble_choir':
                this.render170BubbleChoir(magnitudes);
                break;
            case 'mode_171_starfield_quantizer':
                this.render171StarfieldQuantizer(magnitudes);
                break;
            case 'mode_172_dna_ladder':
                this.render172DnaLadder(magnitudes);
                break;
            case 'mode_173_arc_meter_trio':
                this.render173ArcMeterTrio(magnitudes);
                break;
            case 'mode_174_ink_splatter_scope':
                this.render174InkSplatterScope(magnitudes);
                break;
            case 'mode_175_hex_cell_bloom':
                this.render175HexCellBloom(magnitudes);
                break;
            case 'mode_176_event_horizon_lattice':
                this.render176EventHorizonLattice(magnitudes);
                break;
            case 'mode_177_comet_conveyor':
                this.render177CometConveyor(magnitudes);
                break;
            case 'mode_178_quantum_foam_micro':
                this.render178QuantumFoamMicro(magnitudes);
                break;
            case 'mode_179_aurora_crown':
                this.render179AuroraCrown(magnitudes);
                break;
            case 'mode_180_asteroid_excavator':
                this.render180AsteroidExcavator(magnitudes);
                break;
            case 'mode_181_hyperloop_spectrotrain':
                this.render181HyperloopSpectrotrain(magnitudes);
                break;
            case 'mode_182_galactic_pinball':
                this.render182GalacticPinball(magnitudes);
                break;
            case 'mode_183_nebula_inkblot':
                this.render183NebulaInkblot(magnitudes);
                break;
            case 'mode_184_satellite_telemetry_rings':
                this.render184SatelliteTelemetryRings(magnitudes);
                break;
            case 'mode_185_wormhole_origami':
                this.render185WormholeOrigami(magnitudes);
                break;
            case 'mode_186_holographic_jellyfish':
                this.render186HolographicJellyfish(magnitudes);
                break;
            case 'mode_187_moon_quarry_crane':
                this.render187MoonQuarryCrane(magnitudes);
                break;
            case 'mode_188_constellation_typoplot':
                this.render188ConstellationTypoplot(magnitudes);
                break;
            case 'mode_189_cryo_crystal_garden':
                this.render189CryoCrystalGarden(magnitudes);
                break;
            case 'mode_190_meteorite_blueprint':
                this.render190MeteoriteBlueprint(magnitudes);
                break;
            case 'mode_191_lunar_tide_pool':
                this.render191LunarTidePool(magnitudes);
                break;
            case 'mode_192_orbital_barcode_slicer':
                this.render192OrbitalBarcodeSlicer(magnitudes);
                break;
            case 'mode_193_satellite_swarm_flocking':
                this.render193SatelliteSwarmFlocking(magnitudes);
                break;
            case 'mode_194_astro_pulse_weave':
                this.render194AstroPulseWeave(magnitudes);
                break;
            case 'mode_195_zero_g_paint_spheres':
                this.render195ZeroGPaintSpheres(magnitudes);
                break;
            case 'mode_196_supernova_countdown':
                this.render196SupernovaCountdown(magnitudes);
                break;
            case 'mode_197_martian_wind_harp':
                this.render197MartianWindHarp(magnitudes);
                break;
            case 'mode_198_teleporting_bar_choir':
                this.render198TeleportingBarChoir(magnitudes);
                break;
            case 'mode_199_cosmic_vinyl_halo':
                this.render199CosmicVinylHalo(magnitudes);
                break;
            case 'mode_200_photon_origination_chamber':
                this.render200PhotonOriginationChamber(magnitudes);
                break;
            case 'mode_201_meteor_net':
                this.render201Meteornet(magnitudes);
                break;
            case 'mode_202_deep_space_garden_hose':
                this.render202DeepSpaceGardenHose(magnitudes);
                break;
            case 'mode_203_horizon_monoliths':
                this.render203HorizonMonoliths(magnitudes);
                break;
            case 'mode_204_gravity_slingshot_trails':
                this.render204GravitySlingshotTrails(magnitudes);
                break;
            case 'mode_205_solar_flare_notches':
                this.render205SolarFlareNotches(magnitudes);
                break;
            case 'mode_206_tesseract_window':
                this.render206TesseractWindow(magnitudes);
                break;
            case 'mode_207_interstellar_postcards':
                this.render207InterstellarPostcards(magnitudes);
                break;
            case 'mode_208_cosmic_braille':
                this.render208CosmicBraille(magnitudes);
                break;
            case 'mode_209_stellar_harpoon':
                this.render209StellarHarpoon(magnitudes);
                break;
            case 'mode_210_galaxy_ticker_tape':
                this.render210GalaxyTickerTape(magnitudes);
                break;
            case 'mode_211_antimatter_chess':
                this.render211AntimatterChess(magnitudes);
                break;
            case 'mode_212_star_nursery_conveyor':
                this.render212StarNurseryConveyor(magnitudes);
                break;
            case 'mode_213_magnetar_lines':
                this.render213MagnetarLines(magnitudes);
                break;
            case 'mode_214_zero_kelvin_diamonds':
                this.render214ZeroKelvinDiamonds(magnitudes);
                break;
            case 'mode_215_orbital_time_garden':
                this.render215OrbitalTimeGarden(magnitudes);
                break;
            case 'mode_216_subspace_ribbon_printer':
                this.render216SubspaceRibbonPrinter(magnitudes);
                break;
            case 'mode_217_dark_matter_drizzle':
                this.render217DarkMatterDrizzle(magnitudes);
                break;
            case 'mode_218_meteor_choir_cones':
                this.render218MeteorChoirCones(magnitudes);
                break;
            case 'mode_219_folded_galaxy_map':
                this.render219FoldedGalaxyMap(magnitudes);
                break;
            case 'mode_220_ion_thruster_plume':
                this.render220IonThrusterPlume(magnitudes);
                break;
            case 'mode_221_cosmic_dominoes':
                this.render221CosmicDominoes(magnitudes);
                break;
            case 'mode_222_spacesuit_hud':
                this.render222SpacesuitHud(magnitudes);
                break;
            case 'mode_223_pulsar_barcode_beam':
                this.render223PulsarBarcodeBeam(magnitudes);
                break;
            case 'mode_224_astro_terrarium':
                this.render224AstroTerrarium(magnitudes);
                break;
            case 'mode_225_micrometeor_spark_curtain':
                this.render225MicrometeorSparkCurtain(magnitudes);
                break;
            case 'mode_276_quantum_lattice':
                this.render276QuantumLattice(magnitudes);
                break;
            case 'mode_277_prism_rays':
                this.render277PrismRays(magnitudes);
                break;
            case 'mode_278_liquid_nitrogen':
                this.render278LiquidNitrogen(magnitudes);
                break;
            case 'mode_279_silk_road_caravan':
                this.render279SilkRoadCaravan(magnitudes);
                break;
            case 'mode_280_steampunk_gears':
                this.render280SteampunkGears(magnitudes);
                break;
            case 'mode_281_dragon_scales':
                this.render281DragonScales(magnitudes);
                break;
            case 'mode_282_time_dilation_grid':
                this.render282TimeDilationGrid(magnitudes);
                break;
            case 'mode_283_fiber_bundle':
                this.render283FiberBundle(magnitudes);
                break;
            case 'mode_284_moth_wing_shimmer':
                this.render284MothWingShimmer(magnitudes);
                break;
            case 'mode_285_cathedral_rose':
                this.render285CathedralRose(magnitudes);
                break;
            case 'mode_286_neon_veins_pulse':
                this.render286NeonVeinsPulse(magnitudes);
                break;
            case 'mode_287_glacial_crack':
                this.render287GlacialCrack(magnitudes);
                break;
            case 'mode_288_quantum_dots':
                this.render288QuantumDots(magnitudes);
                break;
            case 'mode_289_origami_crane_flight':
                this.render289OrigamiCraneFlight(magnitudes);
                break;
            case 'mode_290_magma_chamber':
                this.render290MagmaChamber(magnitudes);
                break;
            case 'mode_291_spider_web_dew':
                this.render291SpiderWebDew(magnitudes);
                break;
            case 'mode_292_nebula_birth':
                this.render292NebulaBirth(magnitudes);
                break;
            case 'mode_293_circuit_board_live':
                this.render293CircuitBoardLive(magnitudes);
                break;
            case 'mode_294_bioluminescent_tide':
                this.render294BioluminescentTide(magnitudes);
                break;
            case 'mode_295_tesseract_projection':
                this.render295TesseractProjection(magnitudes);
                break;
            case 'mode_296_frost_crystal_growth':
                this.render296FrostCrystalGrowth(magnitudes);
                break;
            case 'mode_297_sound_wave_interference':
                this.render297SoundWaveInterference(magnitudes);
                break;
            case 'mode_298_holographic_fracture':
                this.render298HolographicFracture(magnitudes);
                break;
            case 'mode_299_plasma_ball_arc':
                this.render299PlasmaBallArc(magnitudes);
                break;
            case 'mode_300_eternal_flame_dance':
                this.render300EternalFlameDance(magnitudes);
                break;
            case 'mode_301_forest_canopy':
                this.render301ForestCanopy(magnitudes);
                break;
            case 'mode_302_ocean_waves':
                this.render302OceanWaves(magnitudes);
                break;
            case 'mode_303_coral_reef':
                this.render303CoralReef(magnitudes);
                break;
            case 'mode_304_butterfly_swarm':
                this.render304ButterflySwarm(magnitudes);
                break;
            case 'mode_305_mountain_peaks':
                this.render305MountainPeaks(magnitudes);
                break;
            case 'mode_306_fireflies':
                this.render306Fireflies(magnitudes);
                break;
            case 'mode_307_flower_bloom':
                this.render307FlowerBloom(magnitudes);
                break;
            case 'mode_308_rain_ripples':
                this.render308RainRipples(magnitudes);
                break;
            case 'mode_309_leaf_fall':
                this.render309LeafFall(magnitudes);
                break;
            case 'mode_310_tree_rings':
                this.render310TreeRings(magnitudes);
                break;
            case 'mode_311_lightning_storm':
                this.render311LightningStorm(magnitudes);
                break;
            case 'mode_312_pond_koi':
                this.render312PondKoi(magnitudes);
                break;
            case 'mode_313_moss_growth':
                this.render313MossGrowth(magnitudes);
                break;
            case 'mode_314_aurora_forest':
                this.render314AuroraForest(magnitudes);
                break;
            case 'mode_315_dandelion_seeds':
                this.render315DandelionSeeds(magnitudes);
                break;
            case 'mode_316_fern_fractals':
                this.render316FernFractals(magnitudes);
                break;
            case 'mode_317_beehive_cells':
                this.render317BeehiveCells(magnitudes);
                break;
            case 'mode_318_wheat_field':
                this.render318WheatField(magnitudes);
                break;
            case 'mode_319_spider_web':
                this.render319SpiderWeb(magnitudes);
                break;
            case 'mode_320_mushroom_spores':
                this.render320MushroomSpores(magnitudes);
                break;
            case 'mode_321_bamboo_forest':
                this.render321BambooForest(magnitudes);
                break;
            case 'mode_322_tide_pools':
                this.render322TidePools(magnitudes);
                break;
            case 'mode_323_vine_tendrils':
                this.render323VineTendrils(magnitudes);
                break;
            case 'mode_324_crystal_cave':
                this.render324CrystalCave(magnitudes);
                break;
            case 'mode_325_bird_murmuration':
                this.render325BirdMurmuration(magnitudes);
                break;
            case 'mode_326_river_flow':
                this.render326RiverFlow(magnitudes);
                break;
            case 'mode_327_seed_pods':
                this.render327SeedPods(magnitudes);
                break;
            case 'mode_328_algae_bloom':
                this.render328AlgaeBloom(magnitudes);
                break;
            case 'mode_329_cactus_spines':
                this.render329CactusSpines(magnitudes);
                break;
            case 'mode_330_snowflakes':
                this.render330Snowflakes(magnitudes);
                break;
            case 'mode_331_lava_flow':
                this.render331LavaFlow(magnitudes);
                break;
            case 'mode_332_ice_crystals':
                this.render332IceCrystals(magnitudes);
                break;
            case 'mode_333_pine_cones':
                this.render333PineCones(magnitudes);
                break;
            case 'mode_334_geyser_eruption':
                this.render334GeyserEruption(magnitudes);
                break;
            case 'mode_335_pollen_cloud':
                this.render335PollenCloud(magnitudes);
                break;
            case 'mode_336_desert_dunes':
                this.render336DesertDunes(magnitudes);
                break;
            case 'mode_337_lily_pads':
                this.render337LilyPads(magnitudes);
                break;
            case 'mode_338_termite_mound':
                this.render338TermiteMound(magnitudes);
                break;
            case 'mode_339_cherry_blossoms':
                this.render339CherryBlossoms(magnitudes);
                break;
            case 'mode_340_root_system':
                this.render340RootSystem(magnitudes);
                break;
            case 'mode_341_plankton_swarm':
                this.render341PlanktonSwarm(magnitudes);
                break;
            case 'mode_342_frost_patterns':
                this.render342FrostPatterns(magnitudes);
                break;
            case 'mode_343_ant_trails':
                this.render343AntTrails(magnitudes);
                break;
            case 'mode_344_seaweed_sway':
                this.render344SeaweedSway(magnitudes);
                break;
            case 'mode_345_volcano_ash':
                this.render345VolcanoAsh(magnitudes);
                break;
            case 'mode_346_dragonfly_wings':
                this.render346DragonflyWings(magnitudes);
                break;
            case 'mode_347_pebble_ripples':
                this.render347PebbleRipples(magnitudes);
                break;
            case 'mode_348_moss_tendrils':
                this.render348MossTendrils(magnitudes);
                break;
            case 'mode_349_starfish_arms':
                this.render349StarfishArms(magnitudes);
                break;
            case 'mode_350_venus_flytrap':
                this.render350VenusFlytrap(magnitudes);
                break;
            case 'mode_351_rainbow_mist':
                this.render351RainbowMist(magnitudes);
                break;
            case 'mode_352_geode_crystals':
                this.render352GeodeCrystals(magnitudes);
                break;
            case 'mode_353_snake_scales':
                this.render353SnakeScales(magnitudes);
                break;
            case 'mode_354_whirlpool':
                this.render354Whirlpool(magnitudes);
                break;
            case 'mode_355_owl_eyes':
                this.render355OwlEyes(magnitudes);
                break;
            case 'mode_356_tornado_funnel':
                this.render356TornadoFunnel(magnitudes);
                break;
            case 'mode_357_peacock_feathers':
                this.render357PeacockFeathers(magnitudes);
                break;
            case 'mode_358_jellyfish_pulse':
                this.render358JellyfishPulse(magnitudes);
                break;
            case 'mode_359_sand_ripples':
                this.render359SandRipples(magnitudes);
                break;
            case 'mode_360_bat_swarm':
                this.render360BatSwarm(magnitudes);
                break;
            case 'mode_361_tide_motion':
                this.render361TideMotion(magnitudes);
                break;
            case 'mode_362_lichen_growth':
                this.render362LichenGrowth(magnitudes);
                break;
            case 'mode_363_eagle_soar':
                this.render363EagleSoar(magnitudes);
                break;
            case 'mode_364_mangrove_roots':
                this.render364MangroveRoots(magnitudes);
                break;
            case 'mode_365_aurora_waves':
                this.render365AuroraWaves(magnitudes);
                break;
            case 'mode_366_dolphin_leap':
                this.render366DolphinLeap(magnitudes);
                break;
            case 'mode_367_tumbleweed_roll':
                this.render367TumbleweedRoll(magnitudes);
                break;
            case 'mode_368_coral_polyps':
                this.render368CoralPolyps(magnitudes);
                break;
            case 'mode_369_smoke_wisps':
                this.render369SmokeWisps(magnitudes);
                break;
            case 'mode_370_nautilus_shell':
                this.render370NautilusShell(magnitudes);
                break;
            case 'mode_371_wolf_howl':
                this.render371WolfHowl(magnitudes);
                break;
            case 'mode_372_seashell_patterns':
                this.render372SeashellPatterns(magnitudes);
                break;
            case 'mode_373_grass_blades':
                this.render373GrassBlades(magnitudes);
                break;
            case 'mode_374_stalactites':
                this.render374Stalactites(magnitudes);
                break;
            case 'mode_375_amoeba_movement':
                this.render375AmoebaMovement(magnitudes);
                break;
            case 'mode_376_pine_needles':
                this.render376PineNeedles(magnitudes);
                break;
            case 'mode_377_water_droplet':
                this.render377WaterDroplet(magnitudes);
                break;
            case 'mode_378_succulent_rosette':
                this.render378SucculentRosette(magnitudes);
                break;
            case 'mode_379_salmon_upstream':
                this.render379SalmonUpstream(magnitudes);
                break;
            case 'mode_380_cloud_formation':
                this.render380CloudFormation(magnitudes);
                break;
            case 'mode_381_fox_tail':
                this.render381FoxTail(magnitudes);
                break;
            case 'mode_382_clover_field':
                this.render382CloverField(magnitudes);
                break;
            case 'mode_383_geyser_field':
                this.render383GeyserField(magnitudes);
                break;
            case 'mode_384_insect_compound_eye':
                this.render384InsectCompoundEye(magnitudes);
                break;
            case 'mode_385_moonflower_bloom':
                this.render385MoonflowerBloom(magnitudes);
                break;
            case 'mode_386_sand_dollar':
                this.render386SandDollar(magnitudes);
                break;
            case 'mode_387_glacier_crevasse':
                this.render387GlacierCrevasse(magnitudes);
                break;
            case 'mode_388_antler_growth':
                this.render388AntlerGrowth(magnitudes);
                break;
            case 'mode_389_plume_worm':
                this.render389PlumeWorm(magnitudes);
                break;
            case 'mode_390_reed_marsh':
                this.render390ReedMarsh(magnitudes);
                break;
            case 'mode_391_beetle_shell':
                this.render391BeetleShell(magnitudes);
                break;
            case 'mode_392_tide_anemone':
                this.render392TideAnemone(magnitudes);
                break;
            case 'mode_393_earthquake_waves':
                this.render393EarthquakeWaves(magnitudes);
                break;
            case 'mode_394_butterfly_lifecycle':
                this.render394ButterflyLifecycle(magnitudes);
                break;
            case 'mode_395_coconut_palm':
                this.render395CoconutPalm(magnitudes);
                break;
            case 'mode_396_frost_ferns':
                this.render396FrostFerns(magnitudes);
                break;
            case 'mode_397_bioluminescent_bay':
                this.render397BioluminescentBay(magnitudes);
                break;
            case 'mode_398_erosion_patterns':
                this.render398ErosionPatterns(magnitudes);
                break;
            case 'mode_399_hedge_maze':
                this.render399HedgeMaze(magnitudes);
                break;
            case 'mode_400_water_lily_reflection':
                this.render400WaterLilyReflection(magnitudes);
                break;
            case 'mode_401_atom_model':
                this.render401AtomModel(magnitudes);
                break;
            case 'mode_402_double_helix':
                this.render402DoubleHelix(magnitudes);
                break;
            case 'mode_403_magnetic_field':
                this.render403MagneticField(magnitudes);
                break;
            case 'mode_404_wave_interference':
                this.render404WaveInterference(magnitudes);
                break;
            case 'mode_405_particle_accelerator':
                this.render405ParticleAccelerator(magnitudes);
                break;
            case 'mode_406_crystal_lattice':
                this.render406CrystalLattice(magnitudes);
                break;
            case 'mode_407_electromagnetic_wave':
                this.render407ElectromagneticWave(magnitudes);
                break;
            case 'mode_408_quantum_tunneling':
                this.render408QuantumTunneling(magnitudes);
                break;
            case 'mode_409_fission_reaction':
                this.render409FissionReaction(magnitudes);
                break;
            case 'mode_410_doppler_effect':
                this.render410DopplerEffect(magnitudes);
                break;
            case 'mode_411_gravity_well':
                this.render411GravityWell(magnitudes);
                break;
            case 'mode_412_prism_spectrum':
                this.render412PrismSpectrum(magnitudes);
                break;
            case 'mode_413_molecular_bonds':
                this.render413MolecularBonds(magnitudes);
                break;
            case 'mode_414_standing_wave':
                this.render414StandingWave(magnitudes);
                break;
            case 'mode_415_brownian_motion':
                this.render415BrownianMotion(magnitudes);
                break;
            case 'mode_416_tesla_coil':
                this.render416TeslaCoil(magnitudes);
                break;
            case 'mode_417_phase_transition':
                this.render417PhaseTransition(magnitudes);
                break;
            case 'mode_418_superconductor':
                this.render418Superconductor(magnitudes);
                break;
            case 'mode_419_neuron_firing':
                this.render419NeuronFiring(magnitudes);
                break;
            case 'mode_420_resonance_modes':
                this.render420ResonanceModes(magnitudes);
                break;
            case 'mode_421_fractal_diffusion':
                this.render421FractalDiffusion(magnitudes);
                break;
            case 'mode_422_plasma_ball':
                this.render422PlasmaBall(magnitudes);
                break;
            case 'mode_423_coriolis_effect':
                this.render423CoriolisEffect(magnitudes);
                break;
            case 'mode_424_photoelectric_effect':
                this.render424PhotoelectricEffect(magnitudes);
                break;
            case 'mode_425_lorenz_attractor':
                this.render425LorenzAttractor(magnitudes);
                break;
            case 'mode_426_spin_precession':
                this.render426SpinPrecession(magnitudes);
                break;
            case 'mode_427_compton_scattering':
                this.render427ComptonScattering(magnitudes);
                break;
            case 'mode_428_ferrofluid':
                this.render428Ferrofluid(magnitudes);
                break;
            case 'mode_429_sonoluminescence':
                this.render429Sonoluminescence(magnitudes);
                break;
            case 'mode_430_cherenkov_radiation':
                this.render430CherenkovRadiation(magnitudes);
                break;
            case 'mode_431_hall_effect':
                this.render431HallEffect(magnitudes);
                break;
            case 'mode_432_cymatics':
                this.render432Cymatics(magnitudes);
                break;
            case 'mode_433_klein_bottle':
                this.render433KleinBottle(magnitudes);
                break;
            case 'mode_434_raman_scattering':
                this.render434RamanScattering(magnitudes);
                break;
            case 'mode_435_vortex_shedding':
                this.render435VortexShedding(magnitudes);
                break;
            case 'mode_436_polarization':
                this.render436Polarization(magnitudes);
                break;
            case 'mode_437_higgs_field':
                this.render437HiggsField(magnitudes);
                break;
            case 'mode_438_bose_einstein':
                this.render438BoseEinstein(magnitudes);
                break;
            case 'mode_439_schrodinger_cat':
                this.render439SchrodingerCat(magnitudes);
                break;
            case 'mode_440_string_vibration':
                this.render440StringVibration(magnitudes);
                break;
            case 'mode_441_electron_cloud':
                this.render441ElectronCloud(magnitudes);
                break;
            case 'mode_442_thermoelectric':
                this.render442Thermoelectric(magnitudes);
                break;
            case 'mode_443_photon_entanglement':
                this.render443PhotonEntanglement(magnitudes);
                break;
            case 'mode_444_superfluidity':
                this.render444Superfluidity(magnitudes);
                break;
            case 'mode_445_piezoelectric':
                this.render445Piezoelectric(magnitudes);
                break;
            case 'mode_446_zeeman_effect':
                this.render446ZeemanEffect(magnitudes);
                break;
            case 'mode_447_cyclotron_motion':
                this.render447CyclotronMotion(magnitudes);
                break;
            case 'mode_448_fusion_reactor':
                this.render448FusionReactor(magnitudes);
                break;
            case 'mode_449_antimatter':
                this.render449Antimatter(magnitudes);
                break;
            case 'mode_450_hawking_radiation':
                this.render450HawkingRadiation(magnitudes);
                break;
            case 'mode_451_heisenberg_uncertainty':
                this.render451HeisenbergUncertainty(magnitudes);
                break;
            case 'mode_452_particle_decay':
                this.render452ParticleDecay(magnitudes);
                break;
            case 'mode_453_laser_cavity':
                this.render453LaserCavity(magnitudes);
                break;
            case 'mode_454_dielectric_breakdown':
                this.render454DielectricBreakdown(magnitudes);
                break;
            case 'mode_455_casimir_effect':
                this.render455CasimirEffect(magnitudes);
                break;
            case 'mode_456_sonochemistry':
                this.render456Sonochemistry(magnitudes);
                break;
            case 'mode_457_phonon_propagation':
                this.render457PhononPropagation(magnitudes);
                break;
            case 'mode_458_pair_production':
                this.render458PairProduction(magnitudes);
                break;
            case 'mode_459_stefan_boltzmann':
                this.render459StefanBoltzmann(magnitudes);
                break;
            case 'mode_460_eddy_currents':
                this.render460EddyCurrents(magnitudes);
                break;
            case 'mode_461_wavefunction_collapse':
                this.render461WavefunctionCollapse(magnitudes);
                break;
            case 'mode_462_qed_feynman':
                this.render462QedFeynman(magnitudes);
                break;
            case 'mode_463_holography':
                this.render463Holography(magnitudes);
                break;
            case 'mode_464_metamaterial':
                this.render464Metamaterial(magnitudes);
                break;
            case 'mode_465_photodiode':
                this.render465Photodiode(magnitudes);
                break;
            case 'mode_466_bremsstrahlung':
                this.render466Bremsstrahlung(magnitudes);
                break;
            case 'mode_467_optogenetics':
                this.render467Optogenetics(magnitudes);
                break;
            case 'mode_468_topological_insulator':
                this.render468TopologicalInsulator(magnitudes);
                break;
            case 'mode_469_nernst_equation':
                this.render469NernstEquation(magnitudes);
                break;
            case 'mode_470_mri_precession':
                this.render470MriPrecession(magnitudes);
                break;
            case 'mode_471_josephson_junction':
                this.render471JosephsonJunction(magnitudes);
                break;
            case 'mode_472_liquid_crystal':
                this.render472LiquidCrystal(magnitudes);
                break;
            case 'mode_473_rydberg_atoms':
                this.render473RydbergAtoms(magnitudes);
                break;
            case 'mode_474_cavity_qed':
                this.render474CavityQed(magnitudes);
                break;
            case 'mode_475_quantum_dots':
                this.render475QuantumDots(magnitudes);
                break;
            case 'mode_476_soliton_wave':
                this.render476SolitonWave(magnitudes);
                break;
            case 'mode_477_acoustic_levitation':
                this.render477AcousticLevitation(magnitudes);
                break;
            case 'mode_478_mosfet_channel':
                this.render478MosfetChannel(magnitudes);
                break;
            case 'mode_479_spintronics':
                this.render479Spintronics(magnitudes);
                break;
            case 'mode_480_electrochemistry':
                this.render480Electrochemistry(magnitudes);
                break;
            case 'mode_481_langmuir_wave':
                this.render481LangmuirWave(magnitudes);
                break;
            case 'mode_482_bloch_sphere':
                this.render482BlochSphere(magnitudes);
                break;
            case 'mode_483_curie_temperature':
                this.render483CurieTemperature(magnitudes);
                break;
            case 'mode_484_dyson_sphere':
                this.render484DysonSphere(magnitudes);
                break;
            case 'mode_485_graphene_lattice':
                this.render485GrapheneLattice(magnitudes);
                break;
            case 'mode_486_memristor':
                this.render486Memristor(magnitudes);
                break;
            case 'mode_487_quantum_hall':
                this.render487QuantumHall(magnitudes);
                break;
            case 'mode_488_optomechanics':
                this.render488Optomechanics(magnitudes);
                break;
            case 'mode_489_exciton':
                this.render489Exciton(magnitudes);
                break;
            case 'mode_490_photonic_crystal':
                this.render490PhotonicCrystal(magnitudes);
                break;
            case 'mode_491_skyrmion':
                this.render491Skyrmion(magnitudes);
                break;
            case 'mode_492_mott_insulator':
                this.render492MottInsulator(magnitudes);
                break;
            case 'mode_493_squeezing':
                this.render493Squeezing(magnitudes);
                break;
            case 'mode_494_andreev_reflection':
                this.render494AndreevReflection(magnitudes);
                break;
            case 'mode_495_casimir_polder':
                this.render495CasimirPolder(magnitudes);
                break;
            case 'mode_496_fano_resonance':
                this.render496FanoResonance(magnitudes);
                break;
            case 'mode_497_quantum_zeno':
                this.render497QuantumZeno(magnitudes);
                break;
            case 'mode_498_rabi_oscillation':
                this.render498RabiOscillation(magnitudes);
                break;
            case 'mode_499_aharonov_bohm':
                this.render499AharonovBohm(magnitudes);
                break;
            case 'mode_500_berry_phase':
                this.render500BerryPhase(magnitudes);
                break;
            case 'mode_501_impressionist':
                this.render501Impressionist(magnitudes);
                break;
            case 'mode_502_cubist':
                this.render502Cubist(magnitudes);
                break;
            case 'mode_503_surreal':
                this.render503Surreal(magnitudes);
                break;
            case 'mode_504_abstract_expressionist':
                this.render504AbstractExpressionist(magnitudes);
                break;
            case 'mode_505_pop_art':
                this.render505PopArt(magnitudes);
                break;
            case 'mode_506_minimalist':
                this.render506Minimalist(magnitudes);
                break;
            case 'mode_507_pointillist':
                this.render507Pointillist(magnitudes);
                break;
            case 'mode_508_art_deco':
                this.render508ArtDeco(magnitudes);
                break;
            case 'mode_509_art_nouveau':
                this.render509ArtNouveau(magnitudes);
                break;
            case 'mode_510_bauhaus':
                this.render510Bauhaus(magnitudes);
                break;
            case 'mode_511_futurist':
                this.render511Futurist(magnitudes);
                break;
            case 'mode_512_dadaist':
                this.render512Dadaist(magnitudes);
                break;
            case 'mode_513_expressionist':
                this.render513Expressionist(magnitudes);
                break;
            case 'mode_514_fauvism':
                this.render514Fauvism(magnitudes);
                break;
            case 'mode_515_constructivist':
                this.render515Constructivist(magnitudes);
                break;
            case 'mode_516_suprematist':
                this.render516Suprematist(magnitudes);
                break;
            case 'mode_517_vorticism':
                this.render517Vorticism(magnitudes);
                break;
            case 'mode_518_orphism':
                this.render518Orphism(magnitudes);
                break;
            case 'mode_519_rayonism':
                this.render519Rayonism(magnitudes);
                break;
            case 'mode_520_synchromism':
                this.render520Synchromism(magnitudes);
                break;
            case 'mode_521_precisionism':
                this.render521Precisionism(magnitudes);
                break;
            case 'mode_522_regionalism':
                this.render522Regionalism(magnitudes);
                break;
            case 'mode_523_social_realism':
                this.render523SocialRealism(magnitudes);
                break;
            case 'mode_524_neo_plasticism':
                this.render524NeoPlasticism(magnitudes);
                break;
            case 'mode_525_de_stijl':
                this.render525DeStijl(magnitudes);
                break;
            case 'mode_526_color_field':
                this.render526ColorField(magnitudes);
                break;
            case 'mode_527_hard_edge':
                this.render527HardEdge(magnitudes);
                break;
            case 'mode_528_lyrical_abstraction':
                this.render528LyricalAbstraction(magnitudes);
                break;
            case 'mode_529_tachisme':
                this.render529Tachisme(magnitudes);
                break;
            case 'mode_530_action_painting':
                this.render530ActionPainting(magnitudes);
                break;
            case 'mode_531_stain_painting':
                this.render531StainPainting(magnitudes);
                break;
            case 'mode_532_shaped_canvas':
                this.render532ShapedCanvas(magnitudes);
                break;
            case 'mode_533_monochrome':
                this.render533Monochrome(magnitudes);
                break;
            case 'mode_534_kinetic_art':
                this.render534KineticArt(magnitudes);
                break;
            case 'mode_535_op_art':
                this.render535OpArt(magnitudes);
                break;
            case 'mode_536_light_art':
                this.render536LightArt(magnitudes);
                break;
            case 'mode_537_land_art':
                this.render537LandArt(magnitudes);
                break;
            case 'mode_538_earth_art':
                this.render538EarthArt(magnitudes);
                break;
            case 'mode_539_environmental_art':
                this.render539EnvironmentalArt(magnitudes);
                break;
            case 'mode_540_installation_art':
                this.render540InstallationArt(magnitudes);
                break;
            case 'mode_541_video_art':
                this.render541VideoArt(magnitudes);
                break;
            case 'mode_542_digital_art':
                this.render542DigitalArt(magnitudes);
                break;
            case 'mode_543_glitch_art':
                this.render543GlitchArt(magnitudes);
                break;
            case 'mode_544_pixel_art':
                this.render544PixelArt(magnitudes);
                break;
            case 'mode_545_ascii_art':
                this.render545AsciiArt(magnitudes);
                break;
            case 'mode_546_vector_art':
                this.render546VectorArt(magnitudes);
                break;
            case 'mode_547_fractal_art':
                this.render547FractalArt(magnitudes);
                break;
            case 'mode_548_algorithmic_art':
                this.render548AlgorithmicArt(magnitudes);
                break;
            case 'mode_549_generative_art':
                this.render549GenerativeArt(magnitudes);
                break;
            case 'mode_550_data_art':
                this.render550DataArt(magnitudes);
                break;
            case 'mode_551_bio_art':
                this.render551BioArt(magnitudes);
                break;
            case 'mode_552_net_art':
                this.render552NetArt(magnitudes);
                break;
            case 'mode_553_software_art':
                this.render553SoftwareArt(magnitudes);
                break;
            case 'mode_554_robotic_art':
                this.render554RoboticArt(magnitudes);
                break;
            case 'mode_555_interactive_art':
                this.render555InteractiveArt(magnitudes);
                break;
            case 'mode_556_projection_mapping':
                this.render556ProjectionMapping(magnitudes);
                break;
            case 'mode_557_holographic_art':
                this.render557HolographicArt(magnitudes);
                break;
            case 'mode_558_augmented_reality_art':
                this.render558AugmentedRealityArt(magnitudes);
                break;
            case 'mode_559_vr_art':
                this.render559VrArt(magnitudes);
                break;
            case 'mode_560_procedural_art':
                this.render560ProceduralArt(magnitudes);
                break;
            case 'mode_561_parametric_art':
                this.render561ParametricArt(magnitudes);
                break;
            case 'mode_562_mathematical_art':
                this.render562MathematicalArt(magnitudes);
                break;
            case 'mode_563_geometric_art':
                this.render563GeometricArt(magnitudes);
                break;
            case 'mode_564_tessellation_art':
                this.render564TessellationArt(magnitudes);
                break;
            case 'mode_565_symmetry_art':
                this.render565SymmetryArt(magnitudes);
                break;
            case 'mode_566_kaleidoscope_art':
                this.render566KaleidoscopeArt(magnitudes);
                break;
            case 'mode_567_mandala_art':
                this.render567MandalaArt(magnitudes);
                break;
            case 'mode_568_zentangle_art':
                this.render568ZentangleArt(magnitudes);
                break;
            case 'mode_569_doodle_art':
                this.render569DoodleArt(magnitudes);
                break;
            case 'mode_570_street_art':
                this.render570StreetArt(magnitudes);
                break;
            case 'mode_571_graffiti_art':
                this.render571GraffitiArt(magnitudes);
                break;
            case 'mode_572_mural_art':
                this.render572MuralArt(magnitudes);
                break;
            case 'mode_573_stencil_art':
                this.render573StencilArt(magnitudes);
                break;
            case 'mode_574_wheat_paste_art':
                this.render574WheatPasteArt(magnitudes);
                break;
            case 'mode_575_spray_paint_art':
                this.render575SprayPaintArt(magnitudes);
                break;
            case 'mode_576_mosaic_art':
                this.render576MosaicArt(magnitudes);
                break;
            case 'mode_577_collage_art':
                this.render577CollageArt(magnitudes);
                break;
            case 'mode_578_mixed_media_art':
                this.render578MixedMediaArt(magnitudes);
                break;
            case 'mode_579_assemblage_art':
                this.render579AssemblageArt(magnitudes);
                break;
            case 'mode_580_found_object_art':
                this.render580FoundObjectArt(magnitudes);
                break;
            case 'mode_581_readymade_art':
                this.render581ReadymadeArt(magnitudes);
                break;
            case 'mode_582_appropriation_art':
                this.render582AppropriationArt(magnitudes);
                break;
            case 'mode_583_sampling_art':
                this.render583SamplingArt(magnitudes);
                break;
            case 'mode_584_remix_art':
                this.render584RemixArt(magnitudes);
                break;
            case 'mode_585_mashup_art':
                this.render585MashupArt(magnitudes);
                break;
            case 'mode_586_photomontage':
                this.render586Photomontage(magnitudes);
                break;
            case 'mode_587_cut_up_technique':
                this.render587CutUpTechnique(magnitudes);
                break;
            case 'mode_588_exquisite_corpse':
                this.render588ExquisiteCorpse(magnitudes);
                break;
            case 'mode_589_automatic_drawing':
                this.render589AutomaticDrawing(magnitudes);
                break;
            case 'mode_590_chance_art':
                this.render590ChanceArt(magnitudes);
                break;
            case 'mode_591_indeterminacy_art':
                this.render591IndeterminacyArt(magnitudes);
                break;
            case 'mode_592_aleatory_art':
                this.render592AleatoryArt(magnitudes);
                break;
            case 'mode_593_stochastic_art':
                this.render593StochasticArt(magnitudes);
                break;
            case 'mode_594_entropy_art':
                this.render594EntropyArt(magnitudes);
                break;
            case 'mode_595_chaos_art':
                this.render595ChaosArt(magnitudes);
                break;
            case 'mode_596_complexity_art':
                this.render596ComplexityArt(magnitudes);
                break;
            case 'mode_597_emergence_art':
                this.render597EmergenceArt(magnitudes);
                break;
            case 'mode_598_self_organization_art':
                this.render598SelfOrganizationArt(magnitudes);
                break;
            case 'mode_599_swarm_art':
                this.render599SwarmArt(magnitudes);
                break;
            case 'mode_600_flocking_art':
                this.render600FlockingArt(magnitudes);
                break;
            case 'mode_601_nebula':
                this.render601Nebula(magnitudes);
                break;
            case 'mode_602_galaxy_spiral':
                this.render602GalaxySpiral(magnitudes);
                break;
            case 'mode_603_black_hole':
                this.render603BlackHole(magnitudes);
                break;
            case 'mode_604_pulsar':
                this.render604Pulsar(magnitudes);
                break;
            case 'mode_605_quasar':
                this.render605Quasar(magnitudes);
                break;
            case 'mode_606_supernova':
                this.render606Supernova(magnitudes);
                break;
            case 'mode_607_star_cluster':
                this.render607StarCluster(magnitudes);
                break;
            case 'mode_608_asteroid_belt':
                this.render608AsteroidBelt(magnitudes);
                break;
            case 'mode_609_comet_tail':
                this.render609CometTail(magnitudes);
                break;
            case 'mode_610_meteor_shower':
                this.render610MeteorShower(magnitudes);
                break;
            case 'mode_611_planetary_rings':
                this.render611PlanetaryRings(magnitudes);
                break;
            case 'mode_612_solar_flare':
                this.render612SolarFlare(magnitudes);
                break;
            case 'mode_613_coronal_mass_ejection':
                this.render613CoronalMassEjection(magnitudes);
                break;
            case 'mode_614_cosmic_ray':
                this.render614CosmicRay(magnitudes);
                break;
            case 'mode_615_gamma_ray_burst':
                this.render615GammaRayBurst(magnitudes);
                break;
            case 'mode_616_gravitational_lens':
                this.render616GravitationalLens(magnitudes);
                break;
            case 'mode_617_dark_matter_halo':
                this.render617DarkMatterHalo(magnitudes);
                break;
            case 'mode_618_cosmic_web':
                this.render618CosmicWeb(magnitudes);
                break;
            case 'mode_619_void':
                this.render619Void(magnitudes);
                break;
            case 'mode_620_filament_structure':
                this.render620FilamentStructure(magnitudes);
                break;
            case 'mode_621_hubble_deep_field':
                this.render621HubbleDeepField(magnitudes);
                break;
            case 'mode_622_galaxy_collision':
                this.render622GalaxyCollision(magnitudes);
                break;
            case 'mode_623_tidal_tail':
                this.render623TidalTail(magnitudes);
                break;
            case 'mode_624_starburst_galaxy':
                this.render624StarburstGalaxy(magnitudes);
                break;
            case 'mode_625_active_galactic_nucleus':
                this.render625ActiveGalacticNucleus(magnitudes);
                break;
            case 'mode_626_blazar':
                this.render626Blazar(magnitudes);
                break;
            case 'mode_627_seyfert_galaxy':
                this.render627SeyfertGalaxy(magnitudes);
                break;
            case 'mode_628_radio_galaxy':
                this.render628RadioGalaxy(magnitudes);
                break;
            case 'mode_629_elliptical_galaxy':
                this.render629EllipticalGalaxy(magnitudes);
                break;
            case 'mode_630_irregular_galaxy':
                this.render630IrregularGalaxy(magnitudes);
                break;
            case 'mode_631_dwarf_galaxy':
                this.render631DwarfGalaxy(magnitudes);
                break;
            case 'mode_632_globular_cluster':
                this.render632GlobularCluster(magnitudes);
                break;
            case 'mode_633_open_cluster':
                this.render633OpenCluster(magnitudes);
                break;
            case 'mode_634_protoplanetary_disk':
                this.render634ProtoplanetaryDisk(magnitudes);
                break;
            case 'mode_635_accretion_disk':
                this.render635AccretionDisk(magnitudes);
                break;
            case 'mode_636_jets_from_black_hole':
                this.render636JetsFromBlackHole(magnitudes);
                break;
            case 'mode_637_event_horizon':
                this.render637EventHorizon(magnitudes);
                break;
            case 'mode_638_photon_sphere':
                this.render638PhotonSphere(magnitudes);
                break;
            case 'mode_639_ergosphere':
                this.render639Ergosphere(magnitudes);
                break;
            case 'mode_640_singularity':
                this.render640Singularity(magnitudes);
                break;
            case 'mode_641_wormhole':
                this.render641Wormhole(magnitudes);
                break;
            case 'mode_642_white_hole':
                this.render642WhiteHole(magnitudes);
                break;
            case 'mode_643_naked_singularity':
                this.render643NakedSingularity(magnitudes);
                break;
            case 'mode_644_hawking_radiation':
                this.render644HawkingRadiation(magnitudes);
                break;
            case 'mode_645_information_paradox':
                this.render645InformationParadox(magnitudes);
                break;
            case 'mode_646_multiverse_bubble':
                this.render646MultiverseBubble(magnitudes);
                break;
            case 'mode_647_parallel_universe':
                this.render647ParallelUniverse(magnitudes);
                break;
            case 'mode_648_brane_collision':
                this.render648BraneCollision(magnitudes);
                break;
            case 'mode_649_extra_dimensions':
                this.render649ExtraDimensions(magnitudes);
                break;
            case 'mode_650_calabi_yau_manifold':
                this.render650CalabiYauManifold(magnitudes);
                break;
            case 'mode_651_string_theory_vibration':
                this.render651StringTheoryVibration(magnitudes);
                break;
            case 'mode_652_quantum_foam':
                this.render652QuantumFoam(magnitudes);
                break;
            case 'mode_653_planck_scale':
                this.render653PlanckScale(magnitudes);
                break;
            case 'mode_654_big_bang':
                this.render654BigBang(magnitudes);
                break;
            case 'mode_655_cosmic_microwave_background':
                this.render655CosmicMicrowaveBackground(magnitudes);
                break;
            case 'mode_656_inflation_field':
                this.render656InflationField(magnitudes);
                break;
            case 'mode_657_density_fluctuations':
                this.render657DensityFluctuations(magnitudes);
                break;
            case 'mode_658_baryon_acoustic_oscillations':
                this.render658BaryonAcousticOscillations(magnitudes);
                break;
            case 'mode_659_dark_energy':
                this.render659DarkEnergy(magnitudes);
                break;
            case 'mode_660_cosmological_constant':
                this.render660CosmologicalConstant(magnitudes);
                break;
            case 'mode_661_quintessence_field':
                this.render661QuintessenceField(magnitudes);
                break;
            case 'mode_662_heat_death':
                this.render662HeatDeath(magnitudes);
                break;
            case 'mode_663_big_rip':
                this.render663BigRip(magnitudes);
                break;
            case 'mode_664_big_crunch':
                this.render664BigCrunch(magnitudes);
                break;
            case 'mode_665_big_bounce':
                this.render665BigBounce(magnitudes);
                break;
            case 'mode_666_cyclic_universe':
                this.render666CyclicUniverse(magnitudes);
                break;
            case 'mode_667_conformal_cyclic_cosmology':
                this.render667ConformalCyclicCosmology(magnitudes);
                break;
            case 'mode_668_eternal_inflation':
                this.render668EternalInflation(magnitudes);
                break;
            case 'mode_669_landscape_multiverse':
                this.render669LandscapeMultiverse(magnitudes);
                break;
            case 'mode_670_quantum_decoherence':
                this.render670QuantumDecoherence(magnitudes);
                break;
            case 'mode_671_many_worlds':
                this.render671ManyWorlds(magnitudes);
                break;
            case 'mode_672_pilot_wave':
                this.render672PilotWave(magnitudes);
                break;
            case 'mode_673_spontaneous_collapse':
                this.render673SpontaneousCollapse(magnitudes);
                break;
            case 'mode_674_transactional_interpretation':
                this.render674TransactionalInterpretation(magnitudes);
                break;
            case 'mode_675_relational_quantum_mechanics':
                this.render675RelationalQuantumMechanics(magnitudes);
                break;
            case 'mode_676_quantum_bayesianism':
                this.render676QuantumBayesianism(magnitudes);
                break;
            case 'mode_677_consistent_histories':
                this.render677ConsistentHistories(magnitudes);
                break;
            case 'mode_678_bohemian_mechanics':
                this.render678BohemianMechanics(magnitudes);
                break;
            case 'mode_679_stochastic_mechanics':
                this.render679StochasticMechanics(magnitudes);
                break;
            case 'mode_680_quantum_darwinism':
                this.render680QuantumDarwinism(magnitudes);
                break;
            case 'mode_681_einselection':
                this.render681Einselection(magnitudes);
                break;
            case 'mode_682_pointer_states':
                this.render682PointerStates(magnitudes);
                break;
            case 'mode_683_branching_spacetime':
                this.render683BranchingSpacetime(magnitudes);
                break;
            case 'mode_684_worldline':
                this.render684Worldline(magnitudes);
                break;
            case 'mode_685_light_cone':
                this.render685LightCone(magnitudes);
                break;
            case 'mode_686_cauchy_surface':
                this.render686CauchySurface(magnitudes);
                break;
            case 'mode_687_spacelike_hypersurface':
                this.render687SpacelikeHypersurface(magnitudes);
                break;
            case 'mode_688_timelike_curve':
                this.render688TimelikeCurve(magnitudes);
                break;
            case 'mode_689_closed_timelike_curve':
                this.render689ClosedTimelikeCurve(magnitudes);
                break;
            case 'mode_690_chronology_protection':
                this.render690ChronologyProtection(magnitudes);
                break;
            case 'mode_691_novikov_self_consistency':
                this.render691NovikovSelfConsistency(magnitudes);
                break;
            case 'mode_692_grandfather_paradox':
                this.render692GrandfatherParadox(magnitudes);
                break;
            case 'mode_693_bootstrap_paradox':
                this.render693BootstrapParadox(magnitudes);
                break;
            case 'mode_694_predestination_paradox':
                this.render694PredestinationParadox(magnitudes);
                break;
            case 'mode_695_causal_loop':
                this.render695CausalLoop(magnitudes);
                break;
            case 'mode_696_retrocausality':
                this.render696Retrocausality(magnitudes);
                break;
            case 'mode_697_advanced_wave':
                this.render697AdvancedWave(magnitudes);
                break;
            case 'mode_698_wheeler_feynman_absorber':
                this.render698WheelerFeynmanAbsorber(magnitudes);
                break;
            case 'mode_699_transactional_interpretation':
                this.render699TransactionalInterpretation(magnitudes);
                break;
            case 'mode_700_two_state_vector':
                this.render700TwoStateVector(magnitudes);
                break;
            case 'mode_701_binary_rain':
                this.render701BinaryRain(magnitudes);
                break;
            case 'mode_702_hexadecimal_grid':
                this.render702HexadecimalGrid(magnitudes);
                break;
            case 'mode_703_circuit_board':
                this.render703CircuitBoard(magnitudes);
                break;
            case 'mode_704_data_flow':
                this.render704DataFlow(magnitudes);
                break;
            case 'mode_705_packet_transmission':
                this.render705PacketTransmission(magnitudes);
                break;
            case 'mode_706_network_topology':
                this.render706NetworkTopology(magnitudes);
                break;
            case 'mode_707_server_cluster':
                this.render707ServerCluster(magnitudes);
                break;
            case 'mode_708_cloud_computing':
                this.render708CloudComputing(magnitudes);
                break;
            case 'mode_709_distributed_system':
                this.render709DistributedSystem(magnitudes);
                break;
            case 'mode_710_peer_to_peer':
                this.render710PeerToPeer(magnitudes);
                break;
            case 'mode_711_blockchain':
                this.render711Blockchain(magnitudes);
                break;
            case 'mode_712_hash_function':
                this.render712HashFunction(magnitudes);
                break;
            case 'mode_713_encryption':
                this.render713Encryption(magnitudes);
                break;
            case 'mode_714_public_key':
                this.render714PublicKey(magnitudes);
                break;
            case 'mode_715_digital_signature':
                this.render715DigitalSignature(magnitudes);
                break;
            case 'mode_716_zero_knowledge_proof':
                this.render716ZeroKnowledgeProof(magnitudes);
                break;
            case 'mode_717_homomorphic_encryption':
                this.render717HomomorphicEncryption(magnitudes);
                break;
            case 'mode_718_secure_multiparty_computation':
                this.render718SecureMultipartyComputation(magnitudes);
                break;
            case 'mode_719_differential_privacy':
                this.render719DifferentialPrivacy(magnitudes);
                break;
            case 'mode_720_federated_learning':
                this.render720FederatedLearning(magnitudes);
                break;
            case 'mode_721_neural_network':
                this.render721NeuralNetwork(magnitudes);
                break;
            case 'mode_722_deep_learning':
                this.render722DeepLearning(magnitudes);
                break;
            case 'mode_723_convolutional_layer':
                this.render723ConvolutionalLayer(magnitudes);
                break;
            case 'mode_724_recurrent_connection':
                this.render724RecurrentConnection(magnitudes);
                break;
            case 'mode_725_attention_mechanism':
                this.render725AttentionMechanism(magnitudes);
                break;
            case 'mode_726_transformer_architecture':
                this.render726TransformerArchitecture(magnitudes);
                break;
            case 'mode_727_residual_connection':
                this.render727ResidualConnection(magnitudes);
                break;
            case 'mode_728_skip_connection':
                this.render728SkipConnection(magnitudes);
                break;
            case 'mode_729_batch_normalization':
                this.render729BatchNormalization(magnitudes);
                break;
            case 'mode_730_dropout_regularization':
                this.render730DropoutRegularization(magnitudes);
                break;
            case 'mode_731_activation_function':
                this.render731ActivationFunction(magnitudes);
                break;
            case 'mode_732_gradient_descent':
                this.render732GradientDescent(magnitudes);
                break;
            case 'mode_733_backpropagation':
                this.render733Backpropagation(magnitudes);
                break;
            case 'mode_734_loss_landscape':
                this.render734LossLandscape(magnitudes);
                break;
            case 'mode_735_optimizer_trajectory':
                this.render735OptimizerTrajectory(magnitudes);
                break;
            case 'mode_736_learning_rate_schedule':
                this.render736LearningRateSchedule(magnitudes);
                break;
            case 'mode_737_momentum':
                this.render737Momentum(magnitudes);
                break;
            case 'mode_738_adaptive_learning':
                this.render738AdaptiveLearning(magnitudes);
                break;
            case 'mode_739_weight_decay':
                this.render739WeightDecay(magnitudes);
                break;
            case 'mode_740_early_stopping':
                this.render740EarlyStopping(magnitudes);
                break;
            case 'mode_741_cross_validation':
                this.render741CrossValidation(magnitudes);
                break;
            case 'mode_742_ensemble_method':
                this.render742EnsembleMethod(magnitudes);
                break;
            case 'mode_743_boosting':
                this.render743Boosting(magnitudes);
                break;
            case 'mode_744_bagging':
                this.render744Bagging(magnitudes);
                break;
            case 'mode_745_random_forest':
                this.render745RandomForest(magnitudes);
                break;
            case 'mode_746_decision_tree':
                this.render746DecisionTree(magnitudes);
                break;
            case 'mode_747_support_vector_machine':
                this.render747SupportVectorMachine(magnitudes);
                break;
            case 'mode_748_kernel_trick':
                this.render748KernelTrick(magnitudes);
                break;
            case 'mode_749_feature_space':
                this.render749FeatureSpace(magnitudes);
                break;
            case 'mode_750_dimensionality_reduction':
                this.render750DimensionalityReduction(magnitudes);
                break;
            case 'mode_751_principal_component_analysis':
                this.render751PrincipalComponentAnalysis(magnitudes);
                break;
            case 'mode_752_t_sne_embedding':
                this.render752TSneEmbedding(magnitudes);
                break;
            case 'mode_753_autoencoder_latent_space':
                this.render753AutoencoderLatentSpace(magnitudes);
                break;
            case 'mode_754_variational_autoencoder':
                this.render754VariationalAutoencoder(magnitudes);
                break;
            case 'mode_755_generative_adversarial_network':
                this.render755GenerativeAdversarialNetwork(magnitudes);
                break;
            case 'mode_756_discriminator_network':
                this.render756DiscriminatorNetwork(magnitudes);
                break;
            case 'mode_757_generator_network':
                this.render757GeneratorNetwork(magnitudes);
                break;
            case 'mode_758_style_transfer':
                this.render758StyleTransfer(magnitudes);
                break;
            case 'mode_759_content_loss':
                this.render759ContentLoss(magnitudes);
                break;
            case 'mode_760_gram_matrix':
                this.render760GramMatrix(magnitudes);
                break;
            case 'mode_761_perceptual_loss':
                this.render761PerceptualLoss(magnitudes);
                break;
            case 'mode_762_adversarial_loss':
                this.render762AdversarialLoss(magnitudes);
                break;
            case 'mode_763_cycle_consistency':
                this.render763CycleConsistency(magnitudes);
                break;
            case 'mode_764_identity_loss':
                this.render764IdentityLoss(magnitudes);
                break;
            case 'mode_765_reconstruction_loss':
                this.render765ReconstructionLoss(magnitudes);
                break;
            case 'mode_766_kl_divergence':
                this.render766KlDivergence(magnitudes);
                break;
            case 'mode_767_wasserstein_distance':
                this.render767WassersteinDistance(magnitudes);
                break;
            case 'mode_768_earth_mover_distance':
                this.render768EarthMoverDistance(magnitudes);
                break;
            case 'mode_769_inception_score':
                this.render769InceptionScore(magnitudes);
                break;
            case 'mode_770_frechet_inception_distance':
                this.render770FrechetInceptionDistance(magnitudes);
                break;
            case 'mode_771_bleu_score':
                this.render771BleuScore(magnitudes);
                break;
            case 'mode_772_rouge_score':
                this.render772RougeScore(magnitudes);
                break;
            case 'mode_773_perplexity':
                this.render773Perplexity(magnitudes);
                break;
            case 'mode_774_cross_entropy':
                this.render774CrossEntropy(magnitudes);
                break;
            case 'mode_775_mutual_information':
                this.render775MutualInformation(magnitudes);
                break;
            case 'mode_776_information_bottleneck':
                this.render776InformationBottleneck(magnitudes);
                break;
            case 'mode_777_rate_distortion':
                this.render777RateDistortion(magnitudes);
                break;
            case 'mode_778_source_coding':
                this.render778SourceCoding(magnitudes);
                break;
            case 'mode_779_channel_coding':
                this.render779ChannelCoding(magnitudes);
                break;
            case 'mode_780_error_correction':
                this.render780ErrorCorrection(magnitudes);
                break;
            case 'mode_781_hamming_distance':
                this.render781HammingDistance(magnitudes);
                break;
            case 'mode_782_reed_solomon':
                this.render782ReedSolomon(magnitudes);
                break;
            case 'mode_783_turbo_code':
                this.render783TurboCode(magnitudes);
                break;
            case 'mode_784_ldpc_code':
                this.render784LdpcCode(magnitudes);
                break;
            case 'mode_785_polar_code':
                this.render785PolarCode(magnitudes);
                break;
            case 'mode_786_quantum_error_correction':
                this.render786QuantumErrorCorrection(magnitudes);
                break;
            case 'mode_787_surface_code':
                this.render787SurfaceCode(magnitudes);
                break;
            case 'mode_788_toric_code':
                this.render788ToricCode(magnitudes);
                break;
            case 'mode_789_color_code':
                this.render789ColorCode(magnitudes);
                break;
            case 'mode_790_stabilizer_formalism':
                this.render790StabilizerFormalism(magnitudes);
                break;
            case 'mode_791_clifford_gate':
                this.render791CliffordGate(magnitudes);
                break;
            case 'mode_792_pauli_group':
                this.render792PauliGroup(magnitudes);
                break;
            case 'mode_793_measurement_based_quantum_computing':
                this.render793MeasurementBasedQuantumComputing(magnitudes);
                break;
            case 'mode_794_one_way_quantum_computer':
                this.render794OneWayQuantumComputer(magnitudes);
                break;
            case 'mode_795_adiabatic_quantum_computation':
                this.render795AdiabaticQuantumComputation(magnitudes);
                break;
            case 'mode_796_quantum_annealing':
                this.render796QuantumAnnealing(magnitudes);
                break;
            case 'mode_797_variational_quantum_eigensolver':
                this.render797VariationalQuantumEigensolver(magnitudes);
                break;
            case 'mode_798_quantum_approximate_optimization':
                this.render798QuantumApproximateOptimization(magnitudes);
                break;
            case 'mode_799_quantum_phase_estimation':
                this.render799QuantumPhaseEstimation(magnitudes);
                break;
            case 'mode_800_quantum_fourier_transform':
                this.render800QuantumFourierTransform(magnitudes);
                break;
            case 'mode_801_mandala':
                this.render801Mandala(magnitudes);
                break;
            case 'mode_802_yantra':
                this.render802Yantra(magnitudes);
                break;
            case 'mode_803_lotus':
                this.render803Lotus(magnitudes);
                break;
            case 'mode_804_om_symbol':
                this.render804OmSymbol(magnitudes);
                break;
            case 'mode_805_chakra':
                this.render805Chakra(magnitudes);
                break;
            case 'mode_806_aura_field':
                this.render806AuraField(magnitudes);
                break;
            case 'mode_807_third_eye':
                this.render807ThirdEye(magnitudes);
                break;
            case 'mode_808_kundalini':
                this.render808Kundalini(magnitudes);
                break;
            case 'mode_809_merkaba':
                this.render809Merkaba(magnitudes);
                break;
            case 'mode_810_flower_of_life':
                this.render810FlowerOfLife(magnitudes);
                break;
            case 'mode_811_seed_of_life':
                this.render811SeedOfLife(magnitudes);
                break;
            case 'mode_812_tree_of_life':
                this.render812TreeOfLife(magnitudes);
                break;
            case 'mode_813_metatron_cube':
                this.render813MetatronCube(magnitudes);
                break;
            case 'mode_814_sri_yantra':
                this.render814SriYantra(magnitudes);
                break;
            case 'mode_815_shri_yantra':
                this.render815ShriYantra(magnitudes);
                break;
            case 'mode_816_tibetan_sand_mandala':
                this.render816TibetanSandMandala(magnitudes);
                break;
            case 'mode_817_zen_circle':
                this.render817ZenCircle(magnitudes);
                break;
            case 'mode_818_yin_yang':
                this.render818YinYang(magnitudes);
                break;
            case 'mode_819_tao_symbol':
                this.render819TaoSymbol(magnitudes);
                break;
            case 'mode_820_bagua':
                this.render820Bagua(magnitudes);
                break;
            case 'mode_821_i_ching_hexagram':
                this.render821IChingHexagram(magnitudes);
                break;
            case 'mode_822_trigram':
                this.render822Trigram(magnitudes);
                break;
            case 'mode_823_medicine_wheel':
                this.render823MedicineWheel(magnitudes);
                break;
            case 'mode_824_dreamcatcher':
                this.render824Dreamcatcher(magnitudes);
                break;
            case 'mode_825_totem':
                this.render825Totem(magnitudes);
                break;
            case 'mode_826_spirit_animal':
                this.render826SpiritAnimal(magnitudes);
                break;
            case 'mode_827_shamanic_journey':
                this.render827ShamanicJourney(magnitudes);
                break;
            case 'mode_828_ayahuasca_vision':
                this.render828AyahuascaVision(magnitudes);
                break;
            case 'mode_829_dmt_realm':
                this.render829DmtRealm(magnitudes);
                break;
            case 'mode_830_astral_projection':
                this.render830AstralProjection(magnitudes);
                break;
            case 'mode_831_out_of_body_experience':
                this.render831OutOfBodyExperience(magnitudes);
                break;
            case 'mode_832_near_death_experience':
                this.render832NearDeathExperience(magnitudes);
                break;
            case 'mode_833_tunnel_of_light':
                this.render833TunnelOfLight(magnitudes);
                break;
            case 'mode_834_life_review':
                this.render834LifeReview(magnitudes);
                break;
            case 'mode_835_soul_retrieval':
                this.render835SoulRetrieval(magnitudes);
                break;
            case 'mode_836_past_life_regression':
                this.render836PastLifeRegression(magnitudes);
                break;
            case 'mode_837_akashic_records':
                this.render837AkashicRecords(magnitudes);
                break;
            case 'mode_838_collective_unconscious':
                this.render838CollectiveUnconscious(magnitudes);
                break;
            case 'mode_839_archetypal_realm':
                this.render839ArchetypalRealm(magnitudes);
                break;
            case 'mode_840_synchronicity':
                this.render840Synchronicity(magnitudes);
                break;
            case 'mode_841_meaningful_coincidence':
                this.render841MeaningfulCoincidence(magnitudes);
                break;
            case 'mode_842_serendipity':
                this.render842Serendipity(magnitudes);
                break;
            case 'mode_843_providence':
                this.render843Providence(magnitudes);
                break;
            case 'mode_844_fate':
                this.render844Fate(magnitudes);
                break;
            case 'mode_845_destiny':
                this.render845Destiny(magnitudes);
                break;
            case 'mode_846_karma':
                this.render846Karma(magnitudes);
                break;
            case 'mode_847_dharma':
                this.render847Dharma(magnitudes);
                break;
            case 'mode_848_samsara':
                this.render848Samsara(magnitudes);
                break;
            case 'mode_849_nirvana':
                this.render849Nirvana(magnitudes);
                break;
            case 'mode_850_enlightenment':
                this.render850Enlightenment(magnitudes);
                break;
            case 'mode_851_samadhi':
                this.render851Samadhi(magnitudes);
                break;
            case 'mode_852_satori':
                this.render852Satori(magnitudes);
                break;
            case 'mode_853_kensho':
                this.render853Kensho(magnitudes);
                break;
            case 'mode_854_moksha':
                this.render854Moksha(magnitudes);
                break;
            case 'mode_855_liberation':
                this.render855Liberation(magnitudes);
                break;
            case 'mode_856_self_realization':
                this.render856SelfRealization(magnitudes);
                break;
            case 'mode_857_god_consciousness':
                this.render857GodConsciousness(magnitudes);
                break;
            case 'mode_858_cosmic_consciousness':
                this.render858CosmicConsciousness(magnitudes);
                break;
            case 'mode_859_unity_consciousness':
                this.render859UnityConsciousness(magnitudes);
                break;
            case 'mode_860_non_dual_awareness':
                this.render860NonDualAwareness(magnitudes);
                break;
            case 'mode_861_witness_consciousness':
                this.render861WitnessConsciousness(magnitudes);
                break;
            case 'mode_862_pure_awareness':
                this.render862PureAwareness(magnitudes);
                break;
            case 'mode_863_presence':
                this.render863Presence(magnitudes);
                break;
            case 'mode_864_now_moment':
                this.render864NowMoment(magnitudes);
                break;
            case 'mode_865_eternal_present':
                this.render865EternalPresent(magnitudes);
                break;
            case 'mode_866_timeless_being':
                this.render866TimelessBeing(magnitudes);
                break;
            case 'mode_867_infinite_space':
                this.render867InfiniteSpace(magnitudes);
                break;
            case 'mode_868_boundless_compassion':
                this.render868BoundlessCompassion(magnitudes);
                break;
            case 'mode_869_unconditional_love':
                this.render869UnconditionalLove(magnitudes);
                break;
            case 'mode_870_divine_grace':
                this.render870DivineGrace(magnitudes);
                break;
            case 'mode_871_holy_spirit':
                this.render871HolySpirit(magnitudes);
                break;
            case 'mode_872_shekinah':
                this.render872Shekinah(magnitudes);
                break;
            case 'mode_873_divine_feminine':
                this.render873DivineFeminine(magnitudes);
                break;
            case 'mode_874_goddess_energy':
                this.render874GoddessEnergy(magnitudes);
                break;
            case 'mode_875_sacred_masculine':
                this.render875SacredMasculine(magnitudes);
                break;
            case 'mode_876_hieros_gamos':
                this.render876HierosGamos(magnitudes);
                break;
            case 'mode_877_alchemical_wedding':
                this.render877AlchemicalWedding(magnitudes);
                break;
            case 'mode_878_coniunctio':
                this.render878Coniunctio(magnitudes);
                break;
            case 'mode_879_philosopher_stone':
                this.render879PhilosopherStone(magnitudes);
                break;
            case 'mode_880_prima_materia':
                this.render880PrimaMateria(magnitudes);
                break;
            case 'mode_881_nigredo':
                this.render881Nigredo(magnitudes);
                break;
            case 'mode_882_albedo':
                this.render882Albedo(magnitudes);
                break;
            case 'mode_883_citrinitas':
                this.render883Citrinitas(magnitudes);
                break;
            case 'mode_884_rubedo':
                this.render884Rubedo(magnitudes);
                break;
            case 'mode_885_seven_stages':
                this.render885SevenStages(magnitudes);
                break;
            case 'mode_886_hermetic_principle':
                this.render886HermeticPrinciple(magnitudes);
                break;
            case 'mode_887_as_above_so_below':
                this.render887AsAboveSoBelow(magnitudes);
                break;
            case 'mode_888_microcosm_macrocosm':
                this.render888MicrocosmMacrocosm(magnitudes);
                break;
            case 'mode_889_correspondence':
                this.render889Correspondence(magnitudes);
                break;
            case 'mode_890_vibration':
                this.render890Vibration(magnitudes);
                break;
            case 'mode_891_polarity':
                this.render891Polarity(magnitudes);
                break;
            case 'mode_892_rhythm':
                this.render892Rhythm(magnitudes);
                break;
            case 'mode_893_cause_and_effect':
                this.render893CauseAndEffect(magnitudes);
                break;
            case 'mode_894_gender_principle':
                this.render894GenderPrinciple(magnitudes);
                break;
            case 'mode_895_mentalism':
                this.render895Mentalism(magnitudes);
                break;
            case 'mode_896_emerald_tablet':
                this.render896EmeraldTablet(magnitudes);
                break;
            case 'mode_897_kybalion':
                this.render897Kybalion(magnitudes);
                break;
            case 'mode_898_corpus_hermeticum':
                this.render898CorpusHermeticum(magnitudes);
                break;
            case 'mode_899_gnostic_vision':
                this.render899GnosticVision(magnitudes);
                break;
            case 'mode_900_sophia':
                this.render900Sophia(magnitudes);
                break;
            case 'mode_901_spiral_vortex':
                this.render901SpiralVortex(magnitudes);
                break;
            case 'mode_902_concentric_circles':
                this.render902ConcentricCircles(magnitudes);
                break;
            case 'mode_903_expanding_rings':
                this.render903ExpandingRings(magnitudes);
                break;
            case 'mode_904_contracting_circles':
                this.render904ContractingCircles(magnitudes);
                break;
            case 'mode_905_pulsing_orb':
                this.render905PulsingOrb(magnitudes);
                break;
            case 'mode_906_oscillating_wave':
                this.render906OscillatingWave(magnitudes);
                break;
            case 'mode_907_pendulum_swing':
                this.render907PendulumSwing(magnitudes);
                break;
            case 'mode_908_hypnotic_swirl':
                this.render908HypnoticSwirl(magnitudes);
                break;
            case 'mode_909_tunnel_zoom':
                this.render909TunnelZoom(magnitudes);
                break;
            case 'mode_910_perspective_shift':
                this.render910PerspectiveShift(magnitudes);
                break;
            case 'mode_911_rotating_polygon':
                this.render911RotatingPolygon(magnitudes);
                break;
            case 'mode_912_morphing_shape':
                this.render912MorphingShape(magnitudes);
                break;
            case 'mode_913_flowing_liquid':
                this.render913FlowingLiquid(magnitudes);
                break;
            case 'mode_914_ripple_effect':
                this.render914RippleEffect(magnitudes);
                break;
            case 'mode_915_interference_pattern':
                this.render915InterferencePattern(magnitudes);
                break;
            case 'mode_916_moire_effect':
                this.render916MoireEffect(magnitudes);
                break;
            case 'mode_917_strobing_light':
                this.render917StrobingLight(magnitudes);
                break;
            case 'mode_918_flickering':
                this.render918Flickering(magnitudes);
                break;
            case 'mode_919_pulsating':
                this.render919Pulsating(magnitudes);
                break;
            case 'mode_920_breathing_pattern':
                this.render920BreathingPattern(magnitudes);
                break;
            case 'mode_921_expansion_contraction':
                this.render921ExpansionContraction(magnitudes);
                break;
            case 'mode_922_growth_decay':
                this.render922GrowthDecay(magnitudes);
                break;
            case 'mode_923_birth_death':
                this.render923BirthDeath(magnitudes);
                break;
            case 'mode_924_ebb_flow':
                this.render924EbbFlow(magnitudes);
                break;
            case 'mode_925_inhale_exhale':
                this.render925InhaleExhale(magnitudes);
                break;
            case 'mode_926_systole_diastole':
                this.render926SystoleDiastole(magnitudes);
                break;
            case 'mode_927_tension_release':
                this.render927TensionRelease(magnitudes);
                break;
            case 'mode_928_charge_discharge':
                this.render928ChargeDischarge(magnitudes);
                break;
            case 'mode_929_loading_unloading':
                this.render929LoadingUnloading(magnitudes);
                break;
            case 'mode_930_compression_rarefaction':
                this.render930CompressionRarefaction(magnitudes);
                break;
            case 'mode_931_dense_sparse':
                this.render931DenseSparse(magnitudes);
                break;
            case 'mode_932_thick_thin':
                this.render932ThickThin(magnitudes);
                break;
            case 'mode_933_heavy_light':
                this.render933HeavyLight(magnitudes);
                break;
            case 'mode_934_dark_bright':
                this.render934DarkBright(magnitudes);
                break;
            case 'mode_935_shadow_highlight':
                this.render935ShadowHighlight(magnitudes);
                break;
            case 'mode_936_positive_negative':
                this.render936PositiveNegative(magnitudes);
                break;
            case 'mode_937_convex_concave':
                this.render937ConvexConcave(magnitudes);
                break;
            case 'mode_938_inside_outside':
                this.render938InsideOutside(magnitudes);
                break;
            case 'mode_939_figure_ground':
                this.render939FigureGround(magnitudes);
                break;
            case 'mode_940_foreground_background':
                this.render940ForegroundBackground(magnitudes);
                break;
            case 'mode_941_solid_void':
                this.render941SolidVoid(magnitudes);
                break;
            case 'mode_942_matter_antimatter':
                this.render942MatterAntimatter(magnitudes);
                break;
            case 'mode_943_particle_wave':
                this.render943ParticleWave(magnitudes);
                break;
            case 'mode_944_discrete_continuous':
                this.render944DiscreteContinuous(magnitudes);
                break;
            case 'mode_945_quantized_smooth':
                this.render945QuantizedSmooth(magnitudes);
                break;
            case 'mode_946_digital_analog':
                this.render946DigitalAnalog(magnitudes);
                break;
            case 'mode_947_binary_fluid':
                this.render947BinaryFluid(magnitudes);
                break;
            case 'mode_948_on_off':
                this.render948OnOff(magnitudes);
                break;
            case 'mode_949_yes_no':
                this.render949YesNo(magnitudes);
                break;
            case 'mode_950_zero_one':
                this.render950ZeroOne(magnitudes);
                break;
            case 'mode_951_presence_absence':
                this.render951PresenceAbsence(magnitudes);
                break;
            case 'mode_952_being_nothingness':
                this.render952BeingNothingness(magnitudes);
                break;
            case 'mode_953_existence_void':
                this.render953ExistenceVoid(magnitudes);
                break;
            case 'mode_954_form_emptiness':
                this.render954FormEmptiness(magnitudes);
                break;
            case 'mode_955_substance_essence':
                this.render955SubstanceEssence(magnitudes);
                break;
            case 'mode_956_appearance_reality':
                this.render956AppearanceReality(magnitudes);
                break;
            case 'mode_957_illusion_truth':
                this.render957IllusionTruth(magnitudes);
                break;
            case 'mode_958_maya_brahman':
                this.render958MayaBrahman(magnitudes);
                break;
            case 'mode_959_phenomena_noumena':
                this.render959PhenomenaNoumena(magnitudes);
                break;
            case 'mode_960_relative_absolute':
                this.render960RelativeAbsolute(magnitudes);
                break;
            case 'mode_961_changing_unchanging':
                this.render961ChangingUnchanging(magnitudes);
                break;
            case 'mode_962_temporal_eternal':
                this.render962TemporalEternal(magnitudes);
                break;
            case 'mode_963_finite_infinite':
                this.render963FiniteInfinite(magnitudes);
                break;
            case 'mode_964_limited_boundless':
                this.render964LimitedBoundless(magnitudes);
                break;
            case 'mode_965_mortal_immortal':
                this.render965MortalImmortal(magnitudes);
                break;
            case 'mode_966_perishable_imperishable':
                this.render966PerishableImperishable(magnitudes);
                break;
            case 'mode_967_transient_permanent':
                this.render967TransientPermanent(magnitudes);
                break;
            case 'mode_968_fleeting_lasting':
                this.render968FleetingLasting(magnitudes);
                break;
            case 'mode_969_ephemeral_enduring':
                this.render969EphemeralEnduring(magnitudes);
                break;
            case 'mode_970_momentary_timeless':
                this.render970MomentaryTimeless(magnitudes);
                break;
            case 'mode_971_local_universal':
                this.render971LocalUniversal(magnitudes);
                break;
            case 'mode_972_particular_general':
                this.render972ParticularGeneral(magnitudes);
                break;
            case 'mode_973_specific_generic':
                this.render973SpecificGeneric(magnitudes);
                break;
            case 'mode_974_unique_common':
                this.render974UniqueCommon(magnitudes);
                break;
            case 'mode_975_individual_collective':
                this.render975IndividualCollective(magnitudes);
                break;
            case 'mode_976_one_many':
                this.render976OneMany(magnitudes);
                break;
            case 'mode_977_unity_multiplicity':
                this.render977UnityMultiplicity(magnitudes);
                break;
            case 'mode_978_simple_complex':
                this.render978SimpleComplex(magnitudes);
                break;
            case 'mode_979_elementary_composite':
                this.render979ElementaryComposite(magnitudes);
                break;
            case 'mode_980_atomic_molecular':
                this.render980AtomicMolecular(magnitudes);
                break;
            case 'mode_981_fundamental_derived':
                this.render981FundamentalDerived(magnitudes);
                break;
            case 'mode_982_primary_secondary':
                this.render982PrimarySecondary(magnitudes);
                break;
            case 'mode_983_essential_accidental':
                this.render983EssentialAccidental(magnitudes);
                break;
            case 'mode_984_necessary_contingent':
                this.render984NecessaryContingent(magnitudes);
                break;
            case 'mode_985_a_priori_a_posteriori':
                this.render985APrioriAPosteriori(magnitudes);
                break;
            case 'mode_986_analytic_synthetic':
                this.render986AnalyticSynthetic(magnitudes);
                break;
            case 'mode_987_deductive_inductive':
                this.render987DeductiveInductive(magnitudes);
                break;
            case 'mode_988_logical_empirical':
                this.render988LogicalEmpirical(magnitudes);
                break;
            case 'mode_989_rational_experiential':
                this.render989RationalExperiential(magnitudes);
                break;
            case 'mode_990_abstract_concrete':
                this.render990AbstractConcrete(magnitudes);
                break;
            case 'mode_991_theoretical_practical':
                this.render991TheoreticalPractical(magnitudes);
                break;
            case 'mode_992_ideal_real':
                this.render992IdealReal(magnitudes);
                break;
            case 'mode_993_conceptual_actual':
                this.render993ConceptualActual(magnitudes);
                break;
            case 'mode_994_possible_necessary':
                this.render994PossibleNecessary(magnitudes);
                break;
            case 'mode_995_potential_actual':
                this.render995PotentialActual(magnitudes);
                break;
            case 'mode_996_virtual_real':
                this.render996VirtualReal(magnitudes);
                break;
            case 'mode_997_simulated_genuine':
                this.render997SimulatedGenuine(magnitudes);
                break;
            case 'mode_998_artificial_natural':
                this.render998ArtificialNatural(magnitudes);
                break;
            case 'mode_999_synthetic_organic':
                this.render999SyntheticOrganic(magnitudes);
                break;
            case 'mode_1000_mechanical_living':
                this.render1000MechanicalLiving(magnitudes);
                break;
            case 'mode_1001_cassette_tape_deck':
                this.render1001CassetteTapeDeck(magnitudes);
                break;
            case 'mode_1002_arcade_pixel_bars':
                this.render1002ArcadePixelBars(magnitudes);
                break;
            case 'mode_1003_vector_oscilloscope':
                this.render1003VectorOscilloscope(magnitudes);
                break;
            case 'mode_1004_led_spectrum_grid':
                this.render1004LEDSpectrumGrid(magnitudes);
                break;
            case 'mode_1008_boombox_spectrum':
                this.render1008BoomboxSpectrum(magnitudes);
                break;
            case 'mode_1009_synthwave_grid':
                this.render1009SynthwaveGrid(magnitudes);
                break;
            case 'mode_1012_ocean_waves':
                this.render1012OceanWaves(magnitudes);
                break;
            case 'mode_1016_quantum_flux':
                this.render1016QuantumFlux(magnitudes);
                break;
            case 'mode_1017_photon_streams':
                this.render1017PhotonStreams(magnitudes);
                break;
            case 'mode_1018_magnetic_field':
                this.render1018MagneticField(magnitudes);
                break;
            case 'mode_1005_v_formation_migration':
                this.render1005VFormationMigration(magnitudes);
                break;
            case 'mode_1006_diving_seagulls':
                this.render1006DivingSeagulls(magnitudes);
                break;
            case 'mode_1007_sparrow_scatter':
                this.render1007SparrowScatter(magnitudes);
                break;
            default:
                this.renderCircularBars(magnitudes);
            }
        } catch (error) {
            console.error(`[Visualizer] Error rendering mode '${modeId}':`, error.message);
            // Fallback to circular bars on error
            this.renderCircularBars(magnitudes);
        }

        if (this.frameCounter === 0) {
            console.log('[Visualizer] First render completed successfully');
        }

        this.frameCounter++;
    }

    /**
     * Mode 1: Circular Bars
     */
    renderCircularBars(magnitudes) {
        const numBars = magnitudes.length;
        const angleStep = (Math.PI * 2) / numBars;
        const innerRadius = this.getEffectiveInnerRadius();
        const barWidthMultiplier = this.settings.barWidthMultiplier;

        // Enable shadow for depth
        this.ctx.shadowBlur = 15;
        this.ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';

        for (let i = 0; i < numBars; i++) {
            const angle = i * angleStep - Math.PI / 2;
            const magnitude = magnitudes[i];
            const barLength = magnitude * this.maxRadius * 0.7;

            const x1 = this.centerX + Math.cos(angle) * innerRadius;
            const y1 = this.centerY + Math.sin(angle) * innerRadius;
            const x2 = this.centerX + Math.cos(angle) * (innerRadius + barLength);
            const y2 = this.centerY + Math.sin(angle) * (innerRadius + barLength);

            this.ctx.strokeStyle = this.getColor(i, numBars);
            this.ctx.lineWidth = angleStep * innerRadius * barWidthMultiplier;
            this.ctx.lineCap = 'round';

            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }

        // Reset shadow
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 2: Waves
     */
    renderWaves(magnitudes) {
        const numWaves = 5;
        const innerRadius = this.getEffectiveInnerRadius();

        this.ctx.shadowBlur = 20;
        this.ctx.shadowColor = 'rgba(0, 113, 227, 0.3)';

        for (let wave = 0; wave < numWaves; wave++) {
            const waveRadius = innerRadius + (wave * 40);
            const numPoints = magnitudes.length;
            const angleStep = (Math.PI * 2) / numPoints;

            this.ctx.beginPath();
            this.ctx.strokeStyle = this.getColor(wave * 20, 100);
            this.ctx.lineWidth = 3;
            this.ctx.lineCap = 'round';

            for (let i = 0; i <= numPoints; i++) {
                const angle = i * angleStep;
                const magnitude = magnitudes[i % numPoints];
                const radius = waveRadius + magnitude * 30;

                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;

                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }

            this.ctx.closePath();
            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 3: Particles
     */
    renderParticles(magnitudes) {
        const numBars = magnitudes.length;
        const angleStep = (Math.PI * 2) / numBars;
        const innerRadius = this.getEffectiveInnerRadius();

        this.ctx.shadowBlur = 25;

        for (let i = 0; i < numBars; i++) {
            const angle = i * angleStep;
            const magnitude = magnitudes[i];
            const distance = innerRadius + magnitude * this.maxRadius * 0.6;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;
            const size = 4 + magnitude * 8;

            const color = this.getColor(i, numBars);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;

            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 4: Smooth Waveform
     */
    renderSmoothWaveform(magnitudes) {
        const numPoints = magnitudes.length;
        const angleStep = (Math.PI * 2) / numPoints;
        const innerRadius = this.getEffectiveInnerRadius();

        // Draw filled waveform
        this.ctx.beginPath();

        for (let i = 0; i <= numPoints; i++) {
            const angle = i * angleStep;
            const magnitude = magnitudes[i % numPoints];
            const radius = innerRadius + magnitude * this.maxRadius * 0.5;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            if (i === 0) {
                this.ctx.moveTo(x, y);
            } else {
                this.ctx.lineTo(x, y);
            }
        }

        this.ctx.closePath();

        // Create gradient fill (ensure positive radii)
        const r1 = Math.max(0, innerRadius);
        const r2 = Math.max(r1 + 1, innerRadius + this.maxRadius * 0.5);
        const gradient = this.ctx.createRadialGradient(
            this.centerX, this.centerY, r1,
            this.centerX, this.centerY, r2
        );

        const scheme = COLOR_SCHEMES[this.settings.colorScheme];
        const color1 = scheme.primary;
        const color2 = scheme.secondary;

        gradient.addColorStop(0, `rgba(${color1[0]}, ${color1[1]}, ${color1[2]}, 0.8)`);
        gradient.addColorStop(1, `rgba(${color2[0]}, ${color2[1]}, ${color2[2]}, 0.4)`);

        this.ctx.fillStyle = gradient;
        this.ctx.fill();

        // Draw outline
        this.ctx.strokeStyle = `rgb(${color1[0]}, ${color1[1]}, ${color1[2]})`;
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
    }

    /**
     * Jazzy Fireworks: Bursting particles from center with jazz energy
     */
    renderJazzyFireworks(magnitudes) {
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const particleCount = this.settings.jazzyFireworksParticleCount || 200;
        const speed = this.settings.jazzyFireworksSpeed || 10;
        const secondaryBursts = this.settings.jazzyFireworksSecondaryBursts || 3;

        // Spawn particles from center constantly when magnitude is high
        if (avgMagnitude > 0.3) {
            const numParticles = Math.floor(150 + avgMagnitude * (particleCount - 150));

            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const particleSpeed = 5 + Math.random() * speed * (avgMagnitude + 0.5);

                // Use color scheme instead of hardcoded rainbow
                const colorIndex = Math.floor(Math.random() * magnitudes.length);
                const colorStr = this.getColor(colorIndex, magnitudes.length);
                const color = this.parseRgbColor(colorStr);

                this.fireworkParticles.push({
                    x: this.centerX,
                    y: this.centerY,
                    vx: Math.cos(angle) * particleSpeed,
                    vy: Math.sin(angle) * particleSpeed,
                    color: color,
                    life: 1.0,
                    size: 4 + Math.floor(avgMagnitude * 8)
                });
            }
        }

        // Spawn secondary bursts from rotating positions
        if (avgMagnitude > 0.5 && this.frameCounter % 5 === 0) {
            for (let burst = 0; burst < secondaryBursts; burst++) {
                const burstAngle = (burst / secondaryBursts) * Math.PI * 2 + this.frameCounter * 0.1;
                const burstDistance = this.maxRadius * 0.4;
                const burstX = this.centerX + Math.cos(burstAngle) * burstDistance;
                const burstY = this.centerY + Math.sin(burstAngle) * burstDistance;

                for (let i = 0; i < 50; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const particleSpeed = 3 + Math.random() * 10;

                    // Use color scheme
                    const colorIndex = Math.floor(Math.random() * magnitudes.length);
                    const colorStr = this.getColor(colorIndex, magnitudes.length);
                    const color = this.parseRgbColor(colorStr);

                    this.fireworkParticles.push({
                        x: burstX,
                        y: burstY,
                        vx: Math.cos(angle) * particleSpeed,
                        vy: Math.sin(angle) * particleSpeed,
                        color: color,
                        life: 0.8,
                        size: 3 + Math.floor(avgMagnitude * 6)
                    });
                }
            }
        }

        // Update and draw particles
        const newParticles = [];
        for (const particle of this.fireworkParticles) {
            particle.x += particle.vx;
            particle.y += particle.vy;
            particle.life -= 0.008;

            // Apply slight gravity
            particle.vy += 0.05;

            if (particle.life > 0) {
                const alpha = particle.life;
                const size = Math.max(1, Math.floor(particle.size * alpha));

                // Main particle
                this.ctx.fillStyle = `rgba(${particle.color[0]}, ${particle.color[1]}, ${particle.color[2]}, ${alpha})`;
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                this.ctx.fill();

                // Multi-layer glow
                if (alpha > 0.3) {
                    // Outer glow
                    this.ctx.strokeStyle = `rgba(${particle.color[0]}, ${particle.color[1]}, ${particle.color[2]}, ${0.3 * alpha})`;
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, size + 4, 0, Math.PI * 2);
                    this.ctx.stroke();

                    // Inner bright glow
                    this.ctx.fillStyle = `rgba(${particle.color[0]}, ${particle.color[1]}, ${particle.color[2]}, ${0.6 * alpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, size + 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                newParticles.push(particle);
            }
        }

        this.fireworkParticles = newParticles;
        this.frameCounter++;
    }

    /**
     * Neon Rain: Cyberpunk neon droplets cascading down
     */
    renderNeonRain(magnitudes) {
        const numBars = magnitudes.length;
        const spawnRate = this.settings.neonRainSpawnRate || 0.3;
        const particleSize = this.settings.neonRainParticleSize || 5;
        const speed = this.settings.neonRainSpeed || 10;

        // Spawn new rain particles based on magnitudes
        for (let i = 0; i < numBars; i++) {
            const magnitude = magnitudes[i];
            if (magnitude > 0.3 && Math.random() < magnitude * spawnRate) {
                const x = (i / numBars) * this.canvas.width;
                const y = 0;
                const particleSpeed = 3 + magnitude * speed;
                const size = 2 + Math.floor(magnitude * particleSize);

                // Use color scheme instead of hardcoded neon colors
                const colorStr = this.getColor(i, numBars);
                const color = this.parseRgbColor(colorStr);

                this.rainParticles.push({
                    x: x,
                    y: y,
                    speed: particleSpeed,
                    size: size,
                    color: color,
                    trailLength: Math.floor(magnitude * 50)
                });
            }
        }

        // Update and draw rain particles
        const newParticles = [];
        for (const particle of this.rainParticles) {
            particle.y += particle.speed;

            // Keep if still on screen
            if (particle.y < this.canvas.height + 20) {
                // Draw particle with trail
                const trailLength = particle.trailLength;
                for (let t = 0; t < trailLength; t++) {
                    const trailY = particle.y - t * 2;
                    if (trailY >= 0) {
                        const alpha = 1.0 - (t / trailLength);
                        const trailColor = `rgba(${particle.color[0]}, ${particle.color[1]}, ${particle.color[2]}, ${alpha})`;
                        const trailSize = Math.max(1, particle.size - Math.floor(t / 3));

                        this.ctx.fillStyle = trailColor;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, trailY, trailSize, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }

                // Glow effect
                this.ctx.fillStyle = `rgba(${particle.color[0]}, ${particle.color[1]}, ${particle.color[2]}, 0.3)`;
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, particle.size + 3, 0, Math.PI * 2);
                this.ctx.fill();

                newParticles.push(particle);
            }
        }

        this.rainParticles = newParticles;
    }

    renderSoulAura(magnitudes) {
        // Get settings
        const numPoints = this.settings.soulAuraNumPoints || 60;
        const baseRadius = this.settings.soulAuraBaseRadius || 0.5;
        const glowLayers = this.settings.soulAuraGlowLayers || 5;

        const angleStep = 360 / numPoints;
        const points = [];

        // Create smooth organic shape with many points
        for (let i = 0; i < numPoints; i++) {
            const angle = (i * angleStep) * Math.PI / 180;

            // Get magnitude for this angle section
            const magIdx = Math.floor((i / numPoints) * magnitudes.length);
            const magnitude = magnitudes[Math.min(magIdx, magnitudes.length - 1)];

            // Base radius with organic variation
            const baseVariation = Math.sin(i * 0.3 + this.frameCounter * 0.05) * 30;
            const magnitudeVariation = magnitude * 150;
            const radius = this.maxRadius * baseRadius + baseVariation + magnitudeVariation;

            const x = this.centerX + radius * Math.cos(angle);
            const y = this.centerY + radius * Math.sin(angle);
            points.push({ x, y });
        }

        // Calculate average magnitude for colors
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Draw multiple layers for depth and glow (outer glow layers - purple to pink gradient)
        for (let layer = glowLayers; layer > 0; layer--) {
            const expansion = layer * 15;
            const layerPoints = [];

            for (const point of points) {
                // Expand from center
                const dx = point.x - this.centerX;
                const dy = point.y - this.centerY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const scale = 1.0 + (expansion / (dist + 1));

                const x = this.centerX + dx * scale;
                const y = this.centerY + dy * scale;
                layerPoints.push({ x, y });
            }

            // Use color scheme for glow layers
            const colorIndex = Math.floor((layer / glowLayers) * magnitudes.length);
            const colorStr = this.getColor(colorIndex, magnitudes.length);
            const rgb = this.parseRgbColor(colorStr);

            const alpha = 0.3 / layer;
            this.ctx.fillStyle = `rgba(${Math.floor(rgb[0] * alpha)}, ${Math.floor(rgb[1] * alpha)}, ${Math.floor(rgb[2] * alpha)}, ${alpha})`;

            // Draw filled polygon
            this.ctx.beginPath();
            this.ctx.moveTo(layerPoints[0].x, layerPoints[0].y);
            for (let i = 1; i < layerPoints.length; i++) {
                this.ctx.lineTo(layerPoints[i].x, layerPoints[i].y);
            }
            this.ctx.closePath();
            this.ctx.fill();
        }

        // Main aura body - use color scheme
        const mainColorIndex = Math.floor(magnitudes.length / 2);
        const mainColorStr = this.getColor(mainColorIndex, magnitudes.length);
        const mainRgb = this.parseRgbColor(mainColorStr);

        this.ctx.fillStyle = `rgb(${mainRgb[0]}, ${mainRgb[1]}, ${mainRgb[2]})`;
        this.ctx.beginPath();
        this.ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            this.ctx.lineTo(points[i].x, points[i].y);
        }
        this.ctx.closePath();
        this.ctx.fill();

        // Bright outline - use color scheme
        const outlineColorIndex = magnitudes.length - 1;
        const outlineColorStr = this.getColor(outlineColorIndex, magnitudes.length);
        this.ctx.strokeStyle = outlineColorStr;
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            this.ctx.lineTo(points[i].x, points[i].y);
        }
        this.ctx.closePath();
        this.ctx.stroke();
    }

    /**
     * Mode 5: Neon Tubes
     */
    renderNeonTubes(magnitudes) {
        const numBars = magnitudes.length;
        const angleStep = (Math.PI * 2) / numBars;
        const innerRadius = this.getEffectiveInnerRadius();

        // Glow effect
        this.ctx.shadowBlur = 30;

        for (let i = 0; i < numBars; i++) {
            const angle = i * angleStep - Math.PI / 2;
            const magnitude = magnitudes[i];
            const barLength = magnitude * this.maxRadius * 0.6;

            const x1 = this.centerX + Math.cos(angle) * innerRadius;
            const y1 = this.centerY + Math.sin(angle) * innerRadius;
            const x2 = this.centerX + Math.cos(angle) * (innerRadius + barLength);
            const y2 = this.centerY + Math.sin(angle) * (innerRadius + barLength);

            const color = this.getColor(i, numBars);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 6;
            this.ctx.lineCap = 'round';

            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 6: Vinyl Grooves
     */
    renderVinylGrooves(magnitudes) {
        const numGrooves = 8;
        const innerRadius = Math.max(20, this.getEffectiveInnerRadius() - 50);

        this.ctx.strokeStyle = `rgba(${COLORS.TEXT_PRIMARY[0]}, ${COLORS.TEXT_PRIMARY[1]}, ${COLORS.TEXT_PRIMARY[2]}, 0.3)`;
        this.ctx.lineWidth = 1;

        // Draw concentric circles
        for (let i = 0; i < numGrooves; i++) {
            const radius = innerRadius + (i * 20);
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }

        // Draw animated spectrum on grooves
        const numPoints = magnitudes.length;
        const angleStep = (Math.PI * 2) / numPoints;

        this.ctx.shadowBlur = 15;

        for (let i = 0; i < numPoints; i++) {
            const angle = i * angleStep;
            const magnitude = magnitudes[i];
            const radius = innerRadius + magnitude * 150;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, numPoints);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;

            this.ctx.beginPath();
            this.ctx.arc(x, y, 2, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 7: Soul Aura
     */
    renderSoulAura(magnitudes) {
        const numLayers = 6;
        const innerRadius = this.getEffectiveInnerRadius();

        for (let layer = 0; layer < numLayers; layer++) {
            const alpha = 0.3 - (layer * 0.04);
            const layerRadius = innerRadius + (layer * 25);

            const numPoints = magnitudes.length;
            const angleStep = (Math.PI * 2) / numPoints;

            this.ctx.beginPath();

            for (let i = 0; i <= numPoints; i++) {
                const angle = i * angleStep;
                const magnitude = magnitudes[i % numPoints];
                const radius = layerRadius + magnitude * 80;

                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;

                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }

            this.ctx.closePath();

            const scheme = COLOR_SCHEMES[this.settings.colorScheme];
            const color = scheme.primary;
            this.ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${alpha})`;
            this.ctx.fill();
        }
    }

    /**
     * Mode 8: Liquid Mercury
     */
    renderLiquidMercury(magnitudes) {
        const numPoints = magnitudes.length;
        const angleStep = (Math.PI * 2) / numPoints;
        const innerRadius = this.getEffectiveInnerRadius();
        const time = this.frameCounter * 0.02;

        const scheme = COLOR_SCHEMES[this.settings.colorScheme];
        const color1 = scheme.primary;
        const color2 = scheme.secondary;

        this.ctx.shadowBlur = 25;
        this.ctx.shadowColor = `rgba(${color1[0]}, ${color1[1]}, ${color1[2]}, 0.5)`;

        this.ctx.beginPath();

        for (let i = 0; i <= numPoints; i++) {
            const angle = i * angleStep;
            const magnitude = magnitudes[i % numPoints];
            const wave = Math.sin(angle * 3 + time) * 15;
            const radius = innerRadius + magnitude * this.maxRadius * 0.4 + wave;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            if (i === 0) {
                this.ctx.moveTo(x, y);
            } else {
                this.ctx.lineTo(x, y);
            }
        }

        this.ctx.closePath();

        // Fluid gradient using color scheme (ensure positive radii)
        const r1 = Math.max(0, innerRadius * 0.5);
        const r2 = Math.max(r1 + 1, innerRadius + this.maxRadius * 0.4);
        const gradient = this.ctx.createRadialGradient(
            this.centerX, this.centerY, r1,
            this.centerX, this.centerY, r2
        );

        gradient.addColorStop(0, `rgba(${color1[0]}, ${color1[1]}, ${color1[2]}, 0.9)`);
        gradient.addColorStop(0.5, `rgba(${Math.round((color1[0] + color2[0]) / 2)}, ${Math.round((color1[1] + color2[1]) / 2)}, ${Math.round((color1[2] + color2[2]) / 2)}, 0.8)`);
        gradient.addColorStop(1, `rgba(${color2[0]}, ${color2[1]}, ${color2[2]}, 0.6)`);

        this.ctx.fillStyle = gradient;
        this.ctx.fill();

        this.ctx.strokeStyle = `rgba(${color1[0]}, ${color1[1]}, ${color1[2]}, 0.9)`;
        this.ctx.lineWidth = 2;
        this.ctx.stroke();

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 9: Aurora Waves
     */
    renderAuroraWaves(magnitudes) {
        const numWaves = 4;
        const innerRadius = this.getEffectiveInnerRadius();
        const time = this.frameCounter * 0.01;

        for (let wave = 0; wave < numWaves; wave++) {
            const waveOffset = wave * 0.5;
            const numPoints = magnitudes.length;
            const angleStep = (Math.PI * 2) / numPoints;

            this.ctx.beginPath();

            for (let i = 0; i <= numPoints; i++) {
                const angle = i * angleStep;
                const magnitude = magnitudes[i % numPoints];
                const waveMod = Math.sin(angle * 2 + time + waveOffset) * 20;
                const radius = innerRadius + (wave * 30) + magnitude * 60 + waveMod;

                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;

                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }

            this.ctx.closePath();

            const alpha = 0.3 - (wave * 0.05);
            const color = this.getColor(wave * 25, 100);
            const rgbMatch = color.match(/\d+/g);
            if (rgbMatch) {
                this.ctx.fillStyle = `rgba(${rgbMatch[0]}, ${rgbMatch[1]}, ${rgbMatch[2]}, ${alpha})`;
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 10: Mandala Growth
     */
    renderMandalaGrowth(magnitudes) {
        const symmetry = 8;
        const numBars = magnitudes.length / symmetry;
        const angleStep = (Math.PI * 2) / (numBars * symmetry);
        const innerRadius = this.getEffectiveInnerRadius();

        this.ctx.shadowBlur = 20;

        for (let sym = 0; sym < symmetry; sym++) {
            const symAngle = (Math.PI * 2 / symmetry) * sym;

            for (let i = 0; i < numBars; i++) {
                const angle = i * angleStep * symmetry + symAngle;
                const magnitude = magnitudes[i % magnitudes.length];
                const barLength = magnitude * this.maxRadius * 0.5;

                const x1 = this.centerX + Math.cos(angle) * innerRadius;
                const y1 = this.centerY + Math.sin(angle) * innerRadius;
                const x2 = this.centerX + Math.cos(angle) * (innerRadius + barLength);
                const y2 = this.centerY + Math.sin(angle) * (innerRadius + barLength);

                const color = this.getColor(i, numBars);
                this.ctx.shadowColor = color;
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 3;
                this.ctx.lineCap = 'round';

                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x2, y2);
                this.ctx.stroke();
            }
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 11: Frequency Bars
     */
    renderFrequencyBars(magnitudes) {
        const numBars = magnitudes.length;
        const barWidth = this.canvas.width / numBars;
        const centerY = this.canvas.height / 2;

        this.ctx.shadowBlur = 10;

        for (let i = 0; i < numBars; i++) {
            const barHeight = magnitudes[i] * this.canvas.height * 0.7;
            const x = i * barWidth;
            const y = centerY - barHeight / 2;

            const color = this.getColor(i, numBars);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;

            this.ctx.fillRect(x, y, barWidth * 0.8, barHeight);
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 12: Linear Spectrum
     */
    renderLinearSpectrum(magnitudes) {
        const numBars = magnitudes.length;
        const barWidth = this.canvas.width / numBars;
        const baseY = this.canvas.height * 0.75;

        this.ctx.shadowBlur = 12;

        for (let i = 0; i < numBars; i++) {
            const barHeight = magnitudes[i] * this.canvas.height * 0.6;
            const x = i * barWidth;
            const y = baseY - barHeight;

            const color = this.getColor(i, numBars);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;

            this.ctx.fillRect(x, y, barWidth * 0.9, barHeight);
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Classic Mode 3: Particles - Glowing particle system
     */
    renderClassicParticles(magnitudes) {
        const params = this.settings.modeParameters || {};
        const particleCount = params.particleCount || 200;
        const particleSize = params.particleSize || 3;
        const glowIntensity = params.glowIntensity || 1;

        // Initialize particles if not exists
        if (!this.classicParticles || this.classicParticles.length !== particleCount) {
            this.classicParticles = [];
            for (let i = 0; i < particleCount; i++) {
                this.classicParticles.push({
                    angle: (Math.PI * 2 * i) / particleCount,
                    distance: Math.random() * this.maxRadius * 0.5,
                    speed: 0.5 + Math.random() * 1.5,
                    phase: Math.random() * Math.PI * 2
                });
            }
        }

        this.ctx.shadowBlur = 15 * glowIntensity;

        this.classicParticles.forEach((particle, i) => {
            const magnitude = magnitudes[Math.floor((i / particleCount) * magnitudes.length)];
            particle.phase += 0.02;
            particle.angle += particle.speed * 0.01;

            const radius = particle.distance + magnitude * this.maxRadius * 0.3;
            const x = this.centerX + Math.cos(particle.angle) * radius;
            const y = this.centerY + Math.sin(particle.angle) * radius;

            const color = this.getColor(i, particleCount);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;

            this.ctx.beginPath();
            this.ctx.arc(x, y, particleSize, 0, Math.PI * 2);
            this.ctx.fill();
        });

        this.ctx.shadowBlur = 0;
    }

    /**
     * Classic Mode 5: Polygon - Geometric polygon that pulses
     */
    renderClassicPolygon(magnitudes) {
        const params = this.settings.modeParameters || {};
        const sides = Math.floor(params.sides || 6);
        const rotationSpeed = params.rotationSpeed || 1;
        const pulseIntensity = params.pulseIntensity || 1;

        if (!this.polygonRotation) this.polygonRotation = 0;
        this.polygonRotation += 0.01 * rotationSpeed;

        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const baseRadius = this.maxRadius * 0.5;
        const pulseRadius = baseRadius + avgMagnitude * this.maxRadius * 0.3 * pulseIntensity;

        this.ctx.shadowBlur = 20;
        this.ctx.lineWidth = 4;

        // Draw main polygon
        this.ctx.beginPath();
        for (let i = 0; i <= sides; i++) {
            const angle = (Math.PI * 2 * i) / sides + this.polygonRotation;
            const magIndex = Math.floor((i / sides) * magnitudes.length);
            const magnitude = magnitudes[magIndex];
            const radius = pulseRadius + magnitude * 50;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            if (i === 0) {
                this.ctx.moveTo(x, y);
            } else {
                this.ctx.lineTo(x, y);
            }
        }

        this.ctx.closePath();

        const color = this.getColor(0, 1);
        this.ctx.strokeStyle = color;
        this.ctx.shadowColor = color;
        this.ctx.stroke();

        this.ctx.shadowBlur = 0;
    }

    /**
     * Classic Mode 6: Spiral - Spiral pattern radiating from center
     */
    renderClassicSpiral(magnitudes) {
        const params = this.settings.modeParameters || {};
        const spiralArms = Math.floor(params.spiralArms || 3);
        const tightness = params.tightness || 1;
        const rotationSpeed = params.rotationSpeed || 1;

        if (!this.spiralRotation) this.spiralRotation = 0;
        this.spiralRotation += 0.02 * rotationSpeed;

        this.ctx.shadowBlur = 15;
        this.ctx.lineWidth = 3;

        for (let arm = 0; arm < spiralArms; arm++) {
            this.ctx.beginPath();
            const armOffset = (Math.PI * 2 * arm) / spiralArms;

            for (let i = 0; i < magnitudes.length; i++) {
                const progress = i / magnitudes.length;
                const angle = progress * Math.PI * 4 * tightness + armOffset + this.spiralRotation;
                const radius = progress * this.maxRadius * 0.8;
                const magnitude = magnitudes[i];

                const x = this.centerX + Math.cos(angle) * (radius + magnitude * 30);
                const y = this.centerY + Math.sin(angle) * (radius + magnitude * 30);

                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }

            const color = this.getColor(arm * 30, spiralArms * 30);
            this.ctx.strokeStyle = color;
            this.ctx.shadowColor = color;
            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Classic Mode 7: DNA Helix - Double helix structure
     */
    renderClassicDNAHelix(magnitudes) {
        const params = this.settings.modeParameters || {};
        const helixTightness = params.helixTightness || 1;
        const rotationSpeed = params.rotationSpeed || 1.5;
        const basePairs = Math.floor(params.basePairs || 20);

        if (!this.helixRotation) this.helixRotation = 0;
        this.helixRotation += 0.02 * rotationSpeed;

        this.ctx.shadowBlur = 12;
        this.ctx.lineWidth = 3;

        const numPoints = magnitudes.length;
        const heightSpacing = this.canvas.height / numPoints;

        // Draw both helices
        for (let helix = 0; helix < 2; helix++) {
            this.ctx.beginPath();
            const phaseShift = helix * Math.PI;

            for (let i = 0; i < numPoints; i++) {
                const y = i * heightSpacing;
                const angle = (i / numPoints) * Math.PI * 6 * helixTightness + this.helixRotation + phaseShift;
                const magnitude = magnitudes[i];
                const radius = 100 + magnitude * 50;
                const x = this.centerX + Math.cos(angle) * radius;

                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }

            const color = this.getColor(helix * 50, 100);
            this.ctx.strokeStyle = color;
            this.ctx.shadowColor = color;
            this.ctx.stroke();
        }

        // Draw base pairs
        for (let i = 0; i < basePairs; i++) {
            const index = Math.floor((i / basePairs) * numPoints);
            const y = index * heightSpacing;
            const angle1 = (index / numPoints) * Math.PI * 6 * helixTightness + this.helixRotation;
            const angle2 = angle1 + Math.PI;
            const magnitude = magnitudes[index];
            const radius = 100 + magnitude * 50;

            const x1 = this.centerX + Math.cos(angle1) * radius;
            const x2 = this.centerX + Math.cos(angle2) * radius;

            this.ctx.beginPath();
            this.ctx.moveTo(x1, y);
            this.ctx.lineTo(x2, y);
            this.ctx.strokeStyle = this.getColor(i, basePairs);
            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Classic Mode 8: Kaleidoscope - Mirrored symmetric patterns
     */
    renderClassicKaleidoscope(magnitudes) {
        const params = this.settings.modeParameters || {};
        const segments = Math.floor(params.segments || 8);
        const complexity = Math.floor(params.complexity || 5);
        const rotationSpeed = params.rotationSpeed || 1;

        if (!this.kaleidoscopeRotation) this.kaleidoscopeRotation = 0;
        this.kaleidoscopeRotation += 0.01 * rotationSpeed;

        this.ctx.shadowBlur = 15;

        for (let seg = 0; seg < segments; seg++) {
            const segmentAngle = (Math.PI * 2 * seg) / segments;

            this.ctx.save();
            this.ctx.translate(this.centerX, this.centerY);
            this.ctx.rotate(segmentAngle + this.kaleidoscopeRotation);

            for (let i = 0; i < complexity; i++) {
                const magIndex = Math.floor((i / complexity) * magnitudes.length);
                const magnitude = magnitudes[magIndex];
                const radius = (i / complexity) * this.maxRadius * 0.7;
                const size = magnitude * 30 + 5;

                const color = this.getColor(i + seg * complexity, complexity * segments);
                this.ctx.fillStyle = color;
                this.ctx.shadowColor = color;

                this.ctx.beginPath();
                this.ctx.arc(radius, 0, size, 0, Math.PI * 2);
                this.ctx.fill();

                // Mirror
                this.ctx.beginPath();
                this.ctx.arc(radius, 0, size, 0, Math.PI * 2);
                this.ctx.scale(1, -1);
                this.ctx.fill();
                this.ctx.scale(1, -1);
            }

            this.ctx.restore();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Classic Mode 9: Pulse Rings - Pulsing concentric rings
     */
    renderClassicPulseRings(magnitudes) {
        const params = this.settings.modeParameters || {};
        const ringCount = Math.floor(params.ringCount || 8);
        const pulseSpeed = params.pulseSpeed || 1;
        const spacing = params.spacing || 25;

        if (!this.ringPulsePhase) this.ringPulsePhase = 0;
        this.ringPulsePhase += 0.05 * pulseSpeed;

        this.ctx.shadowBlur = 18;
        this.ctx.lineWidth = 4;

        for (let i = 0; i < ringCount; i++) {
            const magIndex = Math.floor((i / ringCount) * magnitudes.length);
            const magnitude = magnitudes[magIndex];
            const baseRadius = (i + 1) * spacing + (this.maxRadius * 0.2);
            const pulse = Math.sin(this.ringPulsePhase + i * 0.5) * 20;
            const radius = baseRadius + magnitude * 40 + pulse;

            const color = this.getColor(i, ringCount);
            this.ctx.strokeStyle = color;
            this.ctx.shadowColor = color;

            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Classic Mode 10: Star Burst - Starburst effect radiating from center
     */
    renderClassicStarBurst(magnitudes) {
        const params = this.settings.modeParameters || {};
        const rayCount = Math.floor(params.rayCount || 24);
        const rayLength = params.rayLength || 1;
        const pulseIntensity = params.pulseIntensity || 1;

        this.ctx.shadowBlur = 20;
        this.ctx.lineWidth = 3;
        this.ctx.lineCap = 'round';

        const angleStep = (Math.PI * 2) / rayCount;

        for (let i = 0; i < rayCount; i++) {
            const angle = i * angleStep;
            const magIndex = Math.floor((i / rayCount) * magnitudes.length);
            const magnitude = magnitudes[magIndex];

            const startRadius = this.maxRadius * 0.1;
            const endRadius = this.maxRadius * 0.7 * rayLength + magnitude * this.maxRadius * 0.3 * pulseIntensity;

            const x1 = this.centerX + Math.cos(angle) * startRadius;
            const y1 = this.centerY + Math.sin(angle) * startRadius;
            const x2 = this.centerX + Math.cos(angle) * endRadius;
            const y2 = this.centerY + Math.sin(angle) * endRadius;

            const color = this.getColor(i, rayCount);
            this.ctx.strokeStyle = color;
            this.ctx.shadowColor = color;

            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 851: Classic Bars - Traditional vertical bars
     */
    renderClassicBars(magnitudes) {
        const params = this.settings.modeParameters || {};
        const barWidth = params.barWidth || 8;
        const barSpacing = params.barSpacing || 2;
        const barRounding = params.barRounding || 0;

        const numBars = magnitudes.length;

        // Calculate if we need to scale bars to fit canvas width
        const requestedWidth = numBars * (barWidth + barSpacing);
        const availableWidth = this.canvas.width * 0.95; // Use 95% of canvas width
        const widthScale = Math.min(1, availableWidth / requestedWidth);

        const scaledBarWidth = barWidth * widthScale;
        const scaledBarSpacing = barSpacing * widthScale;
        const totalWidth = numBars * (scaledBarWidth + scaledBarSpacing);
        const startX = (this.canvas.width - totalWidth) / 2;
        const baseY = this.canvas.height * 0.95; // Use more vertical space
        const maxBarHeight = this.canvas.height * 0.85; // Bars can use up to 85% of height

        this.ctx.shadowBlur = 10 * this.scaleFactor;

        for (let i = 0; i < numBars; i++) {
            // Boost magnitude for better visibility (min 30% height, max 100% height)
            const boostedMagnitude = 0.3 + (magnitudes[i] * 0.7);
            const barHeight = boostedMagnitude * maxBarHeight;
            const x = startX + i * (scaledBarWidth + scaledBarSpacing);
            const y = baseY - barHeight;

            const color = this.getColor(i, numBars);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;

            if (barRounding > 0) {
                this.roundedRect(x, y, scaledBarWidth, barHeight, barRounding * widthScale);
            } else {
                this.ctx.fillRect(x, y, scaledBarWidth, barHeight);
            }
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 852: Mirror Symmetry - Mirrored bars with central symmetry
     */
    renderMirrorSymmetry(magnitudes) {
        const params = this.settings.modeParameters || {};
        const barWidth = params.barWidth || 8;
        const barSpacing = params.barSpacing || 2;
        const mirrorGap = params.mirrorGap || 20;

        const numBars = magnitudes.length;

        // Calculate if we need to scale bars to fit canvas width
        const requestedWidth = numBars * (barWidth + barSpacing);
        const availableWidth = this.canvas.width * 0.95; // Use 95% of canvas width
        const widthScale = Math.min(1, availableWidth / requestedWidth);

        const scaledBarWidth = barWidth * widthScale;
        const scaledBarSpacing = barSpacing * widthScale;
        const scaledMirrorGap = mirrorGap * this.scaleFactor;
        const totalWidth = numBars * (scaledBarWidth + scaledBarSpacing);
        const startX = (this.canvas.width - totalWidth) / 2;
        const centerY = this.canvas.height / 2;
        const maxBarHeight = this.canvas.height * 0.45; // Each half can use up to 45% of height

        this.ctx.shadowBlur = 10 * this.scaleFactor;

        for (let i = 0; i < numBars; i++) {
            // Boost magnitude for better visibility (min 30% height, max 100% height)
            const boostedMagnitude = 0.3 + (magnitudes[i] * 0.7);
            const barHeight = boostedMagnitude * maxBarHeight;
            const x = startX + i * (scaledBarWidth + scaledBarSpacing);

            const color = this.getColor(i, numBars);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;

            // Top bars
            this.ctx.fillRect(x, centerY - barHeight - scaledMirrorGap / 2, scaledBarWidth, barHeight);
            // Bottom bars (mirrored)
            this.ctx.fillRect(x, centerY + scaledMirrorGap / 2, scaledBarWidth, barHeight);
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 853: Waterfall - Cascading effect with trailing bars
     */
    renderWaterfall(magnitudes) {
        const params = this.settings.modeParameters || {};
        const trailLength = params.trailLength || 10;
        const fallSpeed = params.fallSpeed || 5;
        const fadeAmount = params.fadeAmount || 0.5;

        if (!this.waterfallHistory) {
            this.waterfallHistory = [];
        }

        // Add current magnitudes to history
        this.waterfallHistory.unshift([...magnitudes]);

        // Keep only trailLength frames
        if (this.waterfallHistory.length > trailLength) {
            this.waterfallHistory.pop();
        }

        const numBars = magnitudes.length;
        const barWidth = this.canvas.width / numBars;

        // Draw each historical frame
        for (let t = 0; t < this.waterfallHistory.length; t++) {
            const histMagnitudes = this.waterfallHistory[t];
            const y = t * (this.canvas.height / trailLength);
            const alpha = 1 - (t / this.waterfallHistory.length) * fadeAmount;

            this.ctx.globalAlpha = alpha;

            for (let i = 0; i < numBars; i++) {
                const barHeight = histMagnitudes[i] * (this.canvas.height / trailLength) * 0.8;
                const x = i * barWidth;

                const color = this.getColor(i, numBars);
                this.ctx.fillStyle = color;
                this.ctx.fillRect(x, y, barWidth * 0.9, barHeight);
            }
        }

        this.ctx.globalAlpha = 1;
    }

    /**
     * Mode 854: Converging Lines - Lines meeting at center point
     */
    renderConvergingLines(magnitudes) {
        const params = this.settings.modeParameters || {};
        const lineCount = params.lineCount || 50;
        const convergencePoint = params.convergencePoint || 0.5;
        const lineWidth = params.lineWidth || 2;

        const numBars = Math.min(magnitudes.length, lineCount);
        const angleStep = (Math.PI * 2) / numBars;
        const convergeX = this.canvas.width * convergencePoint;
        const convergeY = this.canvas.height * convergencePoint;

        this.ctx.lineWidth = lineWidth;
        this.ctx.shadowBlur = 8;

        for (let i = 0; i < numBars; i++) {
            const angle = i * angleStep;
            const magnitude = magnitudes[i];
            const distance = magnitude * Math.min(this.canvas.width, this.canvas.height) * 0.45;

            const startX = convergeX + Math.cos(angle) * distance;
            const startY = convergeY + Math.sin(angle) * distance;

            const color = this.getColor(i, numBars);
            this.ctx.strokeStyle = color;
            this.ctx.shadowColor = color;

            this.ctx.beginPath();
            this.ctx.moveTo(startX, startY);
            this.ctx.lineTo(convergeX, convergeY);
            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 855: Wave Morph - Morphing wave patterns
     */
    renderWaveMorph(magnitudes) {
        const params = this.settings.modeParameters || {};
        const waveAmplitude = params.waveAmplitude || 50;
        const waveFrequency = params.waveFrequency || 3;
        const morphSpeed = params.morphSpeed || 0.5;

        const numPoints = magnitudes.length;
        const segmentWidth = this.canvas.width / (numPoints - 1);
        const centerY = this.canvas.height / 2;
        const time = this.frameCounter * morphSpeed * 0.01;

        this.ctx.lineWidth = 3;
        this.ctx.shadowBlur = 15;

        // Draw multiple morphing waves
        for (let wave = 0; wave < 3; wave++) {
            this.ctx.beginPath();

            for (let i = 0; i < numPoints; i++) {
                const x = i * segmentWidth;
                const magnitude = magnitudes[i];
                const morphOffset = Math.sin(time + wave * Math.PI * 0.66) * waveAmplitude;
                const waveOffset = Math.sin((i / numPoints) * Math.PI * waveFrequency + time) * waveAmplitude;
                const y = centerY + (magnitude * waveAmplitude * 2) + morphOffset + waveOffset;

                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }

            const color = this.getColor(wave * (numPoints / 3), numPoints);
            this.ctx.strokeStyle = color;
            this.ctx.shadowColor = color;
            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 856: Staggered Pulse - Offset pulsing bars with delay
     */
    renderStaggeredPulse(magnitudes) {
        const params = this.settings.modeParameters || {};
        const staggerAmount = params.staggerAmount || 3;
        const pulseSpeed = params.pulseSpeed || 1;
        const barCount = params.barCount || 60;

        const numBars = Math.min(magnitudes.length, barCount);
        const barWidth = this.canvas.width / numBars;
        const baseY = this.canvas.height * 0.8;

        this.ctx.shadowBlur = 12;

        for (let i = 0; i < numBars; i++) {
            // Calculate stagger offset for each bar
            const staggerOffset = Math.sin((this.frameCounter * pulseSpeed * 0.05) - (i * staggerAmount * 0.1));
            const barHeight = magnitudes[i] * this.canvas.height * 0.6 * (0.5 + staggerOffset * 0.5);
            const x = i * barWidth;
            const y = baseY - barHeight;

            const color = this.getColor(i, numBars);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;

            this.ctx.fillRect(x, y, barWidth * 0.85, barHeight);
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 857: Geometric Tunnel - 3D tunnel effect with perspective
     */
    renderGeometricTunnel(magnitudes) {
        const params = this.settings.modeParameters || {};
        const tunnelDepth = params.tunnelDepth || 8;
        const rotationSpeed = params.rotationSpeed || 1;
        const segmentCount = params.segmentCount || 6;

        const rotation = this.frameCounter * rotationSpeed * 0.02;

        this.ctx.shadowBlur = 15;

        for (let depth = tunnelDepth; depth > 0; depth--) {
            const scale = depth / tunnelDepth;
            const size = scale * Math.min(this.canvas.width, this.canvas.height) * 0.4;
            const angleOffset = rotation * (tunnelDepth - depth + 1);
            const magIndex = Math.floor(((tunnelDepth - depth) / tunnelDepth) * magnitudes.length);
            const magnitude = magnitudes[magIndex];

            this.ctx.save();
            this.ctx.translate(this.centerX, this.centerY);
            this.ctx.rotate(angleOffset);

            const color = this.getColor(magIndex, magnitudes.length);
            this.ctx.strokeStyle = color;
            this.ctx.shadowColor = color;
            this.ctx.lineWidth = 2 + magnitude * 5;

            this.ctx.beginPath();
            for (let i = 0; i <= segmentCount; i++) {
                const angle = (i / segmentCount) * Math.PI * 2;
                const x = Math.cos(angle) * size * (1 + magnitude * 0.3);
                const y = Math.sin(angle) * size * (1 + magnitude * 0.3);

                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }
            this.ctx.closePath();
            this.ctx.stroke();

            this.ctx.restore();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 858: Dancing Ribbons - Flowing ribbon-like curves
     */
    renderDancingRibbons(magnitudes) {
        const params = this.settings.modeParameters || {};
        const ribbonWidth = params.ribbonWidth || 20;
        const flowSpeed = params.flowSpeed || 1.5;
        const waveCount = params.waveCount || 4;

        const numPoints = magnitudes.length;
        const segmentWidth = this.canvas.width / (numPoints - 1);
        const time = this.frameCounter * flowSpeed * 0.02;

        for (let ribbon = 0; ribbon < waveCount; ribbon++) {
            const yOffset = (this.canvas.height / (waveCount + 1)) * (ribbon + 1);
            const phase = (ribbon / waveCount) * Math.PI * 2;

            this.ctx.lineWidth = ribbonWidth;
            this.ctx.lineCap = 'round';
            this.ctx.shadowBlur = 20;

            const color = this.getColor(ribbon * (numPoints / waveCount), numPoints);
            this.ctx.strokeStyle = color;
            this.ctx.shadowColor = color;

            this.ctx.beginPath();
            for (let i = 0; i < numPoints; i++) {
                const x = i * segmentWidth;
                const magnitude = magnitudes[i];
                const waveY = Math.sin((i / numPoints) * Math.PI * 3 + time + phase) * 50;
                const y = yOffset + waveY + (magnitude * 100);

                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }
            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 859: Particle Stream - Particle streams flowing along lines
     */
    renderParticleStream(magnitudes) {
        const params = this.settings.modeParameters || {};
        const particleCount = params.particleCount || 200;
        const streamSpeed = params.streamSpeed || 5;
        const particleSize = params.particleSize || 3;

        if (!this.streamParticles) {
            this.streamParticles = [];
        }

        // Create new particles
        while (this.streamParticles.length < particleCount) {
            this.streamParticles.push({
                x: Math.random() * this.canvas.width,
                y: Math.random() * this.canvas.height,
                vx: (Math.random() - 0.5) * streamSpeed,
                vy: (Math.random() - 0.5) * streamSpeed,
                age: Math.random()
            });
        }

        this.ctx.shadowBlur = 15;

        // Update and draw particles
        for (let i = this.streamParticles.length - 1; i >= 0; i--) {
            const particle = this.streamParticles[i];
            const magIndex = Math.floor((particle.x / this.canvas.width) * magnitudes.length);
            const magnitude = magnitudes[magIndex] || 0;

            // Update position
            particle.x += particle.vx;
            particle.y += particle.vy * (1 + magnitude);
            particle.age += 0.01;

            // Wrap around screen
            if (particle.x < 0) particle.x = this.canvas.width;
            if (particle.x > this.canvas.width) particle.x = 0;
            if (particle.y < 0) particle.y = this.canvas.height;
            if (particle.y > this.canvas.height) particle.y = 0;

            // Draw particle
            const color = this.getColor(magIndex, magnitudes.length);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = 0.7;

            this.ctx.beginPath();
            this.ctx.arc(particle.x, particle.y, particleSize * (0.5 + magnitude * 0.5), 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 860: Glitch Art - Glitch aesthetic with digital artifacts
     */
    renderGlitchArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const glitchIntensity = params.glitchIntensity || 0.5;
        const glitchFrequency = params.glitchFrequency || 0.3;
        const colorShift = params.colorShift || 10;

        const numBars = magnitudes.length;
        const barWidth = this.canvas.width / numBars;
        const baseY = this.canvas.height * 0.75;

        // Determine if this frame should glitch
        const shouldGlitch = Math.random() < glitchFrequency;

        for (let i = 0; i < numBars; i++) {
            const barHeight = magnitudes[i] * this.canvas.height * 0.6;
            const x = i * barWidth;
            let y = baseY - barHeight;

            // Apply glitch offset
            if (shouldGlitch) {
                y += (Math.random() - 0.5) * glitchIntensity * 100;
            }

            const color = this.getColor(i, numBars);

            // RGB split effect on glitch
            if (shouldGlitch && Math.random() < glitchIntensity) {
                // Draw RGB channels separately
                this.ctx.fillStyle = `rgba(255, 0, 0, 0.5)`;
                this.ctx.fillRect(x - colorShift, y, barWidth * 0.9, barHeight);

                this.ctx.fillStyle = `rgba(0, 255, 0, 0.5)`;
                this.ctx.fillRect(x, y, barWidth * 0.9, barHeight);

                this.ctx.fillStyle = `rgba(0, 0, 255, 0.5)`;
                this.ctx.fillRect(x + colorShift, y, barWidth * 0.9, barHeight);
            } else {
                this.ctx.fillStyle = color;
                this.ctx.fillRect(x, y, barWidth * 0.9, barHeight);
            }

            // Add digital artifacts
            if (shouldGlitch && Math.random() < glitchIntensity * 0.5) {
                this.ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.5})`;
                this.ctx.fillRect(
                    Math.random() * this.canvas.width,
                    Math.random() * this.canvas.height,
                    Math.random() * 100,
                    Math.random() * 5
                );
            }
        }
    }

    /**
     * Mode 861: Circular Waves - Concentric circular waves that expand from center
     */
    renderCircularWaves(magnitudes) {
        const params = this.settings.modeParameters || {};
        const waveCount = params.waveCount || 10;
        const waveThickness = params.waveThickness || 3;
        const waveSpacing = params.waveSpacing || 25;

        this.ctx.shadowBlur = 15;

        for (let w = 0; w < waveCount; w++) {
            const baseRadius = w * waveSpacing;
            const numPoints = 100;
            const angleStep = (Math.PI * 2) / numPoints;

            this.ctx.beginPath();
            this.ctx.strokeStyle = this.getColor(w, waveCount);
            this.ctx.lineWidth = waveThickness;
            this.ctx.lineCap = 'round';

            for (let i = 0; i <= numPoints; i++) {
                const angle = i * angleStep;
                const magIndex = Math.floor((i / numPoints) * magnitudes.length);
                const magnitude = magnitudes[magIndex % magnitudes.length];
                const radius = baseRadius + magnitude * 50;

                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;

                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }

            this.ctx.closePath();
            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 862: Line Spectrum - Horizontal frequency lines stacked vertically
     */
    renderLineSpectrum(magnitudes) {
        const params = this.settings.modeParameters || {};
        const lineCount = params.lineCount || 50;
        const lineThickness = params.lineThickness || 2;
        const lineSpacing = params.lineSpacing || 5;

        const numBars = magnitudes.length;

        // Scale line spacing to fill the canvas height (stretch or compress as needed)
        const availableHeight = this.canvas.height * 0.95; // Use 95% of canvas height
        const scaledLineSpacing = availableHeight / lineCount;
        const scaledLineThickness = Math.max(1, lineThickness * this.scaleFactor);
        const totalHeight = lineCount * scaledLineSpacing;
        const startY = (this.canvas.height - totalHeight) / 2;
        const maxLineWidth = this.canvas.width * 0.95; // Use up to 95% of canvas width

        this.ctx.shadowBlur = 10 * this.scaleFactor;

        for (let i = 0; i < lineCount; i++) {
            const y = startY + i * scaledLineSpacing;
            const magIndex = Math.floor((i / lineCount) * numBars);
            const magnitude = magnitudes[magIndex % numBars];

            // Boost magnitude for better visibility (min 40% width, max 95% width)
            const boostedMagnitude = 0.4 + (magnitude * 0.55);
            const lineWidth = boostedMagnitude * maxLineWidth;
            const x = (this.canvas.width - lineWidth) / 2;

            const color = this.getColor(i, lineCount);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = scaledLineThickness;
            this.ctx.lineCap = 'round';

            this.ctx.beginPath();
            this.ctx.moveTo(x, y);
            this.ctx.lineTo(x + lineWidth, y);
            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 863: Radial Pulse - Pulsing circles radiating from center
     */
    renderRadialPulse(magnitudes) {
        const params = this.settings.modeParameters || {};
        const ringCount = params.ringCount || 15;
        const pulseIntensity = params.pulseIntensity || 1;
        const ringThickness = params.ringThickness || 4;

        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const basePulse = avgMagnitude * pulseIntensity * 100;

        this.ctx.shadowBlur = 20;

        for (let i = 0; i < ringCount; i++) {
            const ringProgress = i / ringCount;
            const magIndex = Math.floor(ringProgress * magnitudes.length);
            const magnitude = magnitudes[magIndex % magnitudes.length];

            const baseRadius = 50 + i * 30;
            const radius = baseRadius + basePulse * (1 - ringProgress) + magnitude * 40;

            const color = this.getColor(i, ringCount);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = ringThickness;
            this.ctx.globalAlpha = 0.7 - ringProgress * 0.4;

            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 864: Double Helix - DNA-like double spiral pattern
     */
    renderDoubleHelix(magnitudes) {
        const params = this.settings.modeParameters || {};
        const helixTurns = params.helixTurns || 5;
        const helixWidth = params.helixWidth || 100;
        const pointSize = params.pointSize || 6;

        const numPoints = magnitudes.length;
        const heightPerTurn = this.canvas.height / helixTurns;
        const time = this.frameCounter * 0.02;

        this.ctx.shadowBlur = 15;

        for (let i = 0; i < numPoints; i++) {
            const progress = i / numPoints;
            const y = progress * this.canvas.height;
            const angle = progress * Math.PI * 2 * helixTurns + time;

            const magnitude = magnitudes[i];
            const size = pointSize + magnitude * 8;

            // First helix strand
            const x1 = this.centerX + Math.cos(angle) * helixWidth;
            const color1 = this.getColor(i, numPoints);
            this.ctx.shadowColor = color1;
            this.ctx.fillStyle = color1;

            this.ctx.beginPath();
            this.ctx.arc(x1, y, size, 0, Math.PI * 2);
            this.ctx.fill();

            // Second helix strand (180 degrees offset)
            const x2 = this.centerX + Math.cos(angle + Math.PI) * helixWidth;
            const color2 = this.getColor(i + numPoints / 2, numPoints);
            this.ctx.shadowColor = color2;
            this.ctx.fillStyle = color2;

            this.ctx.beginPath();
            this.ctx.arc(x2, y, size, 0, Math.PI * 2);
            this.ctx.fill();

            // Draw connecting lines periodically
            if (i % 5 === 0) {
                this.ctx.strokeStyle = this.getColor(i, numPoints);
                this.ctx.lineWidth = 2;
                this.ctx.globalAlpha = 0.3;
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y);
                this.ctx.lineTo(x2, y);
                this.ctx.stroke();
                this.ctx.globalAlpha = 1;
            }
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 865: Spiral Bars - Frequency bars arranged in spiral pattern
     */
    renderSpiralBars(magnitudes) {
        const params = this.settings.modeParameters || {};
        const spiralTurns = params.spiralTurns || 3;
        const barLength = params.barLength || 50;
        const spiralTightness = params.spiralTightness || 1;

        const numBars = magnitudes.length;
        const time = this.frameCounter * 0.01;

        this.ctx.shadowBlur = 10;

        for (let i = 0; i < numBars; i++) {
            const progress = i / numBars;
            const angle = progress * Math.PI * 2 * spiralTurns + time;
            const radius = 50 + progress * this.maxRadius * 0.6 * spiralTightness;

            const magnitude = magnitudes[i];
            const length = barLength + magnitude * 80;

            const x1 = this.centerX + Math.cos(angle) * radius;
            const y1 = this.centerY + Math.sin(angle) * radius;
            const x2 = this.centerX + Math.cos(angle) * (radius + length);
            const y2 = this.centerY + Math.sin(angle) * (radius + length);

            const color = this.getColor(i, numBars);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 4;
            this.ctx.lineCap = 'round';

            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Helper: Draw rounded rectangle
     */
    roundedRect(x, y, width, height, radius) {
        this.ctx.beginPath();
        this.ctx.moveTo(x + radius, y);
        this.ctx.lineTo(x + width - radius, y);
        this.ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        this.ctx.lineTo(x + width, y + height);
        this.ctx.lineTo(x, y + height);
        this.ctx.lineTo(x, y + radius);
        this.ctx.quadraticCurveTo(x, y, x + radius, y);
        this.ctx.closePath();
        this.ctx.fill();
    }

    /**
     * Mode 13: Fireworks
     */
    renderFireworks(magnitudes) {
        const numBars = magnitudes.length;
        const angleStep = (Math.PI * 2) / numBars;

        this.ctx.shadowBlur = 30;

        for (let i = 0; i < numBars; i++) {
            const angle = i * angleStep;
            const magnitude = magnitudes[i];
            const distance = magnitude * this.maxRadius * 1.2;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            // Trail effect
            for (let t = 0; t < 3; t++) {
                const trailDist = distance * (0.5 + t * 0.2);
                const tx = this.centerX + Math.cos(angle) * trailDist;
                const ty = this.centerY + Math.sin(angle) * trailDist;
                const size = (3 - t) * magnitude * 3;

                const color = this.getColor(i, numBars);
                this.ctx.shadowColor = color;
                this.ctx.fillStyle = color;
                this.ctx.globalAlpha = 0.3 + t * 0.3;

                this.ctx.beginPath();
                this.ctx.arc(tx, ty, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 14: Cosmic Dust
     */
    renderCosmicDust(magnitudes) {
        const numParticles = magnitudes.length * 3;
        const time = this.frameCounter * 0.01;

        this.ctx.shadowBlur = 20;

        for (let i = 0; i < numParticles; i++) {
            const angle = (i / numParticles) * Math.PI * 2 + time;
            const magnitude = magnitudes[i % magnitudes.length];
            const spiral = i / numParticles;
            const distance = this.getEffectiveInnerRadius() + spiral * this.maxRadius * 0.8 + magnitude * 50;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;
            const size = 2 + magnitude * 4;

            const color = this.getColor(i, numParticles);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = 0.6 + magnitude * 0.4;

            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 15: Particle Rain
     */
    renderParticleRain(magnitudes) {
        const numBars = magnitudes.length;
        const barWidth = this.canvas.width / numBars;

        this.ctx.shadowBlur = 15;

        for (let i = 0; i < numBars; i++) {
            const magnitude = magnitudes[i];
            const numDrops = Math.floor(magnitude * 8);
            const x = i * barWidth + barWidth / 2;

            for (let d = 0; d < numDrops; d++) {
                const y = (d / numDrops) * this.canvas.height;
                const size = 2 + magnitude * 3;

                const color = this.getColor(i, numBars);
                this.ctx.shadowColor = color;
                this.ctx.fillStyle = color;
                this.ctx.globalAlpha = 0.4 + (d / numDrops) * 0.4;

                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 16: Snow Particles
     */
    renderSnowParticles(magnitudes) {
        const numFlakes = magnitudes.length * 2;
        const time = this.frameCounter * 0.005;

        this.ctx.shadowBlur = 10;

        for (let i = 0; i < numFlakes; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const x = (i / numFlakes) * this.canvas.width + Math.sin(time + i) * 30;
            const y = ((time * 50 + i * 50) % this.canvas.height);
            const size = 1 + magnitude * 4;

            const color = this.getColor(i, numFlakes);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = 0.5 + magnitude * 0.5;

            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 1008: Fog/Smoke
     */
    renderFogSmoke(magnitudes) {
        const params = this.settings.modeParameters || {};
        const density = params.density || 0.7;
        const speed = params.speed || 0.5;
        const dissipation = params.dissipation || 0.3;
        const particleSize = params.particleSize || 50;
        const drift = params.drift || 1;
        const turbulence = params.turbulence || 0.5;

        const numParticles = Math.floor(magnitudes.length * density * 3);
        const time = this.frameCounter * 0.01 * speed;

        this.ctx.shadowBlur = 30;

        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];

            // Create wispy, drifting motion
            const xOffset = Math.sin(time * 0.5 + i * 0.1) * 100 * drift;
            const yOffset = Math.cos(time * 0.3 + i * 0.15) * 80 * drift;
            const turbulenceX = Math.sin(time * 2 + i) * 40 * turbulence;
            const turbulenceY = Math.cos(time * 1.5 + i) * 40 * turbulence;

            const x = ((i / numParticles) * this.canvas.width + xOffset + turbulenceX) % this.canvas.width;
            const y = ((time * 30 + i * 20 + yOffset + turbulenceY) % this.canvas.height);

            // Particles expand and dissipate based on audio
            const baseSize = particleSize * this.scaleFactor;
            const size = baseSize + magnitude * baseSize * 0.8;

            // Calculate alpha with dissipation effect
            const lifeProgress = (y / this.canvas.height);
            const alpha = (0.15 + magnitude * 0.25) * (1 - lifeProgress * dissipation);

            const color = this.getColor(i, numParticles);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = Math.max(0, alpha);

            // Draw soft, wispy circles with gradient
            const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, size);
            gradient.addColorStop(0, color);
            gradient.addColorStop(0.5, color.replace('rgb', 'rgba').replace(')', ', 0.5)'));
            gradient.addColorStop(1, color.replace('rgb', 'rgba').replace(')', ', 0)'));
            this.ctx.fillStyle = gradient;

            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 1009: Clouds
     */
    renderClouds(magnitudes) {
        const params = this.settings.modeParameters || {};
        const cloudCount = Math.floor(params.cloudCount || 12);
        const cloudSize = params.cloudSize || 1;
        const puffiness = params.puffiness || 0.7;
        const speed = params.speed || 0.3;
        const verticalDrift = params.verticalDrift || 0.2;
        const density = params.density || 0.8;

        const time = this.frameCounter * 0.01 * speed;

        this.ctx.shadowBlur = 20;

        for (let i = 0; i < cloudCount; i++) {
            const magnitude = magnitudes[i % magnitudes.length];

            // Cloud movement - horizontal with slight vertical drift
            const cloudSpeed = 50 + (i % 3) * 30;
            const x = ((time * cloudSpeed + i * 200) % (this.canvas.width + 400)) - 200;
            const yBase = (i / cloudCount) * this.canvas.height;
            const yDrift = Math.sin(time * 0.5 + i) * 30 * verticalDrift;
            const y = yBase + yDrift;

            // Cloud size affected by audio
            const baseSize = 80 * cloudSize * this.scaleFactor;
            const reactiveSize = baseSize + magnitude * baseSize * 0.4;

            // Number of puffs per cloud
            const numPuffs = Math.floor(3 + puffiness * 5);

            const color = this.getColor(i, cloudCount);

            // Draw cloud as multiple overlapping circles (puffs)
            for (let p = 0; p < numPuffs; p++) {
                const puffAngle = (p / numPuffs) * Math.PI * 2;
                const puffDistance = reactiveSize * 0.4 * (0.5 + Math.random() * 0.5);
                const puffX = x + Math.cos(puffAngle) * puffDistance;
                const puffY = y + Math.sin(puffAngle) * puffDistance * 0.6; // Flatten vertically
                const puffSize = reactiveSize * (0.6 + Math.random() * 0.4);

                // Soft, fluffy appearance
                const alpha = (0.3 + magnitude * 0.4) * density;

                // Create soft gradient for each puff
                const gradient = this.ctx.createRadialGradient(puffX, puffY, 0, puffX, puffY, puffSize);
                gradient.addColorStop(0, color);
                gradient.addColorStop(0.4, color.replace('rgb', 'rgba').replace(')', ', 0.6)'));
                gradient.addColorStop(1, color.replace('rgb', 'rgba').replace(')', ', 0)'));

                this.ctx.fillStyle = gradient;
                this.ctx.globalAlpha = alpha;
                this.ctx.shadowColor = color;

                this.ctx.beginPath();
                this.ctx.arc(puffX, puffY, puffSize, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 1010: Aurora Borealis
     */
    renderAuroraBorealis(magnitudes) {
        const params = this.settings.modeParameters || {};
        const waveCount = Math.floor(params.waveCount || 4);
        const waveHeight = params.waveHeight || 1;
        const flowSpeed = params.flowSpeed || 0.3;
        const shimmer = params.shimmer || 0.7;
        const colorShift = params.colorShift || 0.5;
        const opacity = params.opacity || 0.7;

        const time = this.frameCounter * 0.01 * flowSpeed;

        this.ctx.shadowBlur = 40;

        // Draw flowing aurora waves
        for (let w = 0; w < waveCount; w++) {
            const waveOffset = (w / waveCount) * Math.PI * 2;
            const baseY = (w / waveCount) * this.canvas.height * 0.6 + this.canvas.height * 0.2;

            // Color shifts for each wave
            const colorIndex = Math.floor((w / waveCount) * magnitudes.length * colorShift);
            const magnitude = magnitudes[colorIndex % magnitudes.length];
            const color = this.getColor(colorIndex, magnitudes.length);

            // Create gradient for aurora effect
            const gradient = this.ctx.createLinearGradient(0, baseY - 100, 0, baseY + 100);
            gradient.addColorStop(0, color.replace('rgb', 'rgba').replace(')', ', 0)'));
            gradient.addColorStop(0.5, color.replace('rgb', 'rgba').replace(')', `, ${opacity * (0.6 + magnitude * 0.4)})`));
            gradient.addColorStop(1, color.replace('rgb', 'rgba').replace(')', ', 0)'));

            this.ctx.fillStyle = gradient;
            this.ctx.shadowColor = color;

            // Draw wavy, flowing path
            this.ctx.beginPath();
            const numPoints = 100;

            for (let i = 0; i <= numPoints; i++) {
                const x = (i / numPoints) * this.canvas.width;
                const magnitudeIndex = Math.floor((i / numPoints) * magnitudes.length);
                const localMagnitude = magnitudes[magnitudeIndex];

                // Multiple sine waves for organic flow
                const wave1 = Math.sin(time * 2 + i * 0.1 + waveOffset) * 50 * waveHeight;
                const wave2 = Math.sin(time * 1.5 - i * 0.05 + waveOffset * 1.3) * 30 * waveHeight;
                const wave3 = Math.sin(time * 3 + i * 0.15 + waveOffset * 0.7) * 20 * shimmer;

                // Audio reactive wave height
                const audioWave = localMagnitude * 80 * waveHeight;

                const y = baseY + wave1 + wave2 + wave3 + audioWave;

                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }

            // Complete the path for filled area
            this.ctx.lineTo(this.canvas.width, this.canvas.height);
            this.ctx.lineTo(0, this.canvas.height);
            this.ctx.closePath();
            this.ctx.fill();

            // Add shimmer particles
            const particleCount = Math.floor(20 * shimmer);
            for (let p = 0; p < particleCount; p++) {
                const x = (p / particleCount) * this.canvas.width;
                const magnitudeIndex = Math.floor((p / particleCount) * magnitudes.length);
                const particleMag = magnitudes[magnitudeIndex];

                const wave1 = Math.sin(time * 2 + p * 0.1 + waveOffset) * 50 * waveHeight;
                const wave2 = Math.sin(time * 1.5 - p * 0.05 + waveOffset * 1.3) * 30 * waveHeight;
                const y = baseY + wave1 + wave2;

                const shimmerAlpha = Math.sin(time * 5 + p) * 0.5 + 0.5;
                const particleSize = (3 + particleMag * 5) * this.scaleFactor;

                this.ctx.globalAlpha = shimmerAlpha * 0.8;
                const particleGradient = this.ctx.createRadialGradient(x, y, 0, x, y, particleSize);
                particleGradient.addColorStop(0, color);
                particleGradient.addColorStop(1, color.replace('rgb', 'rgba').replace(')', ', 0)'));
                this.ctx.fillStyle = particleGradient;

                this.ctx.beginPath();
                this.ctx.arc(x, y, particleSize, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 1011: Fireflies
     */
    renderFireflies(magnitudes) {
        const params = this.settings.modeParameters || {};
        const fireflyCount = Math.floor(params.fireflyCount || 40);
        const glowSize = params.glowSize || 8;
        const blinkSpeed = params.blinkSpeed || 1.5;
        const floatSpeed = params.floatSpeed || 0.5;
        const glowIntensity = params.glowIntensity || 1;
        const brightness = params.brightness || 1;

        // Initialize firefly positions if not exists
        if (!this.fireflyData || this.fireflyData.length !== fireflyCount) {
            this.fireflyData = [];
            for (let i = 0; i < fireflyCount; i++) {
                this.fireflyData.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    blinkOffset: Math.random() * Math.PI * 2
                });
            }
        }

        const time = this.frameCounter * 0.01;

        this.ctx.shadowBlur = 20 * glowIntensity;

        for (let i = 0; i < fireflyCount; i++) {
            const firefly = this.fireflyData[i];
            const magnitude = magnitudes[i % magnitudes.length];

            // Update position with gentle floating motion
            const floatX = Math.sin(time * floatSpeed + i * 0.5) * 1.5;
            const floatY = Math.cos(time * floatSpeed * 0.7 + i * 0.3) * 1.5;

            firefly.x += firefly.vx * floatSpeed + floatX;
            firefly.y += firefly.vy * floatSpeed + floatY;

            // Wrap around screen edges
            if (firefly.x < 0) firefly.x = this.canvas.width;
            if (firefly.x > this.canvas.width) firefly.x = 0;
            if (firefly.y < 0) firefly.y = this.canvas.height;
            if (firefly.y > this.canvas.height) firefly.y = 0;

            // Blinking effect with audio reactivity
            const blinkPhase = Math.sin(time * blinkSpeed + firefly.blinkOffset) * 0.5 + 0.5;
            const audioBoost = magnitude * 0.5;
            const alpha = Math.max(0.1, (blinkPhase + audioBoost) * brightness);

            // Size varies with blink and audio
            const baseSize = glowSize * this.scaleFactor;
            const size = baseSize * (0.5 + blinkPhase * 0.5 + magnitude * 0.3);

            const color = this.getColor(i, fireflyCount);

            // Create glowing effect
            const gradient = this.ctx.createRadialGradient(
                firefly.x, firefly.y, 0,
                firefly.x, firefly.y, size * 2
            );

            // Bright center fading to transparent
            gradient.addColorStop(0, color.replace('rgb', 'rgba').replace(')', `, ${alpha})`));
            gradient.addColorStop(0.3, color.replace('rgb', 'rgba').replace(')', `, ${alpha * 0.6})`));
            gradient.addColorStop(0.6, color.replace('rgb', 'rgba').replace(')', `, ${alpha * 0.3})`));
            gradient.addColorStop(1, color.replace('rgb', 'rgba').replace(')', ', 0)'));

            this.ctx.fillStyle = gradient;
            this.ctx.shadowColor = color;
            this.ctx.globalAlpha = glowIntensity;

            // Draw firefly glow
            this.ctx.beginPath();
            this.ctx.arc(firefly.x, firefly.y, size * 2, 0, Math.PI * 2);
            this.ctx.fill();

            // Draw bright core
            this.ctx.globalAlpha = alpha * glowIntensity;
            this.ctx.fillStyle = color;
            this.ctx.beginPath();
            this.ctx.arc(firefly.x, firefly.y, size * 0.3, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 1012: Voltage Surge
     */
    renderVoltageSurge(magnitudes) {
        const params = this.settings.modeParameters || {};
        const boltCount = Math.floor(params.boltCount || 15);
        const boltHeight = params.boltHeight || 0.8;
        const surgeSpeed = params.surgeSpeed || 1.5;
        const crackleIntensity = params.crackleIntensity || 1;
        const thickness = params.thickness || 3;
        const glow = params.glow || 25;

        const time = this.frameCounter * 0.02 * surgeSpeed;

        this.ctx.shadowBlur = glow;
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';

        for (let i = 0; i < boltCount; i++) {
            const magnitude = magnitudes[i % magnitudes.length];

            // Skip low magnitude bolts for performance
            if (magnitude < 0.2) continue;

            const x = ((i + 0.5) / boltCount) * this.canvas.width;
            const startY = this.canvas.height;
            const maxHeight = this.canvas.height * boltHeight;

            // Audio-reactive surge height with animation
            const surgePhase = Math.sin(time + i * 0.5) * 0.5 + 0.5;
            const targetHeight = maxHeight * (0.3 + magnitude * 0.7 + surgePhase * 0.3);

            const color = this.getColor(i, boltCount);
            this.ctx.strokeStyle = color;
            this.ctx.shadowColor = color;
            this.ctx.lineWidth = (thickness + magnitude * 3) * this.scaleFactor;

            // Draw main vertical bolt with zigzag
            this.ctx.beginPath();
            this.ctx.moveTo(x, startY);

            let currentY = startY;
            let currentX = x;
            const segments = Math.floor(10 + magnitude * 15);

            for (let s = 0; s < segments; s++) {
                const segmentHeight = targetHeight / segments;
                currentY -= segmentHeight;

                // Zigzag effect
                const zigzag = (Math.random() - 0.5) * 20 * crackleIntensity * this.scaleFactor;
                currentX += zigzag;

                // Keep within reasonable bounds
                currentX = Math.max(x - 50 * this.scaleFactor, Math.min(x + 50 * this.scaleFactor, currentX));

                this.ctx.lineTo(currentX, currentY);

                // Add electrical branches
                if (Math.random() > 0.7 && crackleIntensity > 0) {
                    const branchLength = 20 + magnitude * 30;
                    const branchAngle = (Math.random() - 0.5) * Math.PI * 0.5;
                    const branchEndX = currentX + Math.cos(branchAngle) * branchLength * this.scaleFactor;
                    const branchEndY = currentY + Math.sin(branchAngle) * branchLength * this.scaleFactor;

                    this.ctx.moveTo(currentX, currentY);
                    this.ctx.lineTo(branchEndX, branchEndY);
                    this.ctx.moveTo(currentX, currentY);
                }
            }

            this.ctx.stroke();

            // Add bright core at the top
            if (magnitude > 0.5) {
                const coreSize = (5 + magnitude * 15) * this.scaleFactor;
                const gradient = this.ctx.createRadialGradient(currentX, currentY, 0, currentX, currentY, coreSize);
                gradient.addColorStop(0, color);
                gradient.addColorStop(0.5, color.replace('rgb', 'rgba').replace(')', ', 0.5)'));
                gradient.addColorStop(1, color.replace('rgb', 'rgba').replace(')', ', 0)'));

                this.ctx.fillStyle = gradient;
                this.ctx.globalAlpha = magnitude;
                this.ctx.beginPath();
                this.ctx.arc(currentX, currentY, coreSize, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.globalAlpha = 1;
            }
        }

        this.ctx.shadowBlur = 0;
        this.ctx.lineCap = 'butt';
        this.ctx.lineJoin = 'miter';
    }

    /**
     * Mode 1013: Particle Accelerator
     */
    renderParticleAccelerator(magnitudes) {
        const params = this.settings.modeParameters || {};
        const particleCount = Math.floor(params.particleCount || 80);
        const orbitRadius = params.orbitRadius || 0.4;
        const speed = params.speed || 2;
        const trailLength = params.trailLength || 0.5;
        const particleSize = params.particleSize || 4;
        const rings = Math.floor(params.rings || 2);

        // Initialize particle data if needed
        if (!this.acceleratorParticles || this.acceleratorParticles.length !== particleCount) {
            this.acceleratorParticles = [];
            for (let i = 0; i < particleCount; i++) {
                this.acceleratorParticles.push({
                    angle: (i / particleCount) * Math.PI * 2,
                    ring: i % rings,
                    speed: 0.8 + Math.random() * 0.4
                });
            }
        }

        const time = this.frameCounter * 0.01 * speed;

        // Draw orbital rings
        this.ctx.strokeStyle = 'rgba(100, 100, 100, 0.2)';
        this.ctx.lineWidth = 1;

        for (let r = 0; r < rings; r++) {
            const ringRadius = this.getEffectiveInnerRadius() * orbitRadius * (0.5 + (r / rings) * 0.5);
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, ringRadius, 0, Math.PI * 2);
            this.ctx.stroke();
        }

        // Apply trail effect with fade
        if (trailLength > 0) {
            this.ctx.fillStyle = `rgba(0, 0, 0, ${0.3 * trailLength})`;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }

        this.ctx.shadowBlur = 15;

        // Draw particles
        for (let i = 0; i < particleCount; i++) {
            const particle = this.acceleratorParticles[i];
            const magnitude = magnitudes[i % magnitudes.length];

            // Update particle angle
            particle.angle += 0.02 * particle.speed * speed;

            // Ring-specific radius with audio reactivity
            const ringFactor = 0.5 + (particle.ring / rings) * 0.5;
            const baseRadius = this.getEffectiveInnerRadius() * orbitRadius * ringFactor;
            const radius = baseRadius + magnitude * baseRadius * 0.3;

            // Calculate position
            const x = this.centerX + Math.cos(particle.angle) * radius;
            const y = this.centerY + Math.sin(particle.angle) * radius;

            // Size varies with magnitude
            const size = (particleSize + magnitude * particleSize * 0.5) * this.scaleFactor;

            const color = this.getColor(i, particleCount);
            this.ctx.shadowColor = color;

            // Draw particle with glow
            const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, size * 2);
            gradient.addColorStop(0, color);
            gradient.addColorStop(0.5, color.replace('rgb', 'rgba').replace(')', ', 0.6)'));
            gradient.addColorStop(1, color.replace('rgb', 'rgba').replace(')', ', 0)'));

            this.ctx.fillStyle = gradient;
            this.ctx.globalAlpha = 0.8 + magnitude * 0.2;

            this.ctx.beginPath();
            this.ctx.arc(x, y, size * 2, 0, Math.PI * 2);
            this.ctx.fill();

            // Draw bright core
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = 1;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size * 0.5, 0, Math.PI * 2);
            this.ctx.fill();

            // Add energy streaks on high magnitude
            if (magnitude > 0.6) {
                this.ctx.globalAlpha = magnitude * 0.5;
                const streakLength = 10 * magnitude * this.scaleFactor;
                const streakAngle = particle.angle + Math.PI / 2;

                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 1 * this.scaleFactor;
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                this.ctx.lineTo(
                    x + Math.cos(streakAngle) * streakLength,
                    y + Math.sin(streakAngle) * streakLength
                );
                this.ctx.stroke();
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 1014: Quantum Entanglement
     */
    renderQuantumEntanglement(magnitudes) {
        const params = this.settings.modeParameters || {};
        const pairCount = Math.floor(params.pairCount || 12);
        const separation = params.separation || 0.5;
        const oscillation = params.oscillation || 1.5;
        const connectionGlow = params.connectionGlow || 20;
        const particleSize = params.particleSize || 8;
        const waveEffect = params.waveEffect || 1;

        // Initialize particle pairs if needed
        if (!this.entanglementPairs || this.entanglementPairs.length !== pairCount) {
            this.entanglementPairs = [];
            for (let i = 0; i < pairCount; i++) {
                const baseAngle = (i / pairCount) * Math.PI * 2;
                this.entanglementPairs.push({
                    angle: baseAngle,
                    phaseOffset: Math.random() * Math.PI * 2,
                    orbitSpeed: 0.3 + Math.random() * 0.4
                });
            }
        }

        const time = this.frameCounter * 0.01 * oscillation;

        this.ctx.shadowBlur = connectionGlow;

        // Draw entangled particle pairs
        for (let i = 0; i < pairCount; i++) {
            const pair = this.entanglementPairs[i];
            const magnitude = magnitudes[i % magnitudes.length];

            // Update particle orbit
            pair.angle += 0.005 * pair.orbitSpeed;

            // Calculate base positions (particles orbit around center)
            const orbitRadius = this.getEffectiveInnerRadius() * separation;
            const centerX = this.centerX + Math.cos(pair.angle) * orbitRadius * 0.3;
            const centerY = this.centerY + Math.sin(pair.angle) * orbitRadius * 0.3;

            // Calculate particle pair positions (separated, oscillating)
            const oscillationOffset = Math.sin(time + pair.phaseOffset) * orbitRadius * 0.5;
            const separationAngle = pair.angle + Math.PI / 2;

            const particle1X = centerX + Math.cos(separationAngle) * oscillationOffset;
            const particle1Y = centerY + Math.sin(separationAngle) * oscillationOffset;

            const particle2X = centerX - Math.cos(separationAngle) * oscillationOffset;
            const particle2Y = centerY - Math.sin(separationAngle) * oscillationOffset;

            const color = this.getColor(i, pairCount);

            // Draw connection line with wave effect
            this.ctx.strokeStyle = color;
            this.ctx.shadowColor = color;
            this.ctx.lineWidth = (2 + magnitude * 3) * this.scaleFactor;

            if (waveEffect > 0.1) {
                // Draw wavy connection using bezier curve
                this.ctx.beginPath();
                this.ctx.moveTo(particle1X, particle1Y);

                const waveAmplitude = 30 * waveEffect * magnitude * this.scaleFactor;
                const wavePhase = Math.sin(time * 2 + i) * waveAmplitude;
                const midX = (particle1X + particle2X) / 2 + Math.cos(separationAngle + Math.PI / 2) * wavePhase;
                const midY = (particle1Y + particle2Y) / 2 + Math.sin(separationAngle + Math.PI / 2) * wavePhase;

                this.ctx.quadraticCurveTo(midX, midY, particle2X, particle2Y);
                this.ctx.globalAlpha = 0.6 + magnitude * 0.4;
                this.ctx.stroke();
            } else {
                // Straight connection
                this.ctx.beginPath();
                this.ctx.moveTo(particle1X, particle1Y);
                this.ctx.lineTo(particle2X, particle2Y);
                this.ctx.globalAlpha = 0.6 + magnitude * 0.4;
                this.ctx.stroke();
            }

            // Draw particles
            const size = (particleSize + magnitude * particleSize * 0.5) * this.scaleFactor;

            // Particle 1
            this.ctx.globalAlpha = 0.9 + magnitude * 0.1;
            const gradient1 = this.ctx.createRadialGradient(particle1X, particle1Y, 0, particle1X, particle1Y, size * 2);
            gradient1.addColorStop(0, color);
            gradient1.addColorStop(0.5, color.replace('rgb', 'rgba').replace(')', ', 0.6)'));
            gradient1.addColorStop(1, color.replace('rgb', 'rgba').replace(')', ', 0)'));

            this.ctx.fillStyle = gradient1;
            this.ctx.beginPath();
            this.ctx.arc(particle1X, particle1Y, size * 2, 0, Math.PI * 2);
            this.ctx.fill();

            // Bright core
            this.ctx.globalAlpha = 1;
            this.ctx.fillStyle = color;
            this.ctx.beginPath();
            this.ctx.arc(particle1X, particle1Y, size * 0.4, 0, Math.PI * 2);
            this.ctx.fill();

            // Particle 2 (entangled twin)
            this.ctx.globalAlpha = 0.9 + magnitude * 0.1;
            const gradient2 = this.ctx.createRadialGradient(particle2X, particle2Y, 0, particle2X, particle2Y, size * 2);
            gradient2.addColorStop(0, color);
            gradient2.addColorStop(0.5, color.replace('rgb', 'rgba').replace(')', ', 0.6)'));
            gradient2.addColorStop(1, color.replace('rgb', 'rgba').replace(')', ', 0)'));

            this.ctx.fillStyle = gradient2;
            this.ctx.beginPath();
            this.ctx.arc(particle2X, particle2Y, size * 2, 0, Math.PI * 2);
            this.ctx.fill();

            // Bright core
            this.ctx.globalAlpha = 1;
            this.ctx.fillStyle = color;
            this.ctx.beginPath();
            this.ctx.arc(particle2X, particle2Y, size * 0.4, 0, Math.PI * 2);
            this.ctx.fill();

            // Add energy pulses traveling along connection on high magnitude
            if (magnitude > 0.5) {
                const pulseProgress = (time * 2 + i) % 1;
                const pulseX = particle1X + (particle2X - particle1X) * pulseProgress;
                const pulseY = particle1Y + (particle2Y - particle1Y) * pulseProgress;
                const pulseSize = size * magnitude;

                this.ctx.globalAlpha = (1 - Math.abs(pulseProgress - 0.5) * 2) * magnitude;
                this.ctx.fillStyle = color;
                this.ctx.shadowBlur = connectionGlow * 1.5;
                this.ctx.beginPath();
                this.ctx.arc(pulseX, pulseY, pulseSize, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 1015: Crystal Lattice
     */
    renderCrystalLattice(magnitudes) {
        const params = this.settings.modeParameters || {};
        const gridSize = Math.floor(params.gridSize || 6);
        const latticeSpacing = params.latticeSpacing || 1;
        const pulseIntensity = params.pulseIntensity || 1;
        const bondThickness = params.bondThickness || 2;
        const atomSize = params.atomSize || 6;
        const rotation = params.rotation || 0.5;

        const time = this.frameCounter * 0.01 * rotation;

        // Calculate lattice dimensions
        const spacing = (Math.min(this.canvas.width, this.canvas.height) / (gridSize + 2)) * latticeSpacing;
        const offsetX = (this.canvas.width - (gridSize - 1) * spacing) / 2;
        const offsetY = (this.canvas.height - (gridSize - 1) * spacing) / 2;

        // Rotation for 3D effect
        const rotationAngle = time * 0.3;

        this.ctx.shadowBlur = 15;

        // Draw bonds first (so they appear behind atoms)
        this.ctx.lineWidth = bondThickness * this.scaleFactor;

        for (let x = 0; x < gridSize; x++) {
            for (let y = 0; y < gridSize; y++) {
                const index = x * gridSize + y;
                const magnitude = magnitudes[index % magnitudes.length];

                // Apply 3D rotation to position
                const baseX = x * spacing;
                const baseY = y * spacing;
                const rotX = baseX * Math.cos(rotationAngle) - baseY * Math.sin(rotationAngle);
                const rotY = baseX * Math.sin(rotationAngle) + baseY * Math.cos(rotationAngle);

                const posX = offsetX + rotX;
                const posY = offsetY + rotY;

                const color = this.getColor(index, gridSize * gridSize);
                this.ctx.strokeStyle = color;
                this.ctx.shadowColor = color;

                // Draw bonds to neighboring atoms
                // Right neighbor
                if (x < gridSize - 1) {
                    const nextX = (x + 1) * spacing;
                    const nextRotX = nextX * Math.cos(rotationAngle) - baseY * Math.sin(rotationAngle);
                    const nextRotY = nextX * Math.sin(rotationAngle) + baseY * Math.cos(rotationAngle);
                    const nextPosX = offsetX + nextRotX;
                    const nextPosY = offsetY + nextRotY;

                    this.ctx.globalAlpha = 0.4 + magnitude * 0.3;
                    this.ctx.beginPath();
                    this.ctx.moveTo(posX, posY);
                    this.ctx.lineTo(nextPosX, nextPosY);
                    this.ctx.stroke();
                }

                // Bottom neighbor
                if (y < gridSize - 1) {
                    const nextY = (y + 1) * spacing;
                    const nextRotX = baseX * Math.cos(rotationAngle) - nextY * Math.sin(rotationAngle);
                    const nextRotY = baseX * Math.sin(rotationAngle) + nextY * Math.cos(rotationAngle);
                    const nextPosX = offsetX + nextRotX;
                    const nextPosY = offsetY + nextRotY;

                    this.ctx.globalAlpha = 0.4 + magnitude * 0.3;
                    this.ctx.beginPath();
                    this.ctx.moveTo(posX, posY);
                    this.ctx.lineTo(nextPosX, nextPosY);
                    this.ctx.stroke();
                }

                // Diagonal bonds for more complex structure
                if (x < gridSize - 1 && y < gridSize - 1) {
                    const diagX = (x + 1) * spacing;
                    const diagY = (y + 1) * spacing;
                    const diagRotX = diagX * Math.cos(rotationAngle) - diagY * Math.sin(rotationAngle);
                    const diagRotY = diagX * Math.sin(rotationAngle) + diagY * Math.cos(rotationAngle);
                    const diagPosX = offsetX + diagRotX;
                    const diagPosY = offsetY + diagRotY;

                    this.ctx.globalAlpha = 0.2 + magnitude * 0.2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(posX, posY);
                    this.ctx.lineTo(diagPosX, diagPosY);
                    this.ctx.stroke();
                }
            }
        }

        // Draw atoms (nodes)
        for (let x = 0; x < gridSize; x++) {
            for (let y = 0; y < gridSize; y++) {
                const index = x * gridSize + y;
                const magnitude = magnitudes[index % magnitudes.length];

                // Apply 3D rotation
                const baseX = x * spacing;
                const baseY = y * spacing;
                const rotX = baseX * Math.cos(rotationAngle) - baseY * Math.sin(rotationAngle);
                const rotY = baseX * Math.sin(rotationAngle) + baseY * Math.cos(rotationAngle);

                const posX = offsetX + rotX;
                const posY = offsetY + rotY;

                // Pulsing size based on audio
                const pulsePhase = Math.sin(time * 3 + x + y) * 0.5 + 0.5;
                const size = (atomSize + magnitude * atomSize * pulseIntensity + pulsePhase * 2) * this.scaleFactor;

                const color = this.getColor(index, gridSize * gridSize);
                this.ctx.shadowColor = color;

                // Draw atom glow
                const gradient = this.ctx.createRadialGradient(posX, posY, 0, posX, posY, size * 2);
                gradient.addColorStop(0, color);
                gradient.addColorStop(0.4, color.replace('rgb', 'rgba').replace(')', ', 0.8)'));
                gradient.addColorStop(1, color.replace('rgb', 'rgba').replace(')', ', 0)'));

                this.ctx.fillStyle = gradient;
                this.ctx.globalAlpha = 0.8 + magnitude * 0.2;
                this.ctx.beginPath();
                this.ctx.arc(posX, posY, size * 2, 0, Math.PI * 2);
                this.ctx.fill();

                // Draw bright atom core
                this.ctx.globalAlpha = 1;
                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.arc(posX, posY, size * 0.5, 0, Math.PI * 2);
                this.ctx.fill();

                // Add energy rings on high magnitude
                if (magnitude > 0.6 && pulseIntensity > 0.5) {
                    const ringSize = size * 3 * magnitude;
                    this.ctx.globalAlpha = (1 - magnitude) * 0.5;
                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = 2 * this.scaleFactor;
                    this.ctx.beginPath();
                    this.ctx.arc(posX, posY, ringSize, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Bioluminescence Wave - Mode 1019
     */
    renderBioluminescenceWave(magnitudes) {
        const params = this.settings.modeParameters || {};
        const waveCount = Math.floor(params.waveCount || 6);
        const organismDensity = params.organismDensity || 0.8;
        const glowIntensity = params.glowIntensity || 1.2;
        const waveSpeed = params.waveSpeed || 1;
        const particleSize = params.particleSize || 2.5;
        const trailLength = params.trailLength || 0.7;

        const time = this.frameCounter * 0.02 * waveSpeed;
        const centerY = this.canvas.height / 2;

        // Fade effect for trails
        this.ctx.fillStyle = `rgba(0, 0, 0, ${0.3 / trailLength})`;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.shadowBlur = 20 * glowIntensity;

        // Create wave particles
        const particlesPerWave = Math.floor(50 * organismDensity);

        for (let w = 0; w < waveCount; w++) {
            const waveOffset = (w / waveCount) * Math.PI * 2;
            const magnitude = magnitudes[Math.floor((w / waveCount) * magnitudes.length)];

            for (let p = 0; p < particlesPerWave; p++) {
                const x = (p / particlesPerWave) * this.canvas.width;
                const wavePhase = (x / this.canvas.width) * Math.PI * 4 + time + waveOffset;
                const amplitude = (50 + magnitude * 100) * (1 + w * 0.1);
                const y = centerY + Math.sin(wavePhase) * amplitude + (w - waveCount/2) * 30;

                // Pulsing effect
                const pulse = Math.sin(time * 2 + p * 0.1) * 0.5 + 0.5;
                const size = (particleSize + magnitude * particleSize) * this.scaleFactor;

                const color = this.getColor(w * particlesPerWave + p, waveCount * particlesPerWave);
                this.ctx.shadowColor = color;

                // Draw glowing particle
                const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, size * 4);
                gradient.addColorStop(0, color);
                gradient.addColorStop(0.3, color.replace('rgb', 'rgba').replace(')', `, ${0.6 * glowIntensity})`));
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

                this.ctx.fillStyle = gradient;
                this.ctx.globalAlpha = 0.7 + magnitude * 0.3 + pulse * 0.2;
                this.ctx.beginPath();
                this.ctx.arc(x, y, size * 4, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Electromagnetic Spectrum - Mode 1020
     */
    renderElectromagneticSpectrum(magnitudes) {
        const params = this.settings.modeParameters || {};
        const bandCount = Math.floor(params.bandCount || 9);
        const waveAmplitude = params.waveAmplitude || 1;
        const frequency = params.frequency || 1.5;
        const bandWidth = params.bandWidth || 0.7;
        const opacity = params.opacity || 0.75;
        const flowSpeed = params.flowSpeed || 1.2;

        const time = this.frameCounter * 0.03 * flowSpeed;
        const bandHeight = (this.canvas.height / bandCount) * bandWidth;
        const centerX = this.canvas.width / 2;

        // Clear with slight fade
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        for (let b = 0; b < bandCount; b++) {
            const y = (b / bandCount) * this.canvas.height + bandHeight / 2;
            const magnitude = magnitudes[Math.floor((b / bandCount) * magnitudes.length)];

            this.ctx.beginPath();

            // Create flowing wave path
            for (let x = 0; x <= this.canvas.width; x += 5) {
                const wavePhase = (x / this.canvas.width) * Math.PI * 6 * frequency + time + b * 0.5;
                const wave = Math.sin(wavePhase) * waveAmplitude * 30 * (1 + magnitude);
                const yPos = y + wave;

                if (x === 0) {
                    this.ctx.moveTo(x, yPos);
                } else {
                    this.ctx.lineTo(x, yPos);
                }
            }

            // Mirror the wave to create a band
            for (let x = this.canvas.width; x >= 0; x -= 5) {
                const wavePhase = (x / this.canvas.width) * Math.PI * 6 * frequency + time + b * 0.5;
                const wave = Math.sin(wavePhase) * waveAmplitude * 30 * (1 + magnitude);
                const yPos = y + wave - bandHeight;
                this.ctx.lineTo(x, yPos);
            }

            this.ctx.closePath();

            const color = this.getColor(b, bandCount);
            const gradient = this.ctx.createLinearGradient(0, y - bandHeight/2, 0, y + bandHeight/2);
            gradient.addColorStop(0, color.replace('rgb', 'rgba').replace(')', ', 0.1)'));
            gradient.addColorStop(0.5, color.replace('rgb', 'rgba').replace(')', `, ${opacity})`));
            gradient.addColorStop(1, color.replace('rgb', 'rgba').replace(')', ', 0.1)'));

            this.ctx.fillStyle = gradient;
            this.ctx.globalAlpha = opacity;
            this.ctx.fill();

            // Add edge glow
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 2 * this.scaleFactor;
            this.ctx.globalAlpha = opacity * 0.8;
            this.ctx.shadowBlur = 15;
            this.ctx.shadowColor = color;
            this.ctx.stroke();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Solar Corona - Mode 1021
     */
    renderSolarCorona(magnitudes) {
        const params = this.settings.modeParameters || {};
        const loopCount = Math.floor(params.loopCount || 10);
        const coreRadius = params.coreRadius || 120;
        const loopHeight = params.loopHeight || 1.5;
        const plasmaFlow = params.plasmaFlow || 1.2;
        const energyIntensity = params.energyIntensity || 1;
        const turbulence = params.turbulence || 0.6;

        const time = this.frameCounter * 0.02 * plasmaFlow;
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;

        // Fade background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw sun core
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const coreSize = (coreRadius + avgMagnitude * 40) * this.scaleFactor;

        const coreGradient = this.ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, coreSize);
        coreGradient.addColorStop(0, `rgba(255, 255, 200, ${energyIntensity})`);
        coreGradient.addColorStop(0.5, `rgba(255, 220, 100, ${0.8 * energyIntensity})`);
        coreGradient.addColorStop(1, 'rgba(255, 150, 0, 0)');

        this.ctx.fillStyle = coreGradient;
        this.ctx.globalAlpha = 1;
        this.ctx.beginPath();
        this.ctx.arc(centerX, centerY, coreSize, 0, Math.PI * 2);
        this.ctx.fill();

        this.ctx.shadowBlur = 30;

        // Draw plasma loops
        for (let i = 0; i < loopCount; i++) {
            const magnitude = magnitudes[Math.floor((i / loopCount) * magnitudes.length)];
            const angle = (i / loopCount) * Math.PI * 2 + time * 0.5;
            const loopLength = (100 + magnitude * 150) * loopHeight;

            const startX = centerX + Math.cos(angle) * coreRadius * this.scaleFactor;
            const startY = centerY + Math.sin(angle) * coreRadius * this.scaleFactor;

            const endAngle = angle + Math.PI * 0.3 + Math.sin(time + i) * turbulence;
            const endX = centerX + Math.cos(endAngle) * coreRadius * this.scaleFactor;
            const endY = centerY + Math.sin(endAngle) * coreRadius * this.scaleFactor;

            const controlDist = loopLength * this.scaleFactor;
            const controlAngle = (angle + endAngle) / 2 + Math.PI / 2;
            const controlX = (startX + endX) / 2 + Math.cos(controlAngle) * controlDist;
            const controlY = (startY + endY) / 2 + Math.sin(controlAngle) * controlDist;

            const color = this.getColor(i, loopCount);
            this.ctx.strokeStyle = color;
            this.ctx.shadowColor = color;
            this.ctx.lineWidth = (3 + magnitude * 4) * this.scaleFactor * energyIntensity;
            this.ctx.globalAlpha = 0.6 + magnitude * 0.4;

            // Draw the loop
            this.ctx.beginPath();
            this.ctx.moveTo(startX, startY);
            this.ctx.quadraticCurveTo(controlX, controlY, endX, endY);
            this.ctx.stroke();

            // Add flowing particles along the loop
            const particlePos = (time * 2 + i * 0.3) % 1;
            const t = particlePos;
            const px = (1-t)*(1-t)*startX + 2*(1-t)*t*controlX + t*t*endX;
            const py = (1-t)*(1-t)*startY + 2*(1-t)*t*controlY + t*t*endY;

            this.ctx.globalAlpha = 0.9;
            const particleGradient = this.ctx.createRadialGradient(px, py, 0, px, py, 10 * this.scaleFactor);
            particleGradient.addColorStop(0, color);
            particleGradient.addColorStop(1, color.replace('rgb', 'rgba').replace(')', ', 0)'));
            this.ctx.fillStyle = particleGradient;
            this.ctx.beginPath();
            this.ctx.arc(px, py, 10 * this.scaleFactor, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Cytoplasm Flow - Mode 1022
     */
    renderCytoplasmFlow(magnitudes) {
        const params = this.settings.modeParameters || {};
        const organelleCount = Math.floor(params.organelleCount || 18);
        const flowVelocity = params.flowVelocity || 1;
        const organelleSize = params.organelleSize || 8;
        const membraneThickness = params.membraneThickness || 2;
        const streamCount = Math.floor(params.streamCount || 4);
        const cellRadius = params.cellRadius || 240;

        const time = this.frameCounter * 0.02 * flowVelocity;
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        const scaledRadius = cellRadius * this.scaleFactor;

        // Clear background
        this.ctx.fillStyle = 'rgba(5, 5, 15, 0.2)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw cell membrane
        this.ctx.strokeStyle = 'rgba(100, 150, 200, 0.3)';
        this.ctx.lineWidth = membraneThickness * this.scaleFactor;
        this.ctx.globalAlpha = 0.5;
        this.ctx.shadowBlur = 10;
        this.ctx.shadowColor = 'rgba(100, 150, 200, 0.5)';
        this.ctx.beginPath();

        // Create organic membrane shape
        for (let a = 0; a <= Math.PI * 2; a += 0.1) {
            const wobble = Math.sin(a * 5 + time) * 10 + Math.sin(a * 3 - time * 0.5) * 8;
            const r = scaledRadius + wobble;
            const x = centerX + Math.cos(a) * r;
            const y = centerY + Math.sin(a) * r;
            if (a === 0) {
                this.ctx.moveTo(x, y);
            } else {
                this.ctx.lineTo(x, y);
            }
        }
        this.ctx.closePath();
        this.ctx.stroke();

        // Draw cytoplasm flow streams
        this.ctx.shadowBlur = 15;
        for (let s = 0; s < streamCount; s++) {
            const streamAngle = (s / streamCount) * Math.PI * 2 + time * 0.3;
            const magnitude = magnitudes[Math.floor((s / streamCount) * magnitudes.length)];

            const streamRadius = scaledRadius * 0.7;
            const color = this.getColor(s, streamCount);
            this.ctx.strokeStyle = color.replace('rgb', 'rgba').replace(')', ', 0.2)');
            this.ctx.lineWidth = 2 * this.scaleFactor;

            // Create circular flow path
            this.ctx.beginPath();
            for (let a = 0; a <= Math.PI * 2; a += 0.1) {
                const flow = Math.sin(a * 3 + time * 2) * 20 * magnitude;
                const r = streamRadius + flow;
                const offsetAngle = a + streamAngle;
                const x = centerX + Math.cos(offsetAngle) * r;
                const y = centerY + Math.sin(offsetAngle) * r;
                if (a === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }
            this.ctx.globalAlpha = 0.4;
            this.ctx.stroke();
        }

        // Draw organelles
        for (let i = 0; i < organelleCount; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / organelleCount) * Math.PI * 2 + time;
            const orbitRadius = (scaledRadius * 0.6) * (0.5 + (i % 3) * 0.25);

            const x = centerX + Math.cos(angle) * orbitRadius;
            const y = centerY + Math.sin(angle) * orbitRadius;

            const size = (organelleSize + magnitude * organelleSize * 0.5) * this.scaleFactor;
            const color = this.getColor(i, organelleCount);

            // Draw organelle with membrane
            this.ctx.shadowColor = color;
            this.ctx.shadowBlur = 10;

            // Outer membrane
            const membraneGradient = this.ctx.createRadialGradient(x, y, size * 0.5, x, y, size);
            membraneGradient.addColorStop(0, color);
            membraneGradient.addColorStop(0.7, color.replace('rgb', 'rgba').replace(')', ', 0.6)'));
            membraneGradient.addColorStop(1, color.replace('rgb', 'rgba').replace(')', ', 0.2)'));

            this.ctx.fillStyle = membraneGradient;
            this.ctx.globalAlpha = 0.8;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();

            // Inner core
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = 0.9 + magnitude * 0.1;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size * 0.4, 0, Math.PI * 2);
            this.ctx.fill();

            // Organelle details (varies by type)
            if (i % 3 === 0) {
                // Mitochondria-like cristae
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 1 * this.scaleFactor;
                this.ctx.globalAlpha = 0.6;
                for (let c = 0; c < 3; c++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x - size * 0.3, y - size * 0.2 + c * size * 0.2);
                    this.ctx.lineTo(x + size * 0.3, y - size * 0.2 + c * size * 0.2);
                    this.ctx.stroke();
                }
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 18: Pixel Clouds
     */
    renderPixelClouds(magnitudes) {
        const pixelSize = 12;
        const numClouds = magnitudes.length / 2;
        const time = this.frameCounter * 0.02;

        for (let i = 0; i < numClouds; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const x = ((i * 137.5 + time * 20) % this.canvas.width);
            const y = (i * 17) % this.canvas.height;
            const size = Math.floor(2 + magnitude * 5);

            const color = this.getColor(i, numClouds);
            this.ctx.fillStyle = color;

            // Draw pixelated cloud
            for (let px = 0; px < size; px++) {
                for (let py = 0; py < size; py++) {
                    if (Math.random() > 0.3) {
                        this.ctx.fillRect(x + px * pixelSize, y + py * pixelSize, pixelSize, pixelSize);
                    }
                }
            }
        }
    }

    /**
     * Mode 19: Neon Cityscape
     */
    renderNeonCityscape(magnitudes) {
        const numBuildings = magnitudes.length;
        const buildingWidth = this.canvas.width / numBuildings;
        const baseY = this.canvas.height * 0.9;

        this.ctx.shadowBlur = 25;

        for (let i = 0; i < numBuildings; i++) {
            const magnitude = magnitudes[i];
            const height = 50 + magnitude * this.canvas.height * 0.7;
            const x = i * buildingWidth;
            const y = baseY - height;

            const color = this.getColor(i, numBuildings);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 2;

            // Building outline
            this.ctx.strokeRect(x + 2, y, buildingWidth - 4, height);

            // Windows
            const windowRows = Math.floor(height / 20);
            for (let w = 0; w < windowRows; w++) {
                if (magnitude > 0.3) {
                    this.ctx.fillStyle = color;
                    this.ctx.globalAlpha = 0.6;
                    this.ctx.fillRect(x + buildingWidth / 4, y + w * 20 + 5, buildingWidth / 4, 10);
                }
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 20: Lava Lamp
     */
    renderLavaLamp(magnitudes) {
        const numBlobs = Math.min(magnitudes.length / 4, 12);
        const time = this.frameCounter * 0.01;

        this.ctx.shadowBlur = 30;

        for (let i = 0; i < numBlobs; i++) {
            const magnitude = magnitudes[i * 4] || magnitudes[i];
            const x = this.centerX + Math.sin(time + i * 2) * this.maxRadius * 0.5;
            const y = this.centerY + Math.cos(time * 0.7 + i * 1.5) * this.maxRadius * 0.6;
            const radius = 30 + magnitude * 80;

            const color = this.getColor(i * 8, numBlobs * 8);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = 0.6;

            this.ctx.beginPath();
            this.ctx.arc(x, y, radius, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 21: Ink Drops
     */
    renderInkDrops(magnitudes) {
        const numDrops = Math.min(magnitudes.length / 3, 20);
        const time = this.frameCounter * 0.02;

        this.ctx.shadowBlur = 25;

        for (let i = 0; i < numDrops; i++) {
            const magnitude = magnitudes[i * 3] || magnitudes[i];
            const age = (time + i) % 10;
            const expansion = age / 10;

            const x = this.centerX + (Math.random() - 0.5) * 100;
            const y = this.centerY + (Math.random() - 0.5) * 100;
            const radius = expansion * magnitude * 100;

            const color = this.getColor(i * 4, numDrops * 4);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = Math.max(0, 0.8 - expansion);

            this.ctx.beginPath();
            this.ctx.arc(x, y, radius, 0, Math.PI * 2);
            this.ctx.fill();

            // Tendrils
            for (let t = 0; t < 5; t++) {
                const angle = (t / 5) * Math.PI * 2 + i;
                const length = expansion * magnitude * 120;
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                this.ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 22: Water Ripples
     */
    renderWaterRipples(magnitudes) {
        const numRipples = 8;
        const time = this.frameCounter * 0.05;

        this.ctx.shadowBlur = 15;

        for (let r = 0; r < numRipples; r++) {
            const phase = (time + r * 0.5) % 5;
            const radius = this.getEffectiveInnerRadius() * 0.5 + phase * 60;

            const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
            const thickness = 1 + avgMagnitude * 3;

            const color = this.getColor(r * 10, numRipples * 10);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = thickness;
            this.ctx.globalAlpha = Math.max(0, 1 - phase / 5);

            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 999: Organic Blob
     * Smooth flowing blob with audio-reactive waves inspired by TikTok visualizers
     */
    renderOrganicBlob(magnitudes) {
        const params = this.settings.modeParameters || {};
        const blobRadius = params.blobRadius || 200;
        const wavePoints = params.wavePoints || 64;
        const waveAmplitude = params.waveAmplitude || 40;
        const smoothness = params.smoothness || 0.7;
        const showBars = params.showBars || 0;

        const effectiveRadius = blobRadius * this.scaleFactor;
        const angleStep = (Math.PI * 2) / wavePoints;
        const time = this.frameCounter * 0.02;

        // Create smooth blob outline with audio-reactive deformations
        this.ctx.beginPath();

        // Generate blob points with smooth waves
        const points = [];
        for (let i = 0; i < wavePoints; i++) {
            const angle = i * angleStep;

            // Sample multiple frequencies for smoother, more organic movement
            const magnitudeIndex = Math.floor((i / wavePoints) * magnitudes.length);
            const magnitude = magnitudes[magnitudeIndex] || 0;

            // Add wave motion with time-based animation
            const waveOffset = Math.sin(angle * 4 + time) * 0.15 +
                             Math.sin(angle * 7 - time * 1.5) * 0.1;

            // Calculate radius with audio reactivity and organic waves
            const radius = effectiveRadius +
                          (magnitude * waveAmplitude * this.scaleFactor) +
                          (waveOffset * effectiveRadius * 0.2);

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            points.push({ x, y, magnitude });
        }

        // Draw smooth blob using cardinal spline interpolation
        this.ctx.beginPath();
        this.ctx.moveTo(points[0].x, points[0].y);

        for (let i = 0; i < points.length; i++) {
            const p0 = points[(i - 1 + points.length) % points.length];
            const p1 = points[i];
            const p2 = points[(i + 1) % points.length];
            const p3 = points[(i + 2) % points.length];

            // Cardinal spline control points for smooth curves
            const tension = 1 - smoothness;
            const cp1x = p1.x + (p2.x - p0.x) / 6 * tension;
            const cp1y = p1.y + (p2.y - p0.y) / 6 * tension;
            const cp2x = p2.x - (p3.x - p1.x) / 6 * tension;
            const cp2y = p2.y - (p3.y - p1.y) / 6 * tension;

            this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
        }

        this.ctx.closePath();

        // Style the blob with gradient and glow
        const color = this.getColor(0, 1);
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = 3 * this.scaleFactor;
        this.ctx.shadowBlur = 20 * this.scaleFactor;
        this.ctx.shadowColor = color;
        this.ctx.stroke();

        // Optional: Draw radial bars extending from blob (like circular spectrum)
        if (showBars > 0.5) {
            this.ctx.shadowBlur = 10 * this.scaleFactor;

            for (let i = 0; i < wavePoints; i++) {
                const angle = i * angleStep;
                const magnitude = magnitudes[Math.floor((i / wavePoints) * magnitudes.length)] || 0;

                if (magnitude > 0.1) {
                    const innerR = effectiveRadius * 1.1;
                    const outerR = innerR + (magnitude * waveAmplitude * this.scaleFactor * 2);

                    const x1 = this.centerX + Math.cos(angle) * innerR;
                    const y1 = this.centerY + Math.sin(angle) * innerR;
                    const x2 = this.centerX + Math.cos(angle) * outerR;
                    const y2 = this.centerY + Math.sin(angle) * outerR;

                    const barColor = this.getColor(i, wavePoints);
                    this.ctx.strokeStyle = barColor;
                    this.ctx.shadowColor = barColor;
                    this.ctx.lineWidth = 2 * this.scaleFactor;
                    this.ctx.lineCap = 'round';

                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, y1);
                    this.ctx.lineTo(x2, y2);
                    this.ctx.stroke();
                }
            }
        }

        this.ctx.shadowBlur = 0;
        this.ctx.globalAlpha = 1;
    }

    /**
     * Mode 998: Neon Contour
     * Multi-layered rainbow outline with chromatic offset effect inspired by TikTok/Instagram
     */
    renderNeonContour(magnitudes) {
        const params = this.settings.modeParameters || {};
        const contourSize = params.contourSize || 250;
        const numLayers = Math.floor(params.numLayers || 4);
        const layerOffset = params.layerOffset || 12;
        const waveIntensity = params.waveIntensity || 35;
        const complexity = Math.floor(params.complexity || 48);

        const baseRadius = contourSize * this.scaleFactor;
        const time = this.frameCounter * 0.015;
        const angleStep = (Math.PI * 2) / complexity;

        // Rainbow colors for chromatic aberration effect
        const layerColors = [
            'rgba(255, 220, 0, 0.9)',    // Yellow
            'rgba(100, 255, 100, 0.85)',  // Green
            'rgba(0, 255, 200, 0.8)',     // Cyan
            'rgba(100, 150, 255, 0.75)',  // Blue
            'rgba(200, 100, 255, 0.7)',   // Purple
            'rgba(255, 100, 200, 0.65)',  // Pink
            'rgba(255, 150, 100, 0.6)',   // Orange
            'rgba(255, 255, 150, 0.55)'   // Light Yellow
        ];

        // Generate base contour shape points
        const generateContourPoints = (radiusMultiplier, phaseShift = 0) => {
            const points = [];

            for (let i = 0; i < complexity; i++) {
                const angle = i * angleStep;

                // Sample audio magnitude
                const magnitudeIndex = Math.floor((i / complexity) * magnitudes.length);
                const magnitude = magnitudes[magnitudeIndex] || 0;

                // Create organic shape with multiple frequency waves
                const baseShape = Math.sin(angle * 3 + time + phaseShift) * 0.2 +
                                Math.sin(angle * 5 - time * 1.3 + phaseShift) * 0.15 +
                                Math.cos(angle * 2 + time * 0.7 + phaseShift) * 0.1;

                // Calculate radius with audio reactivity and organic deformation
                const radius = baseRadius * radiusMultiplier +
                              (baseShape * baseRadius * 0.3) +
                              (magnitude * waveIntensity * this.scaleFactor);

                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;

                points.push({ x, y });
            }

            return points;
        };

        // Draw each layer with offset (chromatic aberration effect)
        for (let layer = numLayers - 1; layer >= 0; layer--) {
            const offset = layer * layerOffset * this.scaleFactor;
            const radiusMultiplier = 1 + (offset / baseRadius);
            const phaseShift = layer * 0.3; // Slight phase shift for each layer

            const points = generateContourPoints(radiusMultiplier, phaseShift);

            // Draw smooth contour using cardinal spline
            this.ctx.beginPath();
            this.ctx.moveTo(points[0].x, points[0].y);

            for (let i = 0; i < points.length; i++) {
                const p0 = points[(i - 1 + points.length) % points.length];
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length];
                const p3 = points[(i + 2) % points.length];

                // Cardinal spline control points for smooth curves
                const tension = 0.5;
                const cp1x = p1.x + (p2.x - p0.x) / 6 * tension;
                const cp1y = p1.y + (p2.y - p0.y) / 6 * tension;
                const cp2x = p2.x - (p3.x - p1.x) / 6 * tension;
                const cp2y = p2.y - (p3.y - p1.y) / 6 * tension;

                this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
            }

            this.ctx.closePath();

            // Style each layer with rainbow colors and glow
            const color = layerColors[layer % layerColors.length];
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = (4 - layer * 0.3) * this.scaleFactor;
            this.ctx.shadowBlur = 15 * this.scaleFactor;
            this.ctx.shadowColor = color;
            this.ctx.lineCap = 'round';
            this.ctx.lineJoin = 'round';
            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
        this.ctx.globalAlpha = 1;
    }

    /**
     * Mode 997: Circular Spectrum Bars
     * Radial spectrum bars with blue-to-purple gradient emanating from a circular frame
     */
    renderCircularSpectrumBars(magnitudes) {
        const params = this.settings.modeParameters || {};
        const circleSize = params.circleSize || 150;
        const barCount = Math.floor(params.barCount || 48);
        const barWidth = params.barWidth || 8;
        const barHeight = params.barHeight || 120;
        const spreadAngle = params.spreadAngle || 180;

        const circleRadius = circleSize * this.scaleFactor;
        const maxBarHeight = barHeight * this.scaleFactor;
        const barWidthScaled = barWidth * this.scaleFactor;

        // Calculate starting angle (bottom of circle) and spread
        const startAngle = Math.PI / 2 - (spreadAngle * Math.PI / 180) / 2;
        const endAngle = Math.PI / 2 + (spreadAngle * Math.PI / 180) / 2;
        const angleStep = (endAngle - startAngle) / (barCount - 1);

        // Draw the circular frame first
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, circleRadius, 0, Math.PI * 2);
        this.ctx.strokeStyle = 'rgba(230, 220, 200, 0.8)';
        this.ctx.lineWidth = 12 * this.scaleFactor;
        this.ctx.stroke();

        // Inner circle for depth
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, circleRadius * 0.92, 0, Math.PI * 2);
        this.ctx.strokeStyle = 'rgba(200, 190, 170, 0.4)';
        this.ctx.lineWidth = 6 * this.scaleFactor;
        this.ctx.stroke();

        // Draw spectrum bars in radial pattern
        for (let i = 0; i < barCount; i++) {
            const angle = startAngle + i * angleStep;

            // Sample magnitude
            const magnitudeIndex = Math.floor((i / barCount) * magnitudes.length);
            const magnitude = magnitudes[magnitudeIndex] || 0;

            // Calculate bar height based on magnitude
            const currentBarHeight = magnitude * maxBarHeight;

            // Calculate gradient color (blue to purple/magenta)
            const colorProgress = i / (barCount - 1);
            const r = Math.floor(100 + colorProgress * 155); // 100 -> 255
            const g = Math.floor(100 - colorProgress * 100); // 100 -> 0
            const b = Math.floor(255 - colorProgress * 55);  // 255 -> 200
            const alpha = 0.85 + colorProgress * 0.15;

            // Starting point on circle edge
            const startX = this.centerX + Math.cos(angle) * circleRadius;
            const startY = this.centerY + Math.sin(angle) * circleRadius;

            // End point extends outward
            const endX = this.centerX + Math.cos(angle) * (circleRadius + currentBarHeight);
            const endY = this.centerY + Math.sin(angle) * (circleRadius + currentBarHeight);

            // Draw 3D bar with gradient
            const gradient = this.ctx.createLinearGradient(startX, startY, endX, endY);
            gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${alpha})`);
            gradient.addColorStop(1, `rgba(${r + 20}, ${g}, ${b + 20}, ${alpha - 0.2})`);

            this.ctx.beginPath();
            this.ctx.moveTo(startX, startY);
            this.ctx.lineTo(endX, endY);
            this.ctx.strokeStyle = gradient;
            this.ctx.lineWidth = barWidthScaled;
            this.ctx.lineCap = 'round';
            this.ctx.shadowBlur = 8 * this.scaleFactor;
            this.ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.6)`;
            this.ctx.stroke();

            // Add highlight for 3D effect
            if (currentBarHeight > maxBarHeight * 0.1) {
                const highlightGradient = this.ctx.createLinearGradient(startX, startY, endX, endY);
                highlightGradient.addColorStop(0, `rgba(255, 255, 255, 0.3)`);
                highlightGradient.addColorStop(1, `rgba(255, 255, 255, 0)`);

                this.ctx.beginPath();
                this.ctx.moveTo(startX, startY);
                this.ctx.lineTo(endX, endY);
                this.ctx.strokeStyle = highlightGradient;
                this.ctx.lineWidth = barWidthScaled * 0.4;
                this.ctx.shadowBlur = 0;
                this.ctx.stroke();
            }
        }

        this.ctx.shadowBlur = 0;
        this.ctx.globalAlpha = 1;
    }

    /**
     * Mode 996: Vinyl Record
     * Spinning vinyl disc with two horizontal audio spectrum lines
     */
    renderVinylRecord(magnitudes) {
        const params = this.settings.modeParameters || {};
        const discSize = params.discSize || 200;
        const grooveCount = Math.floor(params.grooveCount || 6);
        const rotationSpeed = params.rotationSpeed || 0.8;
        const lineWidth = params.lineWidth || 800;
        const sparkleCount = Math.floor(params.sparkleCount || 8);

        const discRadius = discSize * this.scaleFactor;
        const time = this.frameCounter * 0.01 * rotationSpeed;

        // Draw vinyl disc
        this.ctx.save();
        this.ctx.translate(this.centerX, this.centerY);
        this.ctx.rotate(time);

        // Main disc body - realistic black vinyl with subtle shine
        const vinylGradient = this.ctx.createRadialGradient(
            -discRadius * 0.3, -discRadius * 0.3, 0,
            0, 0, discRadius
        );
        vinylGradient.addColorStop(0, 'rgba(40, 40, 40, 0.98)');  // Slight highlight
        vinylGradient.addColorStop(0.3, 'rgba(20, 20, 20, 0.98)');
        vinylGradient.addColorStop(1, 'rgba(10, 10, 10, 0.98)');   // Deep black edges

        this.ctx.beginPath();
        this.ctx.arc(0, 0, discRadius, 0, Math.PI * 2);
        this.ctx.fillStyle = vinylGradient;
        this.ctx.fill();
        this.ctx.strokeStyle = 'rgba(30, 30, 30, 0.8)';
        this.ctx.lineWidth = 2 * this.scaleFactor;
        this.ctx.stroke();

        // Center label (darker circle) - realistic label area
        const labelRadius = discRadius * 0.35;
        const labelGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, labelRadius);
        labelGradient.addColorStop(0, 'rgba(45, 45, 45, 0.9)');
        labelGradient.addColorStop(0.7, 'rgba(30, 30, 30, 0.9)');
        labelGradient.addColorStop(1, 'rgba(20, 20, 20, 0.9)');

        this.ctx.beginPath();
        this.ctx.arc(0, 0, labelRadius, 0, Math.PI * 2);
        this.ctx.fillStyle = labelGradient;
        this.ctx.fill();

        // Center hole - realistic spindle hole
        const holeGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, discRadius * 0.08);
        holeGradient.addColorStop(0, 'rgba(5, 5, 5, 1)');
        holeGradient.addColorStop(1, 'rgba(15, 15, 15, 1)');

        this.ctx.beginPath();
        this.ctx.arc(0, 0, discRadius * 0.08, 0, Math.PI * 2);
        this.ctx.fillStyle = holeGradient;
        this.ctx.fill();
        this.ctx.strokeStyle = 'rgba(25, 25, 25, 0.9)';
        this.ctx.lineWidth = 1 * this.scaleFactor;
        this.ctx.stroke();

        // Grooves (concentric circles) - subtle black grooves like real vinyl
        for (let i = 0; i < grooveCount; i++) {
            const grooveRadius = labelRadius + (discRadius - labelRadius) * ((i + 1) / (grooveCount + 1));
            this.ctx.beginPath();
            this.ctx.arc(0, 0, grooveRadius, 0, Math.PI * 2);
            this.ctx.strokeStyle = `rgba(15, 15, 15, ${0.4 - i * 0.04})`;
            this.ctx.lineWidth = 1.5 * this.scaleFactor;
            this.ctx.stroke();
        }

        this.ctx.restore();

        // Two horizontal lines with audio spectrum
        const lineHalfWidth = (lineWidth * this.scaleFactor) / 2;
        const barCount = 30;
        const barWidth = 3 * this.scaleFactor;
        const maxBarHeight = 40 * this.scaleFactor;
        const barSpacing = (lineHalfWidth - discRadius) / barCount;

        // Left line with spectrum
        const leftStartX = this.centerX - discRadius;
        for (let i = 0; i < barCount; i++) {
            const x = leftStartX - i * barSpacing;

            // Sample magnitude from left half
            const magnitudeIndex = Math.floor((i / barCount) * (magnitudes.length / 2));
            const magnitude = magnitudes[magnitudeIndex] || 0;

            const barHeight = magnitude * maxBarHeight;

            // Draw bar with dynamic color
            const barColor = this.getColor(i, barCount);
            this.ctx.beginPath();
            this.ctx.rect(x - barWidth / 2, this.centerY - barHeight / 2, barWidth, barHeight);
            this.ctx.fillStyle = barColor.replace('rgb', 'rgba').replace(')', ', 0.9)');
            this.ctx.fill();
        }

        // Right line with spectrum
        const rightStartX = this.centerX + discRadius;
        for (let i = 0; i < barCount; i++) {
            const x = rightStartX + i * barSpacing;

            // Sample magnitude from right half
            const magnitudeIndex = Math.floor(magnitudes.length / 2 + (i / barCount) * (magnitudes.length / 2));
            const magnitude = magnitudes[magnitudeIndex] || 0;

            const barHeight = magnitude * maxBarHeight;

            // Draw bar with dynamic color
            const barColor = this.getColor(barCount + i, barCount * 2);
            this.ctx.beginPath();
            this.ctx.rect(x - barWidth / 2, this.centerY - barHeight / 2, barWidth, barHeight);
            this.ctx.fillStyle = barColor.replace('rgb', 'rgba').replace(')', ', 0.9)');
            this.ctx.fill();
        }

        // Draw base lines with dynamic color
        const lineColor = this.getColor(0, 1);
        this.ctx.beginPath();
        this.ctx.moveTo(leftStartX, this.centerY);
        this.ctx.lineTo(this.centerX - lineHalfWidth, this.centerY);
        this.ctx.moveTo(rightStartX, this.centerY);
        this.ctx.lineTo(this.centerX + lineHalfWidth, this.centerY);
        this.ctx.strokeStyle = lineColor.replace('rgb', 'rgba').replace(')', ', 0.6)');
        this.ctx.lineWidth = 2 * this.scaleFactor;
        this.ctx.stroke();

        // Sparkles/stars scattered around
        for (let i = 0; i < sparkleCount; i++) {
            const angle = (i / sparkleCount) * Math.PI * 2 + time * 0.5;
            const distance = discRadius * (1.3 + Math.sin(time * 2 + i) * 0.2);
            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            // Twinkle effect
            const twinkle = Math.abs(Math.sin(time * 3 + i * 1.7));
            const sparkleSize = (3 + twinkle * 2) * this.scaleFactor;

            this.ctx.save();
            this.ctx.translate(x, y);
            this.ctx.rotate(time * 2 + i);

            // Draw star shape with dynamic color
            const sparkleColor = this.getColor(i, sparkleCount);
            this.ctx.beginPath();
            for (let j = 0; j < 4; j++) {
                const armAngle = (j / 4) * Math.PI * 2;
                const armX = Math.cos(armAngle) * sparkleSize;
                const armY = Math.sin(armAngle) * sparkleSize;
                if (j === 0) this.ctx.moveTo(armX, armY);
                else this.ctx.lineTo(armX, armY);
            }
            this.ctx.closePath();
            this.ctx.fillStyle = sparkleColor.replace('rgb', 'rgba').replace(')', `, ${0.6 + twinkle * 0.4})`);
            this.ctx.fill();

            this.ctx.restore();
        }

        this.ctx.globalAlpha = 1;
    }

    /**
     * Mode 995: Pulse Ring
     * Segmented circular ring with audio-reactive dashed border
     */
    renderPulseRing(magnitudes) {
        const params = this.settings.modeParameters || {};
        const ringSize = params.ringSize || 200;
        const ringThickness = params.ringThickness || 12;
        const segmentCount = Math.floor(params.segmentCount || 24);
        const gapSize = params.gapSize || 8;
        const sparkleCount = Math.floor(params.sparkleCount || 12);

        const ringRadius = ringSize * this.scaleFactor;
        const thickness = ringThickness * this.scaleFactor;
        const time = this.frameCounter * 0.02;

        // Calculate average magnitude for overall pulse
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const pulseScale = 1 + avgMagnitude * 0.15;

        // Draw segmented ring
        const segmentAngle = (Math.PI * 2) / segmentCount;
        const gapAngle = (gapSize * Math.PI) / 180;

        for (let i = 0; i < segmentCount; i++) {
            const startAngle = i * segmentAngle;
            const endAngle = (i + 1) * segmentAngle - gapAngle;

            // Sample magnitude for this segment
            const magnitudeIndex = Math.floor((i / segmentCount) * magnitudes.length);
            const magnitude = magnitudes[magnitudeIndex] || 0;

            // Segment-specific pulse
            const segmentPulse = 1 + magnitude * 0.2;
            const currentRadius = ringRadius * pulseScale * segmentPulse;

            // Gradient from pink to white
            const gradient = this.ctx.createRadialGradient(
                this.centerX, this.centerY, currentRadius - thickness,
                this.centerX, this.centerY, currentRadius
            );
            gradient.addColorStop(0, 'rgba(255, 200, 220, 0.9)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0.95)');

            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, currentRadius, startAngle, endAngle);
            this.ctx.lineWidth = thickness;
            this.ctx.strokeStyle = gradient;
            this.ctx.lineCap = 'round';
            this.ctx.shadowBlur = 10 * this.scaleFactor;
            this.ctx.shadowColor = 'rgba(255, 200, 220, 0.6)';
            this.ctx.stroke();
        }

        // Sparkles scattered around
        for (let i = 0; i < sparkleCount; i++) {
            const angle = (i / sparkleCount) * Math.PI * 2 + time;
            const distance = ringRadius * (0.6 + Math.random() * 0.8);
            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            // Twinkle effect
            const twinkle = Math.abs(Math.sin(time * 2 + i * 1.3));
            const sparkleSize = (2 + twinkle * 3) * this.scaleFactor;

            this.ctx.save();
            this.ctx.translate(x, y);
            this.ctx.rotate(time + i);

            // Draw star
            this.ctx.beginPath();
            for (let j = 0; j < 4; j++) {
                const armAngle = (j / 4) * Math.PI * 2;
                const armX = Math.cos(armAngle) * sparkleSize;
                const armY = Math.sin(armAngle) * sparkleSize;
                if (j === 0) this.ctx.moveTo(armX, armY);
                else this.ctx.lineTo(armX, armY);
            }
            this.ctx.closePath();
            this.ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + twinkle * 0.5})`;
            this.ctx.shadowBlur = 5 * this.scaleFactor;
            this.ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
            this.ctx.fill();

            this.ctx.restore();
        }

        this.ctx.shadowBlur = 0;
        this.ctx.globalAlpha = 1;
    }

    /**
     * Mode 994: Sunburst Arc
     * Semi-circular arc with radiating bars forming a sunburst pattern
     */
    renderSunburstArc(magnitudes) {
        const params = this.settings.modeParameters || {};
        const arcRadius = params.arcRadius || 180;
        const barCount = Math.floor(params.barCount || 40);
        const barWidth = params.barWidth || 6;
        const maxBarLength = params.maxBarLength || 100;
        const arcSpread = params.arcSpread || 160;

        const radius = arcRadius * this.scaleFactor;
        const barWidthScaled = barWidth * this.scaleFactor;
        const maxLength = maxBarLength * this.scaleFactor;

        // Arc angle range (top semicircle)
        const spreadRadians = (arcSpread * Math.PI) / 180;
        const startAngle = Math.PI / 2 - spreadRadians / 2;
        const endAngle = Math.PI / 2 + spreadRadians / 2;
        const angleStep = (endAngle - startAngle) / (barCount - 1);

        // Draw dotted inner circle
        const dotCount = 30;
        const dotRadius = 2 * this.scaleFactor;
        for (let i = 0; i < dotCount; i++) {
            const angle = startAngle + (i / (dotCount - 1)) * (endAngle - startAngle);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            this.ctx.beginPath();
            this.ctx.arc(x, y, dotRadius, 0, Math.PI * 2);
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            this.ctx.fill();
        }

        // Draw radiating bars
        for (let i = 0; i < barCount; i++) {
            const angle = startAngle + i * angleStep;

            // Sample magnitude
            const magnitudeIndex = Math.floor((i / barCount) * magnitudes.length);
            const magnitude = magnitudes[magnitudeIndex] || 0;

            // Bar length based on magnitude
            const barLength = maxLength * (0.3 + magnitude * 0.7);

            // Starting point on the circle
            const startX = this.centerX + Math.cos(angle) * radius;
            const startY = this.centerY + Math.sin(angle) * radius;

            // End point radiating outward
            const endX = this.centerX + Math.cos(angle) * (radius + barLength);
            const endY = this.centerY + Math.sin(angle) * (radius + barLength);

            // Draw bar
            this.ctx.beginPath();
            this.ctx.moveTo(startX, startY);
            this.ctx.lineTo(endX, endY);
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.95)';
            this.ctx.lineWidth = barWidthScaled;
            this.ctx.lineCap = 'round';
            this.ctx.shadowBlur = 8 * this.scaleFactor;
            this.ctx.shadowColor = 'rgba(255, 255, 255, 0.7)';
            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
        this.ctx.globalAlpha = 1;
    }

    /**
     * Mode 993: Gradient Waveform Circle
     * Circular ring with audio-reactive jagged edge and rainbow gradient
     */
    renderGradientWaveformCircle(magnitudes) {
        const params = this.settings.modeParameters || {};
        const circleRadius = params.circleRadius || 200;
        const waveAmplitude = params.waveAmplitude || 30;
        const lineThickness = params.lineThickness || 8;
        const resolution = Math.floor(params.resolution || 180);
        const sparkleCount = Math.floor(params.sparkleCount || 20);

        const radius = circleRadius * this.scaleFactor;
        const amplitude = waveAmplitude * this.scaleFactor;
        const thickness = lineThickness * this.scaleFactor;
        const time = this.frameCounter * 0.02;

        // Generate waveform points around the circle
        const points = [];
        const angleStep = (Math.PI * 2) / resolution;

        for (let i = 0; i < resolution; i++) {
            const angle = i * angleStep;

            // Sample magnitude
            const magnitudeIndex = Math.floor((i / resolution) * magnitudes.length);
            const magnitude = magnitudes[magnitudeIndex] || 0;

            // Add waveform oscillation
            const wave = magnitude * amplitude;
            const currentRadius = radius + wave;

            const x = this.centerX + Math.cos(angle) * currentRadius;
            const y = this.centerY + Math.sin(angle) * currentRadius;

            points.push({ x, y, angle });
        }

        // Draw the waveform circle with gradient
        this.ctx.beginPath();
        this.ctx.moveTo(points[0].x, points[0].y);

        for (let i = 1; i < points.length; i++) {
            this.ctx.lineTo(points[i].x, points[i].y);
        }
        this.ctx.closePath();

        // Create gradient colors (cyan -> blue -> purple -> magenta -> pink)
        this.ctx.lineWidth = thickness;
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';

        // Draw segments with gradient colors
        for (let i = 0; i < points.length; i++) {
            const nextI = (i + 1) % points.length;

            // Calculate gradient color based on position around circle
            const colorProgress = i / points.length;
            let r, g, b;

            if (colorProgress < 0.25) {
                // Cyan to Blue
                const t = colorProgress / 0.25;
                r = Math.floor(0 + t * 100);
                g = Math.floor(255 - t * 105);
                b = 255;
            } else if (colorProgress < 0.5) {
                // Blue to Purple
                const t = (colorProgress - 0.25) / 0.25;
                r = Math.floor(100 + t * 100);
                g = Math.floor(150 - t * 50);
                b = 255;
            } else if (colorProgress < 0.75) {
                // Purple to Magenta
                const t = (colorProgress - 0.5) / 0.25;
                r = Math.floor(200 + t * 55);
                g = Math.floor(100 - t * 100);
                b = Math.floor(255 - t * 55);
            } else {
                // Magenta to Hot Pink
                const t = (colorProgress - 0.75) / 0.25;
                r = 255;
                g = Math.floor(0 + t * 20);
                b = Math.floor(200 - t * 100);
            }

            this.ctx.beginPath();
            this.ctx.moveTo(points[i].x, points[i].y);
            this.ctx.lineTo(points[nextI].x, points[nextI].y);
            this.ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.95)`;
            this.ctx.shadowBlur = 10 * this.scaleFactor;
            this.ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.6)`;
            this.ctx.stroke();
        }

        // Sparkles
        for (let i = 0; i < sparkleCount; i++) {
            const angle = (i / sparkleCount) * Math.PI * 2 + time;
            const distance = radius * (0.5 + Math.random() * 1);
            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const twinkle = Math.abs(Math.sin(time * 2 + i * 1.5));
            const sparkleSize = (2 + twinkle * 3) * this.scaleFactor;

            // Random color from the gradient
            const colorPos = (i / sparkleCount + time * 0.1) % 1;
            let sr, sg, sb;
            if (colorPos < 0.5) {
                sr = 100; sg = 200; sb = 255;
            } else {
                sr = 255; sg = 100; sb = 200;
            }

            this.ctx.save();
            this.ctx.translate(x, y);
            this.ctx.rotate(time + i);

            this.ctx.beginPath();
            for (let j = 0; j < 4; j++) {
                const armAngle = (j / 4) * Math.PI * 2;
                const armX = Math.cos(armAngle) * sparkleSize;
                const armY = Math.sin(armAngle) * sparkleSize;
                if (j === 0) this.ctx.moveTo(armX, armY);
                else this.ctx.lineTo(armX, armY);
            }
            this.ctx.closePath();
            this.ctx.fillStyle = `rgba(${sr}, ${sg}, ${sb}, ${0.4 + twinkle * 0.6})`;
            this.ctx.shadowBlur = 5 * this.scaleFactor;
            this.ctx.shadowColor = `rgba(${sr}, ${sg}, ${sb}, 0.8)`;
            this.ctx.fill();

            this.ctx.restore();
        }

        this.ctx.shadowBlur = 0;
        this.ctx.globalAlpha = 1;
    }

    /**
     * Mode 991: Plasma Vortex
     * Swirling plasma-like tendrils with spiraling rotation and energy flow
     */
    renderPlasmaVortex(magnitudes) {
        const params = this.settings.modeParameters || {};
        const vortexRadius = params.vortexRadius || 180;
        const tendrilCount = Math.floor(params.tendrilCount || 6);
        const spiralTightness = params.spiralTightness || 1.5;
        const flowSpeed = params.flowSpeed || 0.8;
        const energyIntensity = params.energyIntensity || 50;

        const baseRadius = vortexRadius * this.scaleFactor;
        const time = this.frameCounter * 0.01 * flowSpeed;
        const energy = energyIntensity * this.scaleFactor;

        // Calculate average magnitude for global pulsing
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Draw each plasma tendril
        for (let t = 0; t < tendrilCount; t++) {
            const tendrilAngleOffset = (t / tendrilCount) * Math.PI * 2;

            // Get magnitude for this tendril
            const magnitudeIndex = Math.floor((t / tendrilCount) * magnitudes.length);
            const magnitude = magnitudes[magnitudeIndex] || 0;

            // Create spiral path points
            const points = [];
            const segments = 80;

            for (let i = 0; i < segments; i++) {
                const progress = i / segments;

                // Spiral outward with audio reactivity
                const spiralAngle = tendrilAngleOffset + (progress * Math.PI * 4 * spiralTightness) + time;
                const radius = baseRadius * progress * (1 + magnitude * 0.5);

                // Add wave motion for organic feel
                const wave = Math.sin(progress * 8 - time * 2) * energy * 0.3;
                const wobble = Math.cos(progress * 5 + time * 3) * energy * 0.2;

                const x = this.centerX + Math.cos(spiralAngle) * (radius + wave) + wobble;
                const y = this.centerY + Math.sin(spiralAngle) * (radius + wave) + wobble;

                points.push({ x, y, progress });
            }

            // Draw tendril with gradient
            for (let i = 0; i < points.length - 1; i++) {
                const point = points[i];
                const nextPoint = points[i + 1];

                // Color based on position along tendril and audio
                const colorIndex = Math.floor((t + point.progress) * magnitudes.length / tendrilCount) % magnitudes.length;
                const color = this.getColor(colorIndex, magnitudes.length);

                // Thickness decreases along tendril, pulsing with audio
                const thickness = (8 - point.progress * 6) * this.scaleFactor * (1 + magnitude * 0.5);
                const alpha = 0.6 + magnitude * 0.4;

                // Parse RGB color
                const rgb = this.parseRgbColor(color);

                this.ctx.beginPath();
                this.ctx.moveTo(point.x, point.y);
                this.ctx.lineTo(nextPoint.x, nextPoint.y);
                this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${alpha})`;
                this.ctx.lineWidth = thickness;
                this.ctx.lineCap = 'round';
                this.ctx.shadowBlur = 15 * this.scaleFactor;
                this.ctx.shadowColor = color;
                this.ctx.stroke();
            }
        }

        // Add central energy core
        const coreRadius = 15 * this.scaleFactor * (1 + avgMagnitude);
        const gradient = this.ctx.createRadialGradient(
            this.centerX, this.centerY, 0,
            this.centerX, this.centerY, coreRadius
        );

        const coreColor = this.getColor(0, 1);
        const coreRgb = this.parseRgbColor(coreColor);
        gradient.addColorStop(0, `rgba(${coreRgb[0]}, ${coreRgb[1]}, ${coreRgb[2]}, 0.9)`);
        gradient.addColorStop(1, `rgba(${coreRgb[0]}, ${coreRgb[1]}, ${coreRgb[2]}, 0)`);

        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, coreRadius, 0, Math.PI * 2);
        this.ctx.fillStyle = gradient;
        this.ctx.fill();

        this.ctx.shadowBlur = 0;
        this.ctx.globalAlpha = 1;
    }

    /**
     * Mode 990: Bubble Stream
     * Rising bubbles with audio-reactive sizes and fluid physics simulation
     */
    renderBubbleStream(magnitudes) {
        const params = this.settings.modeParameters || {};
        const bubbleCount = Math.floor(params.bubbleCount || 15);
        const minBubbleSize = params.minBubbleSize || 20;
        const maxBubbleSize = params.maxBubbleSize || 80;
        const riseSpeed = params.riseSpeed || 1.5;
        const wobbleIntensity = params.wobbleIntensity || 0.8;

        // Initialize bubbles array if needed
        if (!this.bubbles || this.bubbles.length !== bubbleCount) {
            this.bubbles = [];
            for (let i = 0; i < bubbleCount; i++) {
                this.bubbles.push({
                    x: this.centerX + (Math.random() - 0.5) * this.maxRadius * 1.5,
                    y: this.centerY + this.maxRadius + Math.random() * 100,
                    baseSize: minBubbleSize + Math.random() * (maxBubbleSize - minBubbleSize),
                    phase: Math.random() * Math.PI * 2,
                    wobblePhase: Math.random() * Math.PI * 2,
                    frequencyIndex: Math.floor(Math.random() * magnitudes.length)
                });
            }
        }

        const time = this.frameCounter * 0.02;

        // Update and draw each bubble
        for (let i = 0; i < this.bubbles.length; i++) {
            const bubble = this.bubbles[i];
            const magnitude = magnitudes[bubble.frequencyIndex] || 0;

            // Update position
            bubble.y -= riseSpeed * this.scaleFactor * (0.5 + magnitude * 0.5);

            // Wobble horizontally
            const wobble = Math.sin(time * 2 + bubble.wobblePhase) * wobbleIntensity * this.scaleFactor * 30;
            const displayX = bubble.x + wobble;

            // Reset bubble if it goes off top
            if (bubble.y < this.centerY - this.maxRadius - 100) {
                bubble.y = this.centerY + this.maxRadius + 50;
                bubble.x = this.centerX + (Math.random() - 0.5) * this.maxRadius * 1.5;
                bubble.frequencyIndex = Math.floor(Math.random() * magnitudes.length);
            }

            // Bubble size reactive to audio
            const bubbleSize = (bubble.baseSize + magnitude * 30) * this.scaleFactor;

            // Draw bubble with gradient and highlights
            const gradient = this.ctx.createRadialGradient(
                displayX - bubbleSize * 0.3, bubble.y - bubbleSize * 0.3, bubbleSize * 0.1,
                displayX, bubble.y, bubbleSize
            );

            // Color based on frequency
            const color = this.getColor(bubble.frequencyIndex, magnitudes.length);
            const rgb = this.parseRgbColor(color);

            gradient.addColorStop(0, `rgba(255, 255, 255, 0.4)`);
            gradient.addColorStop(0.4, `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.3)`);
            gradient.addColorStop(1, `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.6)`);

            // Main bubble
            this.ctx.beginPath();
            this.ctx.arc(displayX, bubble.y, bubbleSize, 0, Math.PI * 2);
            this.ctx.fillStyle = gradient;
            this.ctx.fill();

            // Bubble outline
            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.7)`;
            this.ctx.lineWidth = 2 * this.scaleFactor;
            this.ctx.stroke();

            // Highlight
            const highlightSize = bubbleSize * 0.35;
            const highlightGradient = this.ctx.createRadialGradient(
                displayX - bubbleSize * 0.35, bubble.y - bubbleSize * 0.35, 0,
                displayX - bubbleSize * 0.35, bubble.y - bubbleSize * 0.35, highlightSize
            );
            highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

            this.ctx.beginPath();
            this.ctx.arc(displayX - bubbleSize * 0.35, bubble.y - bubbleSize * 0.35, highlightSize, 0, Math.PI * 2);
            this.ctx.fillStyle = highlightGradient;
            this.ctx.fill();

            // Secondary smaller highlight
            const smallHighlightSize = bubbleSize * 0.15;
            this.ctx.beginPath();
            this.ctx.arc(displayX + bubbleSize * 0.3, bubble.y + bubbleSize * 0.25, smallHighlightSize, 0, Math.PI * 2);
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    /**
     * Mode 992: Minimal Audio Ring
     * Clean white circular ring with subtle audio-reactive edge
     */
    renderMinimalAudioRing(magnitudes) {
        const circleRadius = this.settings.circleRadius || 220;
        const waveAmplitude = this.settings.waveAmplitude || 15;
        const lineThickness = this.settings.lineThickness || 5;
        const resolution = Math.floor(this.settings.resolution || 200);
        const glowIntensity = this.settings.glowIntensity || 8;

        const radius = circleRadius * this.scaleFactor;
        const amplitude = waveAmplitude * this.scaleFactor;
        const thickness = lineThickness * this.scaleFactor;
        const glow = glowIntensity * this.scaleFactor;

        // Generate waveform points around the circle
        const points = [];
        const angleStep = (Math.PI * 2) / resolution;

        for (let i = 0; i < resolution; i++) {
            const angle = i * angleStep;

            // Sample magnitude
            const magnitudeIndex = Math.floor((i / resolution) * magnitudes.length);
            const magnitude = magnitudes[magnitudeIndex] || 0;

            // Add subtle waveform oscillation
            const wave = magnitude * amplitude;
            const currentRadius = radius + wave;

            const x = this.centerX + Math.cos(angle) * currentRadius;
            const y = this.centerY + Math.sin(angle) * currentRadius;

            points.push({ x, y });
        }

        // Draw the waveform circle
        this.ctx.beginPath();
        this.ctx.moveTo(points[0].x, points[0].y);

        for (let i = 1; i < points.length; i++) {
            this.ctx.lineTo(points[i].x, points[i].y);
        }
        this.ctx.closePath();

        // White stroke with subtle glow
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.95)';
        this.ctx.lineWidth = thickness;
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        this.ctx.shadowBlur = glow;
        this.ctx.shadowColor = 'rgba(255, 255, 255, 0.7)';
        this.ctx.stroke();

        this.ctx.shadowBlur = 0;
        this.ctx.globalAlpha = 1;
    }

    /**
     * Mode 991: Triangle Spectrum
     * Glowing triangle frame with vertical waveform bars
     */
    renderTriangleSpectrum(magnitudes) {
        const params = this.settings.modeParameters || {};
        const triangleSize = params.triangleSize || 280;
        const barCount = Math.floor(params.barCount || 50);
        const barWidth = params.barWidth || 4;
        const maxBarHeight = params.maxBarHeight || 100;
        const glowIntensity = params.glowIntensity || 15;

        const size = triangleSize * this.scaleFactor;
        const barWidthScaled = barWidth * this.scaleFactor;
        const maxHeight = maxBarHeight * this.scaleFactor;
        const glow = glowIntensity * this.scaleFactor;

        // Triangle vertices (equilateral, pointing up)
        const height = (Math.sqrt(3) / 2) * size;
        const topX = this.centerX;
        const topY = this.centerY - height / 2;
        const bottomLeftX = this.centerX - size / 2;
        const bottomLeftY = this.centerY + height / 2;
        const bottomRightX = this.centerX + size / 2;
        const bottomRightY = this.centerY + height / 2;

        // Draw glowing triangle outline
        this.ctx.beginPath();
        this.ctx.moveTo(topX, topY);
        this.ctx.lineTo(bottomLeftX, bottomLeftY);
        this.ctx.lineTo(bottomRightX, bottomRightY);
        this.ctx.closePath();

        // Cyan/blue gradient for glow
        this.ctx.strokeStyle = 'rgba(100, 200, 255, 0.9)';
        this.ctx.lineWidth = 4 * this.scaleFactor;
        this.ctx.shadowBlur = glow;
        this.ctx.shadowColor = 'rgba(100, 200, 255, 0.8)';
        this.ctx.stroke();

        // Add extra glow layer
        this.ctx.strokeStyle = 'rgba(150, 220, 255, 0.6)';
        this.ctx.lineWidth = 8 * this.scaleFactor;
        this.ctx.shadowBlur = glow * 1.5;
        this.ctx.stroke();

        // Draw waveform bars at the bottom
        const barStartY = bottomLeftY + 10 * this.scaleFactor;
        const barAreaWidth = size * 0.8;
        const barSpacing = barAreaWidth / barCount;
        const barStartX = this.centerX - barAreaWidth / 2;

        for (let i = 0; i < barCount; i++) {
            const x = barStartX + i * barSpacing;

            // Sample magnitude
            const magnitudeIndex = Math.floor((i / barCount) * magnitudes.length);
            const magnitude = magnitudes[magnitudeIndex] || 0;

            // Bar height based on magnitude
            const barHeight = magnitude * maxHeight;

            // Draw bar
            this.ctx.beginPath();
            this.ctx.rect(x, barStartY, barWidthScaled, barHeight);
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            this.ctx.shadowBlur = 5 * this.scaleFactor;
            this.ctx.shadowColor = 'rgba(255, 255, 255, 0.6)';
            this.ctx.fill();
        }

        // Horizontal line beneath bars
        const lineY = barStartY + maxHeight + 5 * this.scaleFactor;
        this.ctx.beginPath();
        this.ctx.moveTo(barStartX, lineY);
        this.ctx.lineTo(barStartX + barAreaWidth, lineY);
        this.ctx.strokeStyle = 'rgba(100, 200, 255, 0.7)';
        this.ctx.lineWidth = 2 * this.scaleFactor;
        this.ctx.shadowBlur = glow * 0.5;
        this.ctx.shadowColor = 'rgba(100, 200, 255, 0.6)';
        this.ctx.stroke();

        this.ctx.shadowBlur = 0;
        this.ctx.globalAlpha = 1;
    }

    /**
     * Mode 990: Wavy Cloud Ring
     * Soft circular ring with organic wavy edges and pink gradient
     */
    renderWavyCloudRing(magnitudes) {
        const circleRadius = this.settings.circleRadius || 200;
        const waveFrequency = this.settings.waveFrequency || 10;
        const waveAmplitude = this.settings.waveAmplitude || 18;
        const lineThickness = this.settings.lineThickness || 15;
        const animationSpeed = this.settings.animationSpeed || 0.5;

        const radius = circleRadius * this.scaleFactor;
        const amplitude = waveAmplitude * this.scaleFactor;
        const thickness = lineThickness * this.scaleFactor;
        const time = this.frameCounter * 0.01 * animationSpeed;

        // Calculate average magnitude for overall pulse
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Generate wavy circle points
        const points = [];
        const resolution = 120;
        const angleStep = (Math.PI * 2) / resolution;

        for (let i = 0; i < resolution; i++) {
            const angle = i * angleStep;

            // Create organic wave pattern
            const wave1 = Math.sin(angle * waveFrequency + time) * amplitude * 0.5;
            const wave2 = Math.sin(angle * (waveFrequency * 0.7) - time * 1.3) * amplitude * 0.3;
            const wave3 = Math.cos(angle * (waveFrequency * 1.5) + time * 0.8) * amplitude * 0.2;

            // Add audio reactivity
            const magnitudeIndex = Math.floor((i / resolution) * magnitudes.length);
            const magnitude = magnitudes[magnitudeIndex] || 0;
            const audioWave = magnitude * amplitude * 0.4;

            const currentRadius = radius + wave1 + wave2 + wave3 + audioWave;

            const x = this.centerX + Math.cos(angle) * currentRadius;
            const y = this.centerY + Math.sin(angle) * currentRadius;

            points.push({ x, y });
        }

        // Draw smooth wavy circle
        this.ctx.beginPath();
        this.ctx.moveTo(points[0].x, points[0].y);

        // Use quadratic curves for smooth organic shape
        for (let i = 0; i < points.length; i++) {
            const current = points[i];
            const next = points[(i + 1) % points.length];
            const controlX = (current.x + next.x) / 2;
            const controlY = (current.y + next.y) / 2;

            this.ctx.quadraticCurveTo(current.x, current.y, controlX, controlY);
        }
        this.ctx.closePath();

        // Pink/coral gradient
        const gradient = this.ctx.createLinearGradient(
            this.centerX - radius,
            this.centerY,
            this.centerX + radius,
            this.centerY
        );
        gradient.addColorStop(0, 'rgba(255, 180, 180, 0.9)');
        gradient.addColorStop(0.5, 'rgba(255, 150, 150, 0.95)');
        gradient.addColorStop(1, 'rgba(255, 200, 200, 0.9)');

        this.ctx.strokeStyle = gradient;
        this.ctx.lineWidth = thickness;
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        this.ctx.shadowBlur = 12 * this.scaleFactor;
        this.ctx.shadowColor = 'rgba(255, 150, 150, 0.5)';
        this.ctx.stroke();

        // Add soft inner glow
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        this.ctx.lineWidth = thickness * 0.5;
        this.ctx.shadowBlur = 8 * this.scaleFactor;
        this.ctx.shadowColor = 'rgba(255, 200, 200, 0.4)';
        this.ctx.stroke();

        this.ctx.shadowBlur = 0;
        this.ctx.globalAlpha = 1;
    }

    /**
     * Mode 23: Crystal Growth
     */
    renderCrystalGrowth(magnitudes) {
        const numCrystals = magnitudes.length;
        const angleStep = (Math.PI * 2) / numCrystals;
        const innerRadius = this.getEffectiveInnerRadius();

        this.ctx.shadowBlur = 20;

        for (let i = 0; i < numCrystals; i++) {
            const angle = i * angleStep;
            const magnitude = magnitudes[i];
            const length = magnitude * this.maxRadius * 0.6;

            const x1 = this.centerX + Math.cos(angle) * innerRadius;
            const y1 = this.centerY + Math.sin(angle) * innerRadius;
            const x2 = this.centerX + Math.cos(angle) * (innerRadius + length);
            const y2 = this.centerY + Math.sin(angle) * (innerRadius + length);

            const color = this.getColor(i, numCrystals);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;

            // Main crystal spike
            this.ctx.lineWidth = 4;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();

            // Crystal branches
            if (magnitude > 0.4) {
                for (let b = 0; b < 3; b++) {
                    const branchAngle = angle + (Math.random() - 0.5) * 0.5;
                    const branchLength = length * (0.3 + Math.random() * 0.3);
                    const branchX = x1 + Math.cos(branchAngle) * branchLength;
                    const branchY = y1 + Math.sin(branchAngle) * branchLength;

                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, y1);
                    this.ctx.lineTo(branchX, branchY);
                    this.ctx.stroke();
                }
            }
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 24: Frequency Flowers
     */
    renderFrequencyFlowers(magnitudes) {
        const numPetals = magnitudes.length;
        const angleStep = (Math.PI * 2) / numPetals;
        const innerRadius = this.getEffectiveInnerRadius();

        this.ctx.shadowBlur = 20;

        for (let i = 0; i < numPetals; i++) {
            const angle = i * angleStep;
            const magnitude = magnitudes[i];
            const petalLength = magnitude * this.maxRadius * 0.5;

            const color = this.getColor(i, numPetals);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = 0.7;

            // Draw petal shape
            this.ctx.beginPath();
            const x1 = this.centerX + Math.cos(angle - 0.2) * innerRadius;
            const y1 = this.centerY + Math.sin(angle - 0.2) * innerRadius;
            const x2 = this.centerX + Math.cos(angle) * (innerRadius + petalLength);
            const y2 = this.centerY + Math.sin(angle) * (innerRadius + petalLength);
            const x3 = this.centerX + Math.cos(angle + 0.2) * innerRadius;
            const y3 = this.centerY + Math.sin(angle + 0.2) * innerRadius;

            this.ctx.moveTo(x1, y1);
            this.ctx.quadraticCurveTo(x2, y2, x3, y3);
            this.ctx.lineTo(this.centerX, this.centerY);
            this.ctx.closePath();
            this.ctx.fill();
        }

        // Draw center
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        this.ctx.fillStyle = this.getColor(0, numPetals);
        this.ctx.globalAlpha = 1;
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, innerRadius * 0.3 + avgMagnitude * 20, 0, Math.PI * 2);
        this.ctx.fill();

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 25: Fire Dance
     */
    renderFireDance(magnitudes) {
        const numFlames = magnitudes.length;
        const flameWidth = this.canvas.width / numFlames;
        const baseY = this.canvas.height * 0.8;

        this.ctx.shadowBlur = 30;

        for (let i = 0; i < numFlames; i++) {
            const magnitude = magnitudes[i];
            const x = i * flameWidth + flameWidth / 2;
            const height = magnitude * this.canvas.height * 0.6;

            const color = this.getColor(i, numFlames);
            this.ctx.shadowColor = color;

            // Draw flame shape
            this.ctx.beginPath();
            this.ctx.moveTo(x, baseY);

            for (let h = 0; h < height; h += 10) {
                const flicker = Math.sin(this.frameCounter * 0.1 + i + h * 0.1) * 5;
                const width = (1 - h / height) * flameWidth * 0.4;
                this.ctx.lineTo(x + flicker, baseY - h);
            }

            this.ctx.lineTo(x, baseY - height);
            this.ctx.lineTo(x, baseY);
            this.ctx.closePath();

            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = 0.7;
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 26: Ocean Bioluminescence
     */
    renderBioluminescence(magnitudes) {
        const numOrganisms = magnitudes.length * 2;
        const time = this.frameCounter * 0.01;

        this.ctx.shadowBlur = 25;

        for (let i = 0; i < numOrganisms; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const swimPattern = Math.sin(time + i * 0.5) * 100;
            const x = ((i / numOrganisms) * this.canvas.width + swimPattern) % this.canvas.width;
            const y = (i * 17 % this.canvas.height);
            const size = 3 + magnitude * 8;
            const pulse = Math.sin(time * 2 + i) * 0.3 + 0.7;

            const color = this.getColor(i, numOrganisms);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = pulse * magnitude;

            // Draw organism
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();

            // Trail
            for (let t = 1; t < 4; t++) {
                this.ctx.globalAlpha = (pulse * magnitude) / (t + 1);
                this.ctx.beginPath();
                this.ctx.arc(x - t * 8, y, size * (1 - t * 0.2), 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 27: Kaleidoscope
     */
    renderKaleidoscope(magnitudes) {
        const segments = 8;
        const numBars = magnitudes.length / segments;
        const angleStep = (Math.PI * 2) / segments;
        const innerRadius = this.getEffectiveInnerRadius();

        this.ctx.shadowBlur = 15;

        for (let seg = 0; seg < segments; seg++) {
            this.ctx.save();
            this.ctx.translate(this.centerX, this.centerY);
            this.ctx.rotate(seg * angleStep);

            for (let i = 0; i < numBars; i++) {
                const magnitude = magnitudes[Math.floor(i % magnitudes.length)];
                const barAngle = (i / numBars) * angleStep;
                const distance = innerRadius + magnitude * this.maxRadius * 0.5;

                const x = Math.cos(barAngle) * distance;
                const y = Math.sin(barAngle) * distance;
                const size = 3 + magnitude * 6;

                const color = this.getColor(i, numBars);
                this.ctx.shadowColor = color;
                this.ctx.fillStyle = color;

                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, Math.PI * 2);
                this.ctx.fill();
            }

            this.ctx.restore();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 28: Fractal Bloom
     */
    renderFractalBloom(magnitudes) {
        const depth = 4;
        const baseAngle = this.frameCounter * 0.01;

        this.ctx.shadowBlur = 15;

        const drawBranch = (x, y, angle, length, iteration, colorIndex) => {
            if (iteration >= depth) return;

            const magnitude = magnitudes[colorIndex % magnitudes.length];
            const endX = x + Math.cos(angle) * length;
            const endY = y + Math.sin(angle) * length;

            const color = this.getColor(colorIndex, magnitudes.length);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = (depth - iteration) * magnitude * 2;

            this.ctx.beginPath();
            this.ctx.moveTo(x, y);
            this.ctx.lineTo(endX, endY);
            this.ctx.stroke();

            const newLength = length * 0.7;
            drawBranch(endX, endY, angle - 0.5, newLength, iteration + 1, colorIndex + 1);
            drawBranch(endX, endY, angle + 0.5, newLength, iteration + 1, colorIndex + 2);
        };

        for (let i = 0; i < 6; i++) {
            const startAngle = baseAngle + (i / 6) * Math.PI * 2;
            drawBranch(this.centerX, this.centerY, startAngle, 80, 0, i * 10);
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 29: Morphing Geometry
     */
    renderMorphingGeometry(magnitudes) {
        const time = this.frameCounter * 0.02;
        const sides = 3 + Math.floor(Math.sin(time) * 3 + 4);
        const angleStep = (Math.PI * 2) / sides;
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const radius = this.getEffectiveInnerRadius() + avgMagnitude * this.maxRadius * 0.4;

        this.ctx.shadowBlur = 20;

        // Main shape
        this.ctx.beginPath();
        for (let i = 0; i <= sides; i++) {
            const angle = i * angleStep + time;
            const magnitude = magnitudes[i % magnitudes.length];
            const r = radius + magnitude * 50;
            const x = this.centerX + Math.cos(angle) * r;
            const y = this.centerY + Math.sin(angle) * r;

            if (i === 0) {
                this.ctx.moveTo(x, y);
            } else {
                this.ctx.lineTo(x, y);
            }
        }
        this.ctx.closePath();

        const color = this.getColor(Math.floor(time * 10), 100);
        this.ctx.shadowColor = color;
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = 3;
        this.ctx.stroke();

        // Inner wireframe
        this.ctx.globalAlpha = 0.5;
        this.ctx.beginPath();
        for (let i = 0; i < sides; i++) {
            const angle = i * angleStep + time;
            const x = this.centerX + Math.cos(angle) * radius * 0.5;
            const y = this.centerY + Math.sin(angle) * radius * 0.5;

            this.ctx.moveTo(this.centerX, this.centerY);
            this.ctx.lineTo(x, y);
        }
        this.ctx.stroke();

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 30: Spiral Galaxy
     */
    renderSpiralGalaxy(magnitudes) {
        const numArms = 3;
        const particlesPerArm = magnitudes.length / numArms;
        const time = this.frameCounter * 0.01;

        this.ctx.shadowBlur = 20;

        for (let arm = 0; arm < numArms; arm++) {
            const armAngle = (arm / numArms) * Math.PI * 2;

            for (let i = 0; i < particlesPerArm; i++) {
                const t = i / particlesPerArm;
                const magnitude = magnitudes[Math.floor(arm * particlesPerArm + i) % magnitudes.length];
                const spiralAngle = armAngle + t * Math.PI * 4 + time;
                const distance = this.getEffectiveInnerRadius() * 0.3 + t * this.maxRadius * 0.8;

                const x = this.centerX + Math.cos(spiralAngle) * distance;
                const y = this.centerY + Math.sin(spiralAngle) * distance;
                const size = 2 + magnitude * 5;

                const color = this.getColor(Math.floor(arm * particlesPerArm + i), magnitudes.length);
                this.ctx.shadowColor = color;
                this.ctx.fillStyle = color;
                this.ctx.globalAlpha = 0.6 + magnitude * 0.4;

                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 31: DNA Helix
     */
    renderDnaHelix(magnitudes) {
        const time = this.frameCounter * 0.05;
        const numPairs = magnitudes.length / 2;
        const spacing = this.canvas.height / numPairs;

        this.ctx.shadowBlur = 15;

        for (let i = 0; i < numPairs; i++) {
            const y = i * spacing + spacing / 2;
            const phase = i * 0.5 + time;
            const magnitude = magnitudes[i % magnitudes.length];

            const x1 = this.centerX + Math.sin(phase) * (100 + magnitude * 50);
            const x2 = this.centerX - Math.sin(phase) * (100 + magnitude * 50);

            const color = this.getColor(i, numPairs);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;

            // Base pair connection
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y);
            this.ctx.lineTo(x2, y);
            this.ctx.stroke();

            // Nucleotides
            this.ctx.fillStyle = color;
            this.ctx.beginPath();
            this.ctx.arc(x1, y, 4 + magnitude * 4, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.arc(x2, y, 4 + magnitude * 4, 0, Math.PI * 2);
            this.ctx.fill();

            // Helix strands
            if (i > 0) {
                const prevY = (i - 1) * spacing + spacing / 2;
                const prevPhase = (i - 1) * 0.5 + time;
                const prevX1 = this.centerX + Math.sin(prevPhase) * (100 + magnitude * 50);
                const prevX2 = this.centerX - Math.sin(prevPhase) * (100 + magnitude * 50);

                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(prevX1, prevY);
                this.ctx.lineTo(x1, y);
                this.ctx.stroke();
                this.ctx.beginPath();
                this.ctx.moveTo(prevX2, prevY);
                this.ctx.lineTo(x2, y);
                this.ctx.stroke();
            }
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 32: Quantum Strings
     */
    renderQuantumStrings(magnitudes) {
        const numStrings = Math.min(magnitudes.length / 2, 20);
        const time = this.frameCounter * 0.02;

        this.ctx.shadowBlur = 20;

        for (let s = 0; s < numStrings; s++) {
            const magnitude = magnitudes[s * 2 % magnitudes.length];
            const startX = (s / numStrings) * this.canvas.width;
            const numPoints = 50;

            const color = this.getColor(s, numStrings);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 1 + magnitude * 2;

            this.ctx.beginPath();

            for (let i = 0; i < numPoints; i++) {
                const t = i / numPoints;
                const x = startX + (t * this.canvas.width);
                const y = this.centerY + Math.sin(t * Math.PI * 4 + time + s) * magnitude * 100;

                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }

            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 33: Magnetic Fields
     */
    renderMagneticFields(magnitudes) {
        const numLines = magnitudes.length / 2;

        this.ctx.shadowBlur = 10;

        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const startY = (i / numLines) * this.canvas.height;

            const color = this.getColor(i, numLines);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 1 + magnitude * 2;

            this.ctx.beginPath();

            const numPoints = 100;
            for (let p = 0; p < numPoints; p++) {
                const t = p / numPoints;
                const x = t * this.canvas.width;

                // Magnetic field curve
                const distFromCenter = Math.abs(startY - this.canvas.height / 2);
                const curve = Math.sin(t * Math.PI) * magnitude * (100 - distFromCenter * 0.3);
                const y = startY + curve;

                if (p === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }

            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 34: Gravitational Lens
     */
    renderGravitationalLens(magnitudes) {
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const numRings = 8;

        this.ctx.shadowBlur = 20;

        // Central mass
        const massRadius = 30 + avgMagnitude * 40;
        const color1 = this.getColor(0, numRings);
        this.ctx.shadowColor = color1;
        this.ctx.fillStyle = color1;
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, massRadius, 0, Math.PI * 2);
        this.ctx.fill();

        // Lensing rings
        for (let r = 0; r < numRings; r++) {
            const magnitude = magnitudes[r * (magnitudes.length / numRings)] || avgMagnitude;
            const baseRadius = this.getEffectiveInnerRadius() + r * 40;

            const color = this.getColor(r * 10, numRings * 10);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 2 + magnitude * 3;
            this.ctx.globalAlpha = 0.7;

            // Distorted ring
            this.ctx.beginPath();
            const numPoints = 100;
            for (let i = 0; i <= numPoints; i++) {
                const angle = (i / numPoints) * Math.PI * 2;
                const distortion = Math.sin(angle * 2) * magnitude * 20;
                const radius = baseRadius + distortion;

                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;

                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }
            this.ctx.stroke();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 35: Seismic Waves
     */
    renderSeismicWaves(magnitudes) {
        const centerY = this.canvas.height / 2;
        const numPoints = magnitudes.length;
        const spacing = this.canvas.width / numPoints;

        this.ctx.shadowBlur = 15;

        // Draw multiple seismic traces
        for (let trace = 0; trace < 3; trace++) {
            const yOffset = (trace - 1) * 100;
            const color = this.getColor(trace * 20, 60);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 2;

            this.ctx.beginPath();

            for (let i = 0; i < numPoints; i++) {
                const x = i * spacing;
                const magnitude = magnitudes[i];
                const amplitude = magnitude * 80;
                const y = centerY + yOffset + (Math.random() - 0.5) * amplitude;

                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }

            this.ctx.stroke();
        }

        // Draw grid
        this.ctx.strokeStyle = 'rgba(100, 100, 100, 0.2)';
        this.ctx.lineWidth = 1;
        for (let i = 0; i < 10; i++) {
            const y = (i / 10) * this.canvas.height;
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.canvas.width, y);
            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 989: Particle Accelerator
     * Particles racing around a circular accelerator ring with collision effects
     */
    renderParticleAccelerator(magnitudes) {
        const params = this.settings.modeParameters || {};
        const ringRadius = params.ringRadius || 200;
        const particleCount = Math.floor(params.particleCount || 24);
        const particleSpeed = params.particleSpeed || 1.5;
        const collisionEnergy = params.collisionEnergy || 50;
        const beamIntensity = params.beamIntensity || 1;

        const radius = ringRadius * this.scaleFactor;
        const time = this.frameCounter * 0.02 * particleSpeed;

        // Initialize particles if needed
        if (!this.acceleratorParticles || this.acceleratorParticles.length !== particleCount) {
            this.acceleratorParticles = [];
            for (let i = 0; i < particleCount; i++) {
                this.acceleratorParticles.push({
                    angle: (i / particleCount) * Math.PI * 2,
                    speed: 0.02 + (i % 2) * 0.01,
                    direction: i % 2 === 0 ? 1 : -1,
                    energy: 0
                });
            }
        }

        // Calculate average magnitude for collision detection
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Draw accelerator ring
        this.ctx.strokeStyle = this.getColor(0, 1);
        this.ctx.lineWidth = 3 * this.scaleFactor;
        this.ctx.shadowBlur = 15 * this.scaleFactor;
        this.ctx.shadowColor = this.getColor(0, 1);
        this.ctx.globalAlpha = 0.6;

        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
        this.ctx.stroke();

        // Draw magnetic field lines
        const fieldLines = 8;
        this.ctx.globalAlpha = 0.3;
        this.ctx.lineWidth = 1 * this.scaleFactor;
        for (let i = 0; i < fieldLines; i++) {
            const angle = (i / fieldLines) * Math.PI * 2;
            const x1 = this.centerX + Math.cos(angle) * (radius - 30 * this.scaleFactor);
            const y1 = this.centerY + Math.sin(angle) * (radius - 30 * this.scaleFactor);
            const x2 = this.centerX + Math.cos(angle) * (radius + 30 * this.scaleFactor);
            const y2 = this.centerY + Math.sin(angle) * (radius + 30 * this.scaleFactor);

            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }

        this.ctx.globalAlpha = 1;

        // Update and draw particles
        for (let i = 0; i < this.acceleratorParticles.length; i++) {
            const particle = this.acceleratorParticles[i];

            // Update particle position
            particle.angle += particle.speed * particle.direction * particleSpeed;
            particle.energy = magnitudes[i % magnitudes.length] || 0;

            const x = this.centerX + Math.cos(particle.angle) * radius;
            const y = this.centerY + Math.sin(particle.angle) * radius;

            // Draw particle trail
            const trailLength = 15;
            for (let t = 0; t < trailLength; t++) {
                const trailAngle = particle.angle - (t * 0.05 * particle.direction);
                const tx = this.centerX + Math.cos(trailAngle) * radius;
                const ty = this.centerY + Math.sin(trailAngle) * radius;

                const trailAlpha = (1 - t / trailLength) * 0.5;
                const color = this.getColor(i, particleCount);
                const rgb = this.parseRgbColor(color);

                this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${trailAlpha})`;
                const size = (3 - t * 0.15) * this.scaleFactor;
                this.ctx.fillRect(tx - size / 2, ty - size / 2, size, size);
            }

            // Draw particle
            const particleSize = (5 + particle.energy * 8) * this.scaleFactor * beamIntensity;
            const color = this.getColor(i, particleCount);

            this.ctx.shadowBlur = 20 * this.scaleFactor;
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;

            this.ctx.beginPath();
            this.ctx.arc(x, y, particleSize, 0, Math.PI * 2);
            this.ctx.fill();

            // Check for collisions with opposite-direction particles
            for (let j = i + 1; j < this.acceleratorParticles.length; j++) {
                const other = this.acceleratorParticles[j];
                if (particle.direction !== other.direction) {
                    const angleDiff = Math.abs(particle.angle - other.angle);
                    const normalizedDiff = Math.min(angleDiff, Math.PI * 2 - angleDiff);

                    // Collision detected
                    if (normalizedDiff < 0.2 && avgMagnitude > 0.5) {
                        const ox = this.centerX + Math.cos(other.angle) * radius;
                        const oy = this.centerY + Math.sin(other.angle) * radius;
                        const mx = (x + ox) / 2;
                        const my = (y + oy) / 2;

                        // Draw collision burst
                        const burstParticles = 12;
                        for (let b = 0; b < burstParticles; b++) {
                            const burstAngle = (b / burstParticles) * Math.PI * 2;
                            const burstDist = collisionEnergy * this.scaleFactor * avgMagnitude;
                            const bx = mx + Math.cos(burstAngle) * burstDist;
                            const by = my + Math.sin(burstAngle) * burstDist;

                            const burstColor = this.getColor(b, burstParticles);
                            const burstRgb = this.parseRgbColor(burstColor);

                            this.ctx.beginPath();
                            this.ctx.moveTo(mx, my);
                            this.ctx.lineTo(bx, by);
                            this.ctx.strokeStyle = `rgba(${burstRgb[0]}, ${burstRgb[1]}, ${burstRgb[2]}, 0.8)`;
                            this.ctx.lineWidth = 2 * this.scaleFactor;
                            this.ctx.shadowBlur = 10 * this.scaleFactor;
                            this.ctx.stroke();
                        }
                    }
                }
            }
        }

        this.ctx.shadowBlur = 0;
        this.ctx.globalAlpha = 1;
    }

    /**
     * Mode 988: Neural Network
     * Interconnected neurons firing with synaptic pulses based on audio
     */
    renderNeuralNetwork(magnitudes) {
        const params = this.settings.modeParameters || {};
        const neuronCount = Math.floor(params.neuronCount || 16);
        const connectionDensity = params.connectionDensity || 0.6;
        const fireRate = params.fireRate || 1.5;
        const pulseSpeed = params.pulseSpeed || 1.2;
        const neuronSize = params.neuronSize || 15;

        const time = this.frameCounter * 0.02;

        // Initialize neurons if needed
        if (!this.neurons || this.neurons.length !== neuronCount) {
            this.neurons = [];
            this.synapses = [];

            // Create neurons in a distributed pattern
            for (let i = 0; i < neuronCount; i++) {
                const angle = (i / neuronCount) * Math.PI * 2;
                const distance = (0.3 + Math.random() * 0.5) * this.maxRadius;
                const x = this.centerX + Math.cos(angle) * distance;
                const y = this.centerY + Math.sin(angle) * distance;

                this.neurons.push({
                    x: x,
                    y: y,
                    activation: 0,
                    frequencyIndex: i % magnitudes.length,
                    lastFireTime: 0
                });
            }

            // Create synaptic connections
            for (let i = 0; i < this.neurons.length; i++) {
                for (let j = i + 1; j < this.neurons.length; j++) {
                    if (Math.random() < connectionDensity) {
                        this.synapses.push({
                            from: i,
                            to: j,
                            pulses: []
                        });
                    }
                }
            }
        }

        // Update neuron activations based on audio
        for (let i = 0; i < this.neurons.length; i++) {
            const neuron = this.neurons[i];
            const magnitude = magnitudes[neuron.frequencyIndex] || 0;

            // Fire when magnitude crosses threshold
            if (magnitude > 0.5 && time - neuron.lastFireTime > (1 / fireRate)) {
                neuron.activation = 1;
                neuron.lastFireTime = time;

                // Create pulses along synapses
                for (const synapse of this.synapses) {
                    if (synapse.from === i || synapse.to === i) {
                        synapse.pulses.push({
                            progress: 0,
                            direction: synapse.from === i ? 1 : -1,
                            strength: magnitude
                        });
                    }
                }
            }

            // Decay activation
            neuron.activation *= 0.92;
        }

        // Draw synapses
        this.ctx.lineWidth = 2 * this.scaleFactor;
        this.ctx.globalAlpha = 0.3;

        for (const synapse of this.synapses) {
            const n1 = this.neurons[synapse.from];
            const n2 = this.neurons[synapse.to];

            this.ctx.beginPath();
            this.ctx.moveTo(n1.x, n1.y);
            this.ctx.lineTo(n2.x, n2.y);
            this.ctx.strokeStyle = this.getColor(synapse.from, this.neurons.length);
            this.ctx.stroke();
        }

        this.ctx.globalAlpha = 1;

        // Draw and update pulses
        for (const synapse of this.synapses) {
            const n1 = this.neurons[synapse.from];
            const n2 = this.neurons[synapse.to];

            // Update pulses
            synapse.pulses = synapse.pulses.filter(pulse => {
                pulse.progress += 0.02 * pulseSpeed;
                return pulse.progress < 1;
            });

            // Draw pulses
            for (const pulse of synapse.pulses) {
                const x = n1.x + (n2.x - n1.x) * pulse.progress;
                const y = n1.y + (n2.y - n1.y) * pulse.progress;

                const color = this.getColor(synapse.from, this.neurons.length);
                const rgb = this.parseRgbColor(color);

                this.ctx.shadowBlur = 15 * this.scaleFactor;
                this.ctx.shadowColor = color;
                this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${pulse.strength})`;

                const size = 4 * this.scaleFactor * pulse.strength;
                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        // Draw neurons
        for (let i = 0; i < this.neurons.length; i++) {
            const neuron = this.neurons[i];
            const color = this.getColor(i, this.neurons.length);
            const rgb = this.parseRgbColor(color);

            // Neuron body
            const size = (neuronSize + neuron.activation * 10) * this.scaleFactor;
            const alpha = 0.6 + neuron.activation * 0.4;

            this.ctx.shadowBlur = 20 * this.scaleFactor * neuron.activation;
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${alpha})`;

            this.ctx.beginPath();
            this.ctx.arc(neuron.x, neuron.y, size, 0, Math.PI * 2);
            this.ctx.fill();

            // Neuron core
            if (neuron.activation > 0.1) {
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                this.ctx.beginPath();
                this.ctx.arc(neuron.x, neuron.y, size * 0.4, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        this.ctx.shadowBlur = 0;
        this.ctx.globalAlpha = 1;
    }

    /**
     * Mode 36: Tunnel Vision
     */
    renderTunnelVision(magnitudes) {
        const numRings = 20;
        const time = this.frameCounter * 0.05;

        this.ctx.shadowBlur = 25;

        for (let r = 0; r < numRings; r++) {
            const t = (r + time) % numRings;
            const radius = (t / numRings) * this.maxRadius * 1.5;
            const magnitude = magnitudes[r % magnitudes.length];

            const color = this.getColor(r, numRings);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 3 + magnitude * 10;
            this.ctx.globalAlpha = 1 - (t / numRings);

            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 37: Matrix Code
     */
    renderMatrixCode(magnitudes) {
        const columns = Math.min(magnitudes.length, 60);
        const columnWidth = this.canvas.width / columns;
        const charHeight = 20;

        this.ctx.shadowBlur = 15;
        this.ctx.font = '14px monospace';

        for (let i = 0; i < columns; i++) {
            const magnitude = magnitudes[i];
            const numChars = Math.floor(magnitude * 30);

            const color = this.getColor(i, columns);
            this.ctx.shadowColor = color;

            for (let c = 0; c < numChars; c++) {
                const x = i * columnWidth + columnWidth / 2;
                const y = ((this.frameCounter * magnitude * 2 + c * charHeight) % this.canvas.height);
                const char = String.fromCharCode(0x30A0 + Math.floor(Math.random() * 96));

                const alpha = 1 - (c / numChars);
                this.ctx.fillStyle = color;
                this.ctx.globalAlpha = alpha * magnitude;
                this.ctx.fillText(char, x, y);
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 38: Hologram Glitch
     */
    renderHologramGlitch(magnitudes) {
        const numBars = magnitudes.length;
        const angleStep = (Math.PI * 2) / numBars;
        const innerRadius = this.getEffectiveInnerRadius();
        const glitchIntensity = Math.max(...magnitudes);

        this.ctx.shadowBlur = 20;

        for (let i = 0; i < numBars; i++) {
            const angle = i * angleStep;
            const magnitude = magnitudes[i];

            // Glitch offset
            const glitchX = (Math.random() - 0.5) * glitchIntensity * 20;
            const glitchY = (Math.random() - 0.5) * glitchIntensity * 20;

            const barLength = magnitude * this.maxRadius * 0.6;
            const x1 = this.centerX + Math.cos(angle) * innerRadius + glitchX;
            const y1 = this.centerY + Math.sin(angle) * innerRadius + glitchY;
            const x2 = this.centerX + Math.cos(angle) * (innerRadius + barLength) + glitchX;
            const y2 = this.centerY + Math.sin(angle) * (innerRadius + barLength) + glitchY;

            const color = this.getColor(i, numBars);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 3;
            this.ctx.globalAlpha = 0.6 + Math.random() * 0.4;

            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 39: Circuit Board
     */
    renderCircuitBoard(magnitudes) {
        const gridSize = 40;
        const cols = Math.floor(this.canvas.width / gridSize);
        const rows = Math.floor(this.canvas.height / gridSize);

        this.ctx.shadowBlur = 15;

        // Draw grid
        this.ctx.strokeStyle = this.getColor(0, magnitudes.length);
        this.ctx.lineWidth = 1;
        this.ctx.globalAlpha = 0.3;

        for (let x = 0; x < cols; x++) {
            for (let y = 0; y < rows; y++) {
                this.ctx.strokeRect(x * gridSize, y * gridSize, gridSize, gridSize);
            }
        }

        this.ctx.globalAlpha = 1;

        // Draw active paths
        const numPaths = Math.min(magnitudes.length / 2, cols);

        for (let i = 0; i < numPaths; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            if (magnitude < 0.3) continue;

            const x = (i % cols) * gridSize + gridSize / 2;
            const segments = Math.floor(magnitude * 10);

            const color = this.getColor(i, numPaths);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 2;

            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);

            let currentY = 0;
            for (let s = 0; s < segments; s++) {
                currentY += gridSize;
                if (currentY > this.canvas.height) break;

                const horizontalShift = (Math.random() > 0.5 ? 1 : -1) * gridSize;
                this.ctx.lineTo(x, currentY);
                this.ctx.lineTo(x + horizontalShift, currentY);
            }

            this.ctx.stroke();

            // Draw nodes
            this.ctx.fillStyle = color;
            this.ctx.beginPath();
            this.ctx.arc(x, 0, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 40: Neural Network
     */
    renderNeuralNetwork(magnitudes) {
        const layers = 4;
        const nodesPerLayer = 8;
        const layerSpacing = this.canvas.width / (layers + 1);
        const nodeSpacing = this.canvas.height / (nodesPerLayer + 1);

        this.ctx.shadowBlur = 15;

        // Draw connections
        for (let l = 0; l < layers - 1; l++) {
            for (let n1 = 0; n1 < nodesPerLayer; n1++) {
                for (let n2 = 0; n2 < nodesPerLayer; n2++) {
                    const magnitude = magnitudes[(l * nodesPerLayer + n1) % magnitudes.length];

                    if (magnitude > 0.4) {
                        const x1 = (l + 1) * layerSpacing;
                        const y1 = (n1 + 1) * nodeSpacing;
                        const x2 = (l + 2) * layerSpacing;
                        const y2 = (n2 + 1) * nodeSpacing;

                        const color = this.getColor(l * nodesPerLayer + n1, magnitudes.length);
                        this.ctx.shadowColor = color;
                        this.ctx.strokeStyle = color;
                        this.ctx.lineWidth = magnitude * 2;
                        this.ctx.globalAlpha = magnitude * 0.6;

                        this.ctx.beginPath();
                        this.ctx.moveTo(x1, y1);
                        this.ctx.lineTo(x2, y2);
                        this.ctx.stroke();
                    }
                }
            }
        }

        this.ctx.globalAlpha = 1;

        // Draw nodes
        for (let l = 0; l < layers; l++) {
            for (let n = 0; n < nodesPerLayer; n++) {
                const x = (l + 1) * layerSpacing;
                const y = (n + 1) * nodeSpacing;
                const magnitude = magnitudes[(l * nodesPerLayer + n) % magnitudes.length];
                const size = 5 + magnitude * 10;

                const color = this.getColor(l * nodesPerLayer + n, magnitudes.length);
                this.ctx.shadowColor = color;
                this.ctx.fillStyle = color;

                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 41: Lightning Strikes
     */
    renderLightningStrikes(magnitudes) {
        // Get parameters with defaults
        const threshold = this.settings.lightningStrikesThreshold || 0.5;
        const baseSegments = this.settings.lightningStrikesSegments || 10;
        const segmentRange = this.settings.lightningStrikesSegmentRange || 10;
        const zigzagAmount = this.settings.lightningStrikesZigzagAmount || 40;
        const branchProbability = this.settings.lightningStrikesBranchProbability || 0.7;
        const baseLineWidth = this.settings.lightningStrikesLineWidth || 2;
        const lineWidthRange = this.settings.lightningStrikesLineWidthRange || 4;

        const numBolts = magnitudes.length;

        this.ctx.shadowBlur = 25;

        for (let i = 0; i < numBolts; i++) {
            const magnitude = magnitudes[i];
            if (magnitude < threshold) continue;

            const startX = (i / numBolts) * this.canvas.width;
            const startY = 0;
            const endY = this.canvas.height;

            const color = this.getColor(i, numBolts);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = baseLineWidth + magnitude * lineWidthRange;

            this.ctx.beginPath();
            this.ctx.moveTo(startX, startY);

            let currentX = startX;
            let currentY = startY;
            const segments = baseSegments + Math.floor(magnitude * segmentRange);

            for (let s = 0; s < segments; s++) {
                currentY += (endY - startY) / segments;
                currentX += (Math.random() - 0.5) * zigzagAmount * magnitude;

                this.ctx.lineTo(currentX, currentY);

                // Branch
                if (Math.random() > branchProbability) {
                    const branchX = currentX + (Math.random() - 0.5) * 60;
                    const branchY = currentY + 40;
                    this.ctx.moveTo(currentX, currentY);
                    this.ctx.lineTo(branchX, branchY);
                    this.ctx.moveTo(currentX, currentY);
                }
            }

            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 42: Plasma Storm
     */
    renderPlasmaStorm(magnitudes) {
        // Get parameters with defaults
        const numVortices = this.settings.plasmaStormNumVortices || 3;
        const rotationSpeed = this.settings.plasmaStormRotationSpeed || 0.03;
        const vortexDistance = this.settings.plasmaStormVortexDistance || 0.5;
        const particleDistance = this.settings.plasmaStormParticleDistance || 100;
        const baseParticleSize = this.settings.plasmaStormParticleSize || 2;
        const particleSizeRange = this.settings.plasmaStormParticleSizeRange || 6;

        const time = this.frameCounter * rotationSpeed;

        this.ctx.shadowBlur = 30;

        for (let v = 0; v < numVortices; v++) {
            const vortexAngle = (v / numVortices) * Math.PI * 2 + time;
            const vortexDist = this.getEffectiveInnerRadius() * vortexDistance;
            const vortexX = this.centerX + Math.cos(vortexAngle) * vortexDist;
            const vortexY = this.centerY + Math.sin(vortexAngle) * vortexDist;

            const numParticles = Math.floor(magnitudes.length / numVortices);

            for (let i = 0; i < numParticles; i++) {
                const magnitude = magnitudes[v * numParticles + i % magnitudes.length];
                const angle = (i / numParticles) * Math.PI * 2 + time * 2;
                const distance = magnitude * particleDistance;

                const x = vortexX + Math.cos(angle) * distance;
                const y = vortexY + Math.sin(angle) * distance;
                const size = baseParticleSize + magnitude * particleSizeRange;

                const color = this.getColor(v * numParticles + i, magnitudes.length);
                this.ctx.shadowColor = color;
                this.ctx.fillStyle = color;
                this.ctx.globalAlpha = 0.7;

                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 43: Laser Show
     */
    renderLaserShow(magnitudes) {
        // Get parameters with defaults
        const maxLasers = this.settings.laserShowMaxLasers || 20;
        const threshold = this.settings.laserShowThreshold || 0.3;
        const rotationSpeed = this.settings.laserShowRotationSpeed || 0.05;
        const laserLength = this.settings.laserShowLaserLength || 1.5;
        const baseLineWidth = this.settings.laserShowLineWidth || 3;
        const lineWidthRange = this.settings.laserShowLineWidthRange || 5;
        const endGlowSize = this.settings.laserShowEndGlowSize || 5;
        const endGlowRange = this.settings.laserShowEndGlowRange || 10;

        const numLasers = Math.min(magnitudes.length / 2, maxLasers);
        const time = this.frameCounter * rotationSpeed;

        this.ctx.shadowBlur = 30;

        for (let i = 0; i < numLasers; i++) {
            const magnitude = magnitudes[i * 2 % magnitudes.length];
            if (magnitude < threshold) continue;

            const angle = (i / numLasers) * Math.PI * 2 + time + magnitude;
            const length = this.maxRadius * laserLength;

            const x1 = this.centerX;
            const y1 = this.centerY;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const color = this.getColor(i, numLasers);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = baseLineWidth + magnitude * lineWidthRange;
            this.ctx.globalAlpha = 0.8;

            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();

            // End glow
            this.ctx.fillStyle = color;
            this.ctx.beginPath();
            this.ctx.arc(x2, y2, endGlowSize + magnitude * endGlowRange, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 44: Energy Pulses
     */
    renderEnergyPulses(magnitudes) {
        // Get parameters with defaults
        const numPulses = this.settings.energyPulsesNumPulses || 6;
        const pulseSpeed = this.settings.energyPulsesPulseSpeed || 0.1;
        const pulseSpread = this.settings.energyPulsesPulseSpread || 100;
        const baseLineWidth = this.settings.energyPulsesLineWidth || 3;
        const lineWidthRange = this.settings.energyPulsesLineWidthRange || 8;

        const time = this.frameCounter * pulseSpeed;

        this.ctx.shadowBlur = 25;

        for (let p = 0; p < numPulses; p++) {
            const phase = (time + p * 0.5) % 3;
            const radius = this.getEffectiveInnerRadius() + phase * pulseSpread;
            const magnitude = magnitudes[Math.floor(p * (magnitudes.length / numPulses)) % magnitudes.length];

            const color = this.getColor(p * 10, numPulses * 10);
            this.ctx.shadowColor = color;
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = baseLineWidth + magnitude * lineWidthRange;
            this.ctx.globalAlpha = Math.max(0, 1 - phase / 3);

            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 45: Rainbow Prism
     */
    renderRainbowPrism(magnitudes) {
        const numRays = magnitudes.length;
        const angleStep = (Math.PI * 2) / numRays;
        const innerRadius = this.getEffectiveInnerRadius() * 0.5;

        this.ctx.shadowBlur = 20;

        for (let i = 0; i < numRays; i++) {
            const angle = i * angleStep;
            const magnitude = magnitudes[i];
            const length = magnitude * this.maxRadius * 0.8;

            const x1 = this.centerX + Math.cos(angle) * innerRadius;
            const y1 = this.centerY + Math.sin(angle) * innerRadius;
            const x2 = this.centerX + Math.cos(angle) * (innerRadius + length);
            const y2 = this.centerY + Math.sin(angle) * (innerRadius + length);

            // Create gradient for each ray
            const gradient = this.ctx.createLinearGradient(x1, y1, x2, y2);
            const color1 = this.getColor(i, numRays);
            const color2 = this.getColor((i + numRays / 6) % numRays, numRays);

            gradient.addColorStop(0, color1);
            gradient.addColorStop(1, color2);

            this.ctx.shadowColor = color1;
            this.ctx.strokeStyle = gradient;
            this.ctx.lineWidth = 4 + magnitude * 6;
            this.ctx.globalAlpha = 0.8;

            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }

        // Central prism
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        this.ctx.globalAlpha = 1;
        this.ctx.fillStyle = this.getColor(0, numRays);
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, innerRadius * 0.6 + avgMagnitude * 20, 0, Math.PI * 2);
        this.ctx.fill();

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 987: Supernova Burst
     * Explosive stellar energy with radiating particles and shockwaves
     */
    renderSupernovaBurst(magnitudes) {
        const params = this.settings.modeParameters || {};
        const burstIntensity = params.burstIntensity || 1.5;
        const particleDensity = Math.floor(params.particleDensity || 80);
        const expansionSpeed = params.expansionSpeed || 2.5;
        const shockwaveCount = Math.floor(params.shockwaveCount || 4);
        const coreSize = params.coreSize || 40;
        const energyDecay = params.energyDecay || 0.95;

        const time = this.frameCounter * 0.02;
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const peakMagnitude = Math.max(...magnitudes);

        // Initialize burst particles if needed
        if (!this.burstParticles || this.frameCounter % 60 === 0 || peakMagnitude > 0.8) {
            this.burstParticles = this.burstParticles || [];

            // Add new particles when there's energy
            if (peakMagnitude > 0.3) {
                for (let i = 0; i < particleDensity * burstIntensity * peakMagnitude; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = (2 + Math.random() * 3) * expansionSpeed;

                    this.burstParticles.push({
                        x: this.centerX,
                        y: this.centerY,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1,
                        size: 2 + Math.random() * 4,
                        color: Math.floor(Math.random() * magnitudes.length),
                        energy: peakMagnitude
                    });
                }
            }
        }

        // Update and draw particles
        this.burstParticles = this.burstParticles.filter(p => p.life > 0);

        for (const particle of this.burstParticles) {
            // Update particle
            particle.x += particle.vx * this.scaleFactor;
            particle.y += particle.vy * this.scaleFactor;
            particle.life *= energyDecay;
            particle.vx *= 0.99; // Slight drag
            particle.vy *= 0.99;

            // Draw particle trail
            const color = this.getColor(particle.color, magnitudes.length);
            const rgb = this.parseRgbColor(color);
            const alpha = particle.life * particle.energy;

            this.ctx.shadowBlur = 15 * this.scaleFactor * particle.life;
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${alpha})`;

            const size = particle.size * this.scaleFactor * particle.life * burstIntensity;
            this.ctx.beginPath();
            this.ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        // Draw shockwave rings
        for (let i = 0; i < shockwaveCount; i++) {
            const waveTime = (time * expansionSpeed + i * 0.5) % 4;
            const radius = waveTime * this.maxRadius * 0.5;
            const alpha = Math.max(0, 1 - waveTime / 4) * avgMagnitude;

            if (alpha > 0) {
                const colorIndex = Math.floor((i / shockwaveCount) * magnitudes.length);
                const color = this.getColor(colorIndex, magnitudes.length);
                const rgb = this.parseRgbColor(color);

                this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${alpha})`;
                this.ctx.lineWidth = (6 - waveTime) * this.scaleFactor;
                this.ctx.shadowBlur = 20 * this.scaleFactor;
                this.ctx.shadowColor = color;

                this.ctx.beginPath();
                this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
                this.ctx.stroke();
            }
        }

        // Draw pulsing core
        const corePulse = 0.8 + Math.sin(time * 5) * 0.2;
        const coreRadius = (coreSize + avgMagnitude * 40) * this.scaleFactor * corePulse;

        const gradient = this.ctx.createRadialGradient(
            this.centerX, this.centerY, 0,
            this.centerX, this.centerY, coreRadius
        );

        const coreColor = this.getColor(0, 1);
        const coreRgb = this.parseRgbColor(coreColor);
        gradient.addColorStop(0, `rgba(255, 255, 255, ${avgMagnitude})`);
        gradient.addColorStop(0.3, `rgba(${coreRgb[0]}, ${coreRgb[1]}, ${coreRgb[2]}, ${avgMagnitude * 0.8})`);
        gradient.addColorStop(1, `rgba(${coreRgb[0]}, ${coreRgb[1]}, ${coreRgb[2]}, 0)`);

        this.ctx.shadowBlur = 40 * this.scaleFactor;
        this.ctx.shadowColor = coreColor;
        this.ctx.fillStyle = gradient;
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, coreRadius, 0, Math.PI * 2);
        this.ctx.fill();

        this.ctx.shadowBlur = 0;
        this.ctx.globalAlpha = 1;
    }

    /**
     * Mode 986: Electric Web
     * Tesla coil network with arcing electricity connecting reactive nodes
     */
    renderElectricWeb(magnitudes) {
        const params = this.settings.modeParameters || {};
        const nodeCount = Math.floor(params.nodeCount || 12);
        const arcThreshold = params.arcThreshold || 0.4;
        const arcIntensity = params.arcIntensity || 1.5;
        const pulseSpeed = params.pulseSpeed || 1.5;
        const nodeSize = params.nodeSize || 12;
        const webDensity = params.webDensity || 0.6;

        const time = this.frameCounter * 0.02 * pulseSpeed;

        // Initialize nodes if needed
        if (!this.webNodes || this.webNodes.length !== nodeCount) {
            this.webNodes = [];
            for (let i = 0; i < nodeCount; i++) {
                const angle = (i / nodeCount) * Math.PI * 2;
                const radius = (0.5 + Math.random() * 0.3) * this.maxRadius;

                this.webNodes.push({
                    x: this.centerX + Math.cos(angle) * radius,
                    y: this.centerY + Math.sin(angle) * radius,
                    baseX: this.centerX + Math.cos(angle) * radius,
                    baseY: this.centerY + Math.sin(angle) * radius,
                    charge: 0,
                    frequencyIndex: i % magnitudes.length
                });
            }
        }

        // Update node charges and positions
        for (let i = 0; i < this.webNodes.length; i++) {
            const node = this.webNodes[i];
            const magnitude = magnitudes[node.frequencyIndex] || 0;

            node.charge = magnitude;

            // Slight wobble based on energy
            const wobble = magnitude * 15 * this.scaleFactor;
            node.x = node.baseX + Math.sin(time + i) * wobble;
            node.y = node.baseY + Math.cos(time * 1.3 + i) * wobble;
        }

        // Draw arcs between nodes
        for (let i = 0; i < this.webNodes.length; i++) {
            for (let j = i + 1; j < this.webNodes.length; j++) {
                // Draw arcs based on connection density and charge
                if (Math.random() > (1 - webDensity)) {
                    const node1 = this.webNodes[i];
                    const node2 = this.webNodes[j];
                    const combinedCharge = (node1.charge + node2.charge) / 2;

                    if (combinedCharge > arcThreshold) {
                        // Generate jagged electric arc
                        const segments = 8;
                        const points = [{x: node1.x, y: node1.y}];

                        for (let s = 1; s < segments; s++) {
                            const t = s / segments;
                            const baseX = node1.x + (node2.x - node1.x) * t;
                            const baseY = node1.y + (node2.y - node1.y) * t;

                            // Add electric jitter
                            const jitter = (30 + combinedCharge * 40) * this.scaleFactor * arcIntensity;
                            const offsetX = (Math.random() - 0.5) * jitter;
                            const offsetY = (Math.random() - 0.5) * jitter;

                            points.push({
                                x: baseX + offsetX,
                                y: baseY + offsetY
                            });
                        }
                        points.push({x: node2.x, y: node2.y});

                        // Draw the arc
                        const color = this.getColor(i, this.webNodes.length);
                        const rgb = this.parseRgbColor(color);
                        const alpha = 0.5 + combinedCharge * 0.5;

                        this.ctx.beginPath();
                        this.ctx.moveTo(points[0].x, points[0].y);
                        for (let p = 1; p < points.length; p++) {
                            this.ctx.lineTo(points[p].x, points[p].y);
                        }

                        this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${alpha})`;
                        this.ctx.lineWidth = (1 + combinedCharge * 3) * this.scaleFactor;
                        this.ctx.shadowBlur = 15 * this.scaleFactor * combinedCharge;
                        this.ctx.shadowColor = color;
                        this.ctx.stroke();
                    }
                }
            }
        }

        // Draw nodes
        for (let i = 0; i < this.webNodes.length; i++) {
            const node = this.webNodes[i];
            const color = this.getColor(i, this.webNodes.length);
            const rgb = this.parseRgbColor(color);

            const size = (nodeSize + node.charge * 15) * this.scaleFactor;
            const pulse = 0.8 + Math.sin(time * 3 + i) * 0.2;

            // Outer glow
            const gradient = this.ctx.createRadialGradient(
                node.x, node.y, 0,
                node.x, node.y, size * 1.5
            );
            gradient.addColorStop(0, `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${node.charge})`);
            gradient.addColorStop(1, `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0)`);

            this.ctx.fillStyle = gradient;
            this.ctx.beginPath();
            this.ctx.arc(node.x, node.y, size * 1.5, 0, Math.PI * 2);
            this.ctx.fill();

            // Core
            this.ctx.shadowBlur = 20 * this.scaleFactor * node.charge;
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.9)`;
            this.ctx.beginPath();
            this.ctx.arc(node.x, node.y, size * pulse, 0, Math.PI * 2);
            this.ctx.fill();

            // Bright center
            if (node.charge > 0.5) {
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                this.ctx.beginPath();
                this.ctx.arc(node.x, node.y, size * 0.4, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        this.ctx.shadowBlur = 0;
        this.ctx.globalAlpha = 1;
    }

    /**
     * Mode 985: Kinetic Shockwave
     * Powerful circular shockwaves with space distortion and energy ripples
     */
    renderKineticShockwave(magnitudes) {
        const params = this.settings.modeParameters || {};
        const waveCount = Math.floor(params.waveCount || 6);
        const waveSpeed = params.waveSpeed || 2;
        const distortionAmount = params.distortionAmount || 20;
        const impactForce = params.impactForce || 1.5;
        const waveThickness = params.waveThickness || 6;
        const particleTrail = Math.floor(params.particleTrail || 20);

        const time = this.frameCounter * 0.02;
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const peakMagnitude = Math.max(...magnitudes);

        // Initialize shockwaves array
        if (!this.shockwaves) {
            this.shockwaves = [];
        }

        // Create new shockwave on strong beats
        if (peakMagnitude > 0.6 && this.frameCounter % Math.max(10, 40 - peakMagnitude * 30) === 0) {
            this.shockwaves.push({
                radius: 0,
                strength: peakMagnitude * impactForce,
                life: 1,
                startTime: time,
                particleAngles: Array.from({length: particleTrail}, () => Math.random() * Math.PI * 2),
                waveFormation: Array.from({length: 360}, (_, i) => ({
                    angle: (i / 360) * Math.PI * 2,
                    distortion: Math.sin(i * 0.1 + time) * distortionAmount * 0.5
                }))
            });
        }

        // Limit number of active shockwaves
        if (this.shockwaves.length > waveCount) {
            this.shockwaves = this.shockwaves.slice(-waveCount);
        }

        // Update and draw shockwaves
        this.shockwaves = this.shockwaves.filter(wave => wave.life > 0);

        for (let w = 0; w < this.shockwaves.length; w++) {
            const wave = this.shockwaves[w];

            // Update wave
            wave.radius += waveSpeed * this.scaleFactor * 5 * wave.strength;
            wave.life -= 0.01 / wave.strength;

            const alpha = wave.life * wave.strength;

            if (alpha > 0 && wave.radius < this.maxRadius * 2) {
                // Draw primary shockwave with distortion effect
                const distortionRings = Math.ceil(4 + distortionAmount / 15);
                for (let d = 0; d < distortionRings; d++) {
                    const distOffset = (d - distortionRings / 2) * distortionAmount * this.scaleFactor * 0.8;
                    const distRadius = wave.radius + distOffset;

                    if (distRadius > 0) {
                        const colorIndex = Math.floor((w / waveCount) * magnitudes.length);
                        const color = this.getColor(colorIndex, magnitudes.length);
                        const rgb = this.parseRgbColor(color);
                        const distAlpha = alpha * (0.4 + (1 - Math.abs(d - distortionRings / 2) / (distortionRings / 2)) * 0.8);

                        // Enhanced wave thickness based on parameter
                        const baseThickness = (waveThickness / 6) * 2;
                        this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${distAlpha})`;
                        this.ctx.lineWidth = Math.max(2, baseThickness * this.scaleFactor * (1.5 + wave.strength * 2));
                        this.ctx.shadowBlur = 35 * this.scaleFactor * wave.strength * Math.max(1, waveThickness / 6);
                        this.ctx.shadowColor = color;
                        this.ctx.lineCap = 'round';

                        this.ctx.beginPath();
                        this.ctx.arc(this.centerX, this.centerY, distRadius, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                }

                // Draw energy ripples that follow the distortion
                const rippleCount = Math.ceil(particleTrail / 4);
                for (let r = 0; r < rippleCount; r++) {
                    const rippleRadius = wave.radius * (1 + (r / rippleCount) * 0.3);
                    const rippleAlpha = alpha * (0.6 - r / rippleCount * 0.5);
                    const colorIndex = Math.floor((w / waveCount + r / rippleCount) * magnitudes.length) % magnitudes.length;
                    const color = this.getColor(colorIndex, magnitudes.length);
                    const rgb = this.parseRgbColor(color);

                    this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${rippleAlpha})`;
                    this.ctx.lineWidth = Math.max(1, (waveThickness / 6) * this.scaleFactor * wave.strength);
                    this.ctx.shadowBlur = 15 * this.scaleFactor;
                    this.ctx.shadowColor = color;

                    this.ctx.beginPath();
                    this.ctx.arc(this.centerX, this.centerY, rippleRadius, 0, Math.PI * 2);
                    this.ctx.stroke();
                }

                // Draw particle trail with enhanced behavior
                if (particleTrail > 0) {
                    for (let p = 0; p < wave.particleAngles.length; p++) {
                        const angle = wave.particleAngles[p];
                        // Add distortion movement to particles
                        const distortionPhase = Math.sin(p / wave.particleAngles.length * Math.PI * 2 + time * 2);
                        const radiusVariation = wave.radius * (1 + distortionPhase * (distortionAmount / 100));

                        const x = this.centerX + Math.cos(angle) * radiusVariation;
                        const y = this.centerY + Math.sin(angle) * radiusVariation;

                        const colorIndex = Math.floor((p / wave.particleAngles.length) * magnitudes.length);
                        const color = this.getColor(colorIndex, magnitudes.length);
                        const rgb = this.parseRgbColor(color);

                        this.ctx.shadowBlur = 15 * this.scaleFactor * Math.max(1, waveThickness / 6);
                        this.ctx.shadowColor = color;
                        this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${alpha * 0.8})`;

                        const size = Math.max(2, (4 + wave.strength * 7) * this.scaleFactor * (particleTrail / 20));
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, size, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            }
        }

        // Draw impact center with enhanced effect
        const centerPulse = avgMagnitude * impactForce;
        if (centerPulse > 0.05) {
            const centerRadius = 25 * this.scaleFactor * centerPulse * impactForce;

            const gradient = this.ctx.createRadialGradient(
                this.centerX, this.centerY, 0,
                this.centerX, this.centerY, centerRadius
            );

            const centerColor = this.getColor(0, 1);
            const centerRgb = this.parseRgbColor(centerColor);
            gradient.addColorStop(0, `rgba(255, 255, 255, ${centerPulse * 1.2})`);
            gradient.addColorStop(0.3, `rgba(${centerRgb[0]}, ${centerRgb[1]}, ${centerRgb[2]}, ${centerPulse * 0.8})`);
            gradient.addColorStop(1, `rgba(${centerRgb[0]}, ${centerRgb[1]}, ${centerRgb[2]}, 0)`);

            this.ctx.shadowBlur = 40 * this.scaleFactor * Math.max(1, waveThickness / 6);
            this.ctx.shadowColor = centerColor;
            this.ctx.fillStyle = gradient;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, centerRadius, 0, Math.PI * 2);
            this.ctx.fill();

            // Draw additional energy rings from center
            for (let i = 1; i <= 3; i++) {
                const ringRadius = centerRadius * (i / 3);
                const ringAlpha = centerPulse * (1 - i / 3) * 0.6;
                this.ctx.strokeStyle = `rgba(${centerRgb[0]}, ${centerRgb[1]}, ${centerRgb[2]}, ${ringAlpha})`;
                this.ctx.lineWidth = 2 * this.scaleFactor;
                this.ctx.beginPath();
                this.ctx.arc(this.centerX, this.centerY, ringRadius, 0, Math.PI * 2);
                this.ctx.stroke();
            }
        }

        this.ctx.shadowBlur = 0;
        this.ctx.globalAlpha = 1;
    }

    /**
     * Mode 46: Neon Rain (already implemented - keeping reference)
     */
    // renderNeonRain is already implemented above

    /**
     * Mode 47: Jazzy Fireworks (already implemented - keeping reference)
     */
    // renderJazzyFireworks is already implemented above

    /**
     * Mode 48: Retro Cassette New (already implemented - keeping reference)
     */
    // renderRetroCassetteNew is already implemented above

    /**
     * Mode 49: Soul Aura (already implemented - keeping reference)
     */
    // renderSoulAura is already implemented above

    /**
     * Mode 50: Frequency Flowers (migrated)
     */
    renderFrequencyFlowers(magnitudes) {
        const numPetals = Math.min(24, magnitudes.length);
        const angleStep = (Math.PI * 2) / numPetals;
        const time = this.frameCounter * 0.5;

        this.ctx.shadowBlur = 15;

        for (let i = 0; i < numPetals; i++) {
            const angle = i * angleStep + time * 0.01;
            const magnitude = magnitudes[Math.floor((i / numPetals) * magnitudes.length)];

            const petalLength = 50 + magnitude * 150;
            const petalWidth = 20 + magnitude * 40;
            const baseRadius = this.maxRadius * 0.4;

            const baseX = this.centerX + Math.cos(angle) * baseRadius;
            const baseY = this.centerY + Math.sin(angle) * baseRadius;

            const tipX = baseX + Math.cos(angle) * petalLength;
            const tipY = baseY + Math.sin(angle) * petalLength;

            const centerX = (baseX + tipX) / 2;
            const centerY = (baseY + tipY) / 2;

            // Use color scheme for petals
            const color = this.getColor(i, numPetals);

            this.ctx.fillStyle = color;
            this.ctx.shadowColor = color;

            this.ctx.save();
            this.ctx.translate(centerX, centerY);
            this.ctx.rotate(angle);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, petalWidth / 2, petalLength / 2, 0, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.restore();
        }

        // Flower center - use color scheme
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const centerRadius = 30 + avgMagnitude * 50;
        this.ctx.shadowBlur = 20;
        const centerColorIndex = Math.floor(magnitudes.length / 2);
        this.ctx.fillStyle = this.getColor(centerColorIndex, magnitudes.length);
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, centerRadius, 0, Math.PI * 2);
        this.ctx.fill();

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 51: Fractal Tree
     */
    renderFractalTree(magnitudes) {
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);

        // Trunk sway
        const trunkSway = Math.sin(this.frameCounter * 0.1 + avgMagnitude) * 20;
        const trunkBase = { x: this.centerX + trunkSway, y: this.canvas.height - 50 };
        const trunkTop = { x: this.centerX + trunkSway, y: this.centerY };

        // Draw trunk - use color scheme
        const trunkThickness = 10 + avgMagnitude * 15;
        const trunkColorIndex = 0;
        this.ctx.strokeStyle = this.getColor(trunkColorIndex, magnitudes.length);
        this.ctx.lineWidth = trunkThickness;
        this.ctx.lineCap = 'round';
        this.ctx.beginPath();
        this.ctx.moveTo(trunkBase.x, trunkBase.y);
        this.ctx.lineTo(trunkTop.x, trunkTop.y);
        this.ctx.stroke();

        // Spawn branches on bass hits
        if (!this.fractalTreeBranches) this.fractalTreeBranches = [];
        if (bass > 0.3 && this.frameCounter % 8 === 0) {
            const angle = -Math.PI / 2 + (Math.random() - 0.5) * Math.PI / 3;
            this.fractalTreeBranches.push({
                x: trunkTop.x,
                y: trunkTop.y,
                angle: angle,
                length: 40 + bass * 60,
                thickness: 3 + bass * 8,
                generation: 0,
                life: 1.0
            });
        }

        // Update and draw branches
        this.fractalTreeBranches = this.fractalTreeBranches.filter(branch => {
            if (branch.life <= 0) return false;

            const endX = branch.x + Math.cos(branch.angle) * branch.length;
            const endY = branch.y + Math.sin(branch.angle) * branch.length;

            this.ctx.globalAlpha = branch.life;
            const branchColorIndex = Math.floor(branch.generation * 2) % magnitudes.length;
            const branchColorStr = this.getColor(branchColorIndex, magnitudes.length);
            const branchRgb = this.parseRgbColor(branchColorStr);
            this.ctx.strokeStyle = `rgba(${branchRgb[0]}, ${branchRgb[1]}, ${branchRgb[2]}, ${branch.life})`;
            this.ctx.lineWidth = branch.thickness;
            this.ctx.beginPath();
            this.ctx.moveTo(branch.x, branch.y);
            this.ctx.lineTo(endX, endY);
            this.ctx.stroke();

            // Bloom flowers on treble - use color scheme
            if (treble > 0.4 && branch.generation > 0) {
                const bloomSize = 3 + treble * 10;
                const bloomColorIndex = magnitudes.length - 1;
                const bloomColorStr = this.getColor(bloomColorIndex, magnitudes.length);
                const rgb = this.parseRgbColor(bloomColorStr);
                this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${branch.life})`;
                this.ctx.beginPath();
                this.ctx.arc(endX, endY, bloomSize, 0, Math.PI * 2);
                this.ctx.fill();
            }

            branch.life -= 0.003;
            return true;
        }).slice(0, 100);

        this.ctx.globalAlpha = 1;
    }

    /**
     * Mode 52: Cityscape Extrusion
     */
    renderCityscapeExtrusion(magnitudes) {
        const numBlocks = Math.min(magnitudes.length, 40);
        const blockWidth = this.canvas.width / numBlocks;

        for (let i = 0; i < numBlocks; i++) {
            const magnitude = magnitudes[i] || 0;
            const buildingHeight = magnitude * this.canvas.height * 0.7;

            const baseY = this.canvas.height - 100;
            const topY = baseY - buildingHeight;
            const xLeft = i * blockWidth + 5;
            const xRight = (i + 1) * blockWidth - 5;

            // Building color - use color scheme
            this.ctx.fillStyle = this.getColor(i, numBlocks);
            this.ctx.fillRect(xLeft, topY, xRight - xLeft, baseY - topY);

            // Windows
            if (magnitude > 0.3) {
                const numWindows = Math.max(2, Math.floor(buildingHeight / 30));
                for (let w = 0; w < numWindows; w++) {
                    const windowY = baseY - ((w + 0.5) * buildingHeight / numWindows);
                    const windowX = (xLeft + xRight) / 2;
                    const brightness = 255 * magnitude;
                    this.ctx.fillStyle = `rgb(${brightness}, ${brightness}, 200)`;
                    this.ctx.beginPath();
                    this.ctx.arc(windowX, windowY, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
        }
    }

    /**
     * Mode 53: Gravity Well
     */
    renderGravityWell(magnitudes) {
        if (!this.gravityWellParticles) this.gravityWellParticles = [];

        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);

        // Spawn particles
        if (this.frameCounter % 2 === 0) {
            for (let i = 0; i < treble * 20 + 5; i++) {
                const angle = Math.random() * Math.PI * 2;
                const edgeDist = Math.min(this.canvas.width, this.canvas.height) / 2;
                this.gravityWellParticles.push({
                    x: this.centerX + Math.cos(angle) * edgeDist,
                    y: this.centerY + Math.sin(angle) * edgeDist,
                    vx: 0,
                    vy: 0,
                    colorIndex: Math.floor(Math.random() * magnitudes.length)
                });
            }
        }

        // Black hole - use color scheme
        const wellRadius = 30 + bass * 50;
        const wellColorIndex = Math.floor(magnitudes.length / 2);
        this.ctx.fillStyle = this.getColor(wellColorIndex, magnitudes.length);
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, wellRadius, 0, Math.PI * 2);
        this.ctx.fill();

        // Update particles
        const shockwaveForce = bass > 0.6 ? bass * 500 : 0;

        this.gravityWellParticles = this.gravityWellParticles.filter(p => {
            const dx = this.centerX - p.x;
            const dy = this.centerY - p.y;
            const dist = Math.sqrt(dx * dx + dy * dy) + 1;

            // Gravity
            const pullForce = 200 / (dist * dist);
            p.vx += (dx / dist) * pullForce;
            p.vy += (dy / dist) * pullForce;

            // Shockwave
            if (shockwaveForce > 0 && dist < 200) {
                p.vx -= (dx / dist) * shockwaveForce;
                p.vy -= (dy / dist) * shockwaveForce;
            }

            p.x += p.vx;
            p.y += p.vy;

            if (dist > wellRadius && p.x >= 0 && p.x < this.canvas.width &&
                p.y >= 0 && p.y < this.canvas.height) {
                this.ctx.fillStyle = this.getColor(p.colorIndex, magnitudes.length);
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                this.ctx.fill();
                return true;
            }
            return false;
        }).slice(0, 500);
    }

    /**
     * Mode 54: Metaball Fluid
     */
    renderMetaballFluid(magnitudes) {
        if (!this.metaballs) this.metaballs = [];

        const numBalls = Math.min(magnitudes.length, 15);
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Initialize metaballs
        while (this.metaballs.length < numBalls) {
            this.metaballs.push({
                x: Math.random() * this.canvas.width,
                y: Math.random() * this.canvas.height,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                baseRadius: 40 + Math.random() * 40
            });
        }

        // Draw metaballs
        for (let i = 0; i < Math.min(numBalls, this.metaballs.length); i++) {
            const ball = this.metaballs[i];
            const magnitude = magnitudes[i] || avgMagnitude;
            const radius = ball.baseRadius * (0.7 + magnitude * 0.8);

            // Update position
            ball.x += ball.vx;
            ball.y += ball.vy;

            // Bounce
            if (ball.x < radius || ball.x > this.canvas.width - radius) ball.vx *= -1;
            if (ball.y < radius || ball.y > this.canvas.height - radius) ball.vy *= -1;

            // Color - use color scheme
            const colorStr = this.getColor(i, numBalls);
            const rgb = this.parseRgbColor(colorStr);

            // Draw with gradient
            for (let r = radius; r > 0; r -= 5) {
                const alpha = r / radius;
                this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${alpha * 0.6})`;
                this.ctx.beginPath();
                this.ctx.arc(ball.x, ball.y, r, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 55: Aurora Borealis
     */
    renderAuroraBorealis(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);

        const numCurtains = 5;
        const curtainPoints = 60;

        for (let curtainIdx = 0; curtainIdx < numCurtains; curtainIdx++) {
            const points = [];
            const baseYOffset = curtainIdx * 80 - 160;

            for (let i = 0; i < curtainPoints; i++) {
                const x = (i / curtainPoints) * this.canvas.width;
                const wave1 = Math.sin(i * 0.15 + this.frameCounter * 0.05 + curtainIdx) * bass * 60;
                const wave2 = Math.sin(i * 0.08 + this.frameCounter * 0.03) * bass * 40;
                const shimmer = Math.sin(i * 0.8 + this.frameCounter * 0.4) * treble * 20;
                const y = this.centerY + baseYOffset + wave1 + wave2 + shimmer;

                points.push({ x, y });
            }

            // Use color scheme for curtain
            const colorStr = this.getColor(curtainIdx, numCurtains);
            this.ctx.strokeStyle = colorStr;
            this.ctx.lineWidth = 3;
            this.ctx.shadowBlur = 15;
            this.ctx.shadowColor = this.ctx.strokeStyle;

            this.ctx.beginPath();
            this.ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                this.ctx.lineTo(points[i].x, points[i].y);
            }
            this.ctx.stroke();
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 56: Stained Glass
     */
    renderStainedGlass(magnitudes) {
        const rows = 6, cols = 10;
        const paneWidth = this.canvas.width / cols;
        const paneHeight = this.canvas.height / rows;

        let paneIdx = 0;
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (paneIdx >= magnitudes.length) break;

                const magnitude = magnitudes[paneIdx];
                const x1 = col * paneWidth + 2;
                const y1 = row * paneHeight + 2;
                const x2 = (col + 1) * paneWidth - 2;
                const y2 = (row + 1) * paneHeight - 2;

                // Use color scheme for glass pane
                const colorStr = this.getColor(paneIdx, magnitudes.length);
                this.ctx.fillStyle = colorStr;
                this.ctx.fillRect(x1, y1, x2 - x1, y2 - y1);

                if (magnitude > 0.5) {
                    this.ctx.shadowBlur = magnitude * 20;
                    this.ctx.shadowColor = colorStr;
                    this.ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
                    this.ctx.shadowBlur = 0;
                }

                paneIdx++;
            }
        }
    }

    /**
     * Mode 57: Neural Network
     */
    renderNeuralNetwork(magnitudes) {
        if (!this.nerveNodes || this.nerveNodes.length === 0) {
            this.nerveNodes = [];
            const numNodes = 20;
            for (let i = 0; i < numNodes; i++) {
                this.nerveNodes.push({
                    x: 100 + Math.random() * (this.canvas.width - 200),
                    y: 100 + Math.random() * (this.canvas.height - 200),
                    pulse: 0,
                    connections: []
                });
            }
            // Create connections
            this.nerveNodes.forEach((node, i) => {
                const numConnections = 2 + Math.floor(Math.random() * 3);
                for (let j = 0; j < numConnections; j++) {
                    const target = Math.floor(Math.random() * numNodes);
                    if (target !== i) node.connections.push(target);
                }
            });
        }

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);

        // Update pulses
        this.nerveNodes.forEach((node, i) => {
            if (i < magnitudes.length) node.pulse = magnitudes[i];
        });

        // Get color scheme
        const scheme = COLOR_SCHEMES[this.settings.colorScheme];
        const color1 = scheme.primary;
        const color2 = scheme.secondary;

        // Draw connections
        this.ctx.strokeStyle = `rgba(${color1[0]}, ${color1[1]}, ${color1[2]}, ${treble * 0.8})`;
        this.ctx.lineWidth = 2;
        this.nerveNodes.forEach(node => {
            node.connections.forEach(targetIdx => {
                const target = this.nerveNodes[targetIdx];
                if (treble > 0.5) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(node.x, node.y);
                    this.ctx.lineTo(target.x, target.y);
                    this.ctx.stroke();
                }
            });
        });

        // Draw nodes
        this.nerveNodes.forEach(node => {
            const radius = 10 + node.pulse * 25;
            this.ctx.fillStyle = `rgba(${color2[0]}, ${color2[1]}, ${color2[2]}, ${0.6 + node.pulse * 0.4})`;
            this.ctx.beginPath();
            this.ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
            this.ctx.fill();
        });
    }

    /**
     * Mode 58: Glitch Artifact
     */
    renderGlitchArtifact(magnitudes) {
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);

        // Get color scheme
        const scheme = COLOR_SCHEMES[this.settings.colorScheme];
        const color1 = scheme.primary;

        // Draw clean bars
        const barWidth = this.canvas.width / magnitudes.length;
        magnitudes.forEach((magnitude, i) => {
            const barHeight = magnitude * this.canvas.height * 0.7;
            const x = i * barWidth;
            const y = this.canvas.height - barHeight;

            this.ctx.fillStyle = `rgb(${color1[0]}, ${color1[1]}, ${color1[2]})`;
            this.ctx.fillRect(x, y, barWidth - 2, barHeight);
        });

        // Apply glitch on strong transients
        if (treble > 0.7) {
            const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
            const shift = Math.floor(treble * 20);

            // Simple chromatic aberration simulation
            for (let y = 0; y < this.canvas.height; y += 10) {
                const rowData = this.ctx.getImageData(0, y, this.canvas.width, 1);
                this.ctx.putImageData(rowData, shift, y);
            }
        }
    }

    /**
     * Mode 59: Warp Tunnel
     */
    renderWarpTunnel(magnitudes) {
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const numRings = 30;

        for (let i = 0; i < numRings; i++) {
            const depth = i / numRings;
            const scale = 1 - depth * 0.9;
            const freqIdx = Math.floor(depth * magnitudes.length);
            const magnitude = magnitudes[Math.min(freqIdx, magnitudes.length - 1)];
            const radius = this.maxRadius * scale * (0.5 + magnitude * 0.8);

            // Use color scheme for tunnel ring
            const colorIndex = Math.floor(depth * magnitudes.length);
            this.ctx.strokeStyle = this.getColor(colorIndex, magnitudes.length);
            this.ctx.lineWidth = 2 + magnitude * 8;

            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 60: Conway's Game of Life
     */
    renderConwayLife(magnitudes) {
        const gridSize = 40;
        const cellWidth = this.canvas.width / gridSize;
        const cellHeight = this.canvas.height / gridSize;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);

        if (!this.cellularAutomaton || this.cellularAutomaton.length === 0) {
            this.cellularAutomaton = [];
            for (let y = 0; y < gridSize; y++) {
                this.cellularAutomaton[y] = [];
                for (let x = 0; x < gridSize; x++) {
                    this.cellularAutomaton[y][x] = Math.random() > 0.5 ? 1 : 0;
                }
            }
        }

        if (this.frameCounter % 3 === 0) {
            const newGrid = this.cellularAutomaton.map(row => [...row]);

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    let neighbors = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dy === 0 && dx === 0) continue;
                            const ny = (y + dy + gridSize) % gridSize;
                            const nx = (x + dx + gridSize) % gridSize;
                            neighbors += this.cellularAutomaton[ny][nx];
                        }
                    }

                    if (this.cellularAutomaton[y][x] === 1) {
                        if (neighbors < 2 || neighbors > 3) newGrid[y][x] = 0;
                    } else {
                        if (neighbors === 3 || (bass > 0.6 && Math.random() < bass * 0.1)) {
                            newGrid[y][x] = 1;
                        }
                    }
                }
            }

            this.cellularAutomaton = newGrid;
        }

        // Get color scheme
        const scheme = COLOR_SCHEMES[this.settings.colorScheme];
        const color1 = scheme.primary;

        // Draw grid
        this.ctx.fillStyle = `rgb(${color1[0]}, ${color1[1]}, ${color1[2]})`;
        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                if (this.cellularAutomaton[y][x] === 1) {
                    this.ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth - 1, cellHeight - 1);
                }
            }
        }
    }

    /**
     * Mode 61: ASCII Art Bars
     */
    renderAsciiArt(magnitudes) {
        const chars = ['.', '-', '=', '+', '*', '#', '@'];
        const barWidth = this.canvas.width / magnitudes.length;

        // Get color scheme
        const scheme = COLOR_SCHEMES[this.settings.colorScheme];
        const color1 = scheme.primary;

        this.ctx.font = '20px monospace';
        this.ctx.textAlign = 'center';

        for (let i = 0; i < magnitudes.length; i++) {
            const magnitude = magnitudes[i];
            const barHeight = Math.floor(magnitude * 20);
            const charIdx = Math.min(Math.floor(magnitude * chars.length), chars.length - 1);
            const char = chars[charIdx];

            const x = i * barWidth + barWidth / 2;
            for (let row = 0; row < barHeight; row++) {
                const y = this.canvas.height - row * 30 - 30;
                if (y > 0) {
                    // Use color scheme with varying opacity based on magnitude
                    const alpha = 0.7 + magnitude * 0.3;
                    this.ctx.fillStyle = `rgba(${color1[0]}, ${color1[1]}, ${color1[2]}, ${alpha})`;
                    this.ctx.fillText(char, x, y);
                }
            }
        }
    }

    /**
     * Mode 62: Rippling Water
     */
    renderRipplingWater(magnitudes) {
        for (let i = 0; i < magnitudes.length; i++) {
            const magnitude = magnitudes[i];
            if (magnitude > 0.4) {
                const x = (i / magnitudes.length) * this.canvas.width;
                const y = this.canvas.height * 0.3;

                const rippleRadius = ((this.frameCounter % 60) * magnitude * 8);
                const alpha = 1.0 - (rippleRadius / 300);

                if (alpha > 0) {
                    this.ctx.strokeStyle = `rgba(100, 150, 255, ${alpha})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, rippleRadius, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
            }
        }
    }

    /**
     * Mode 63: Terrain Flyover
     */
    renderTerrainFlyover(magnitudes) {
        // Use Step 4 settings
        const numBars = this.settings.numBars || 72;

        const terrainWidth = Math.floor(50 * (numBars / 72)); // Scale with numBars
        const terrainDepth = 40;
        const scale = 15;
        const offsetX = this.canvas.width / 2;
        const offsetY = this.canvas.height - 150;

        // Initialize terrain history for scrolling effect
        if (!this.terrainHistory) {
            this.terrainHistory = [];
            this.terrainScroll = 0;
        }

        // Audio features
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Add current magnitude slice to history
        this.terrainHistory.push([...magnitudes]);
        if (this.terrainHistory.length > terrainDepth) {
            this.terrainHistory.shift();
        }

        // Continuous scrolling
        this.terrainScroll += 0.3 + avgMagnitude * 0.5;

        // Fade background for depth
        this.ctx.fillStyle = 'rgba(0, 0, 10, 0.3)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw wireframe terrain from history
        for (let z = 0; z < this.terrainHistory.length - 1; z++) {
            const depthFactor = 1 - z / terrainDepth;
            const currentRow = this.terrainHistory[z];
            const nextRow = this.terrainHistory[z + 1];

            // Get color from scheme based on depth
            const colorIndex = Math.floor(z / terrainDepth * numBars);
            const baseColor = this.getColor(colorIndex, numBars);
            const colorMatch = baseColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);

            for (let x = 0; x < terrainWidth - 1; x++) {
                const freqIdx = Math.floor((x / terrainWidth) * currentRow.length);
                const nextFreqIdx = Math.floor(((x + 1) / terrainWidth) * currentRow.length);

                const height1 = currentRow[Math.min(freqIdx, currentRow.length - 1)] * 150 * (0.5 + bass * 0.5);
                const height2 = currentRow[Math.min(nextFreqIdx, currentRow.length - 1)] * 150 * (0.5 + bass * 0.5);
                const height3 = nextRow[Math.min(freqIdx, nextRow.length - 1)] * 150 * (0.5 + bass * 0.5);

                const zPos = z * 8 - this.terrainScroll;

                const x1 = offsetX + (x - terrainWidth / 2) * scale;
                const y1 = offsetY - height1 + zPos;

                const x2 = offsetX + (x + 1 - terrainWidth / 2) * scale;
                const y2 = offsetY - height2 + zPos;

                const x3 = offsetX + (x - terrainWidth / 2) * scale;
                const y3 = offsetY - height3 + zPos + 8;

                // Apply color with depth fading
                if (colorMatch) {
                    const [_, r, g, b] = colorMatch;
                    const fadedR = Math.floor(parseInt(r) * depthFactor);
                    const fadedG = Math.floor(parseInt(g) * depthFactor);
                    const fadedB = Math.floor(parseInt(b) * depthFactor);
                    this.ctx.strokeStyle = `rgb(${fadedR}, ${fadedG}, ${fadedB})`;
                } else {
                    this.ctx.strokeStyle = `rgb(${100 * depthFactor}, ${200 * depthFactor}, ${100 * depthFactor})`;
                }

                // Line width based on depth (thicker in front)
                this.ctx.lineWidth = Math.max(0.5, depthFactor * 2);

                // Draw horizontal line
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x2, y2);
                this.ctx.stroke();

                // Draw vertical line
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x3, y3);
                this.ctx.stroke();

                // Add glow effect on peaks
                if (height1 > 100) {
                    if (colorMatch) {
                        const [_, r, g, b] = colorMatch;
                        const glowAlpha = (height1 / 150) * depthFactor * 0.5;
                        this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${glowAlpha})`;
                    } else {
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${(height1 / 150) * depthFactor * 0.3})`;
                    }
                    this.ctx.beginPath();
                    this.ctx.arc(x1, y1, 3 * depthFactor, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
        }

        // Reset scroll when it gets too far
        if (this.terrainScroll > 8) {
            this.terrainScroll -= 8;
        }

        // Draw horizon line for reference
        const horizonColor = this.getColor(Math.floor(numBars * 0.8), numBars);
        const horizonMatch = horizonColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (horizonMatch) {
            const [_, r, g, b] = horizonMatch;
            this.ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
        } else {
            this.ctx.strokeStyle = 'rgba(100, 150, 200, 0.3)';
        }
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        this.ctx.moveTo(0, offsetY);
        this.ctx.lineTo(this.canvas.width, offsetY);
        this.ctx.stroke();
    }

    /**
     * Mode 64: String Art
     */
    renderStringArt(magnitudes) {
        const numPoints = Math.min(magnitudes.length, 36);
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 2);
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);

        // Calculate points
        const points = [];
        for (let i = 0; i < numPoints; i++) {
            const angle = (i / numPoints) * Math.PI * 2;
            const radius = this.maxRadius * 0.8 * (1 + bass * 0.3);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            points.push({ x, y });
        }

        // Draw lines - use color scheme
        const numLines = mids * 50 + treble * 100;
        const lineColorIndex = Math.floor(magnitudes.length / 2);
        const lineColorStr = this.getColor(lineColorIndex, magnitudes.length);
        const rgb = this.parseRgbColor(lineColorStr);

        this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.3)`;
        this.ctx.lineWidth = 1;

        for (let i = 0; i < numLines; i++) {
            const idx1 = Math.floor(Math.random() * points.length);
            const idx2 = Math.floor(Math.random() * points.length);
            if (idx1 !== idx2) {
                this.ctx.beginPath();
                this.ctx.moveTo(points[idx1].x, points[idx1].y);
                this.ctx.lineTo(points[idx2].x, points[idx2].y);
                this.ctx.stroke();
            }
        }

        // Draw points - use color scheme
        const pointColorIndex = magnitudes.length - 1;
        this.ctx.fillStyle = this.getColor(pointColorIndex, magnitudes.length);
        points.forEach(point => {
            this.ctx.beginPath();
            this.ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        });
    }

    /**
     * Mode 65: Fire Embers
     */
    renderFireEmbers(magnitudes) {
        if (!this.emberParticles) this.emberParticles = [];

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 4);

        // Central fire
        const fireHeight = bass * 300 + 100;
        const fireWidth = 150;

        for (let i = 0; i < 20; i++) {
            const flameX = this.centerX + (Math.random() - 0.5) * fireWidth;
            const flameY = this.canvas.height - 100 - Math.random() * fireHeight;
            const flameSize = 20 + bass * 30;

            // Use color scheme for flames
            const flameColorIndex = Math.floor(Math.random() * magnitudes.length);
            this.ctx.fillStyle = this.getColor(flameColorIndex, magnitudes.length);
            this.ctx.beginPath();
            this.ctx.arc(flameX, flameY, flameSize, 0, Math.PI * 2);
            this.ctx.fill();
        }

        // Emit embers on treble
        if (treble > 0.5) {
            for (let i = 0; i < treble * 30; i++) {
                this.emberParticles.push({
                    x: this.centerX + (Math.random() - 0.5) * 100,
                    y: this.canvas.height - 150,
                    vx: (Math.random() - 0.5) * 8,
                    vy: -Math.random() * 15 - 5,
                    life: 1.0
                });
            }
        }

        // Update embers
        this.emberParticles = this.emberParticles.filter(ember => {
            ember.x += ember.vx;
            ember.y += ember.vy;
            ember.vy += 0.5; // Gravity
            ember.life -= 0.015;

            if (ember.life > 0 && ember.y < this.canvas.height) {
                const alpha = ember.life;
                const emberColorIndex = Math.floor(magnitudes.length * 0.75);
                const emberColorStr = this.getColor(emberColorIndex, magnitudes.length);
                const emberRgb = this.parseRgbColor(emberColorStr);
                this.ctx.fillStyle = `rgba(${emberRgb[0]}, ${emberRgb[1]}, ${emberRgb[2]}, ${alpha})`;
                this.ctx.beginPath();
                this.ctx.arc(ember.x, ember.y, 3, 0, Math.PI * 2);
                this.ctx.fill();
                return true;
            }
            return false;
        });
    }

    /**
     * Mode 66: Radial Kaleidoscope
     */
    renderRadialKaleidoscope(magnitudes) {
        const numSegments = 8;
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const segmentAngle = (Math.PI * 2) / numSegments;

        // Draw particles in mirrored segments
        for (let i = 0; i < Math.min(magnitudes.length, 30); i++) {
            const magnitude = magnitudes[i];
            if (magnitude > 0.2) {
                const angle = (i / 30) * segmentAngle;
                const distance = 100 + magnitude * 300;

                // Use color scheme for kaleidoscope particles
                const colorStr = this.getColor(i, magnitudes.length);
                const [r, g, b] = this.parseRgbColor(colorStr);

                // Draw in all mirrored segments
                for (let seg = 0; seg < numSegments; seg++) {
                    const segAngle = seg * segmentAngle + this.frameCounter * 0.02;
                    const rotX = this.centerX + Math.cos(angle + segAngle) * distance;
                    const rotY = this.centerY + Math.sin(angle + segAngle) * distance;

                    const size = 5 + magnitude * 15;
                    this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    this.ctx.beginPath();
                    this.ctx.arc(rotX, rotY, size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
        }
    }

    /**
     * Mode 68: Orbital System
     */
    renderOrbitalSystem(magnitudes) {
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);

        // Central sun pulses - use color scheme
        const sunRadius = 40 + avgMagnitude * 40;
        const sunColorIndex = Math.floor(magnitudes.length / 2);
        this.ctx.fillStyle = this.getColor(sunColorIndex, magnitudes.length);
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, sunRadius, 0, Math.PI * 2);
        this.ctx.fill();

        this.ctx.strokeStyle = this.getColor(sunColorIndex + 1, magnitudes.length);
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, sunRadius + 10, 0, Math.PI * 2);
        this.ctx.stroke();

        // Planets orbit
        const numPlanets = Math.min(mids.length, 6);
        for (let i = 0; i < numPlanets; i++) {
            const magnitude = i < mids.length ? mids[i] : 0;
            const orbitRadius = 120 + i * 70;
            const angle = this.frameCounter * 0.02 * (1 + i * 0.3);

            const planetX = this.centerX + Math.cos(angle) * orbitRadius;
            const planetY = this.centerY + Math.sin(angle) * orbitRadius;
            const planetSize = 10 + magnitude * 25;

            // Planet color - use color scheme
            this.ctx.fillStyle = this.getColor(i, numPlanets);
            this.ctx.beginPath();
            this.ctx.arc(planetX, planetY, planetSize, 0, Math.PI * 2);
            this.ctx.fill();

            // Moon orbits planet (treble)
            if (treble > 0.4) {
                const moonAngle = this.frameCounter * 0.1;
                const moonDistance = planetSize + 20;
                const moonX = planetX + Math.cos(moonAngle) * moonDistance;
                const moonY = planetY + Math.sin(moonAngle) * moonDistance;
                const moonSize = 3 + treble * 8;

                const moonColorIndex = magnitudes.length - 1;
                this.ctx.fillStyle = this.getColor(moonColorIndex, magnitudes.length);
                this.ctx.beginPath();
                this.ctx.arc(moonX, moonY, moonSize, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 69: Spectrum Cube
     */
    renderSpectrumCube(magnitudes) {
        if (!this.cubeRotation) this.cubeRotation = 0;
        this.cubeRotation += 0.02;

        // Use settings
        const circleCount = this.settings.circleCount || 50;
        const barCount = this.settings.barCount || 72;

        const cubeSize = 200;
        const angleX = this.cubeRotation;
        const angleY = this.cubeRotation * 0.7;

        // Cube vertices
        const vertices3D = [
            [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],
            [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]
        ];

        // Rotate and project
        const vertices2D = vertices3D.map(([vx, vy, vz]) => {
            // Rotate around Y
            let x = vx * Math.cos(angleY) - vz * Math.sin(angleY);
            let z = vx * Math.sin(angleY) + vz * Math.cos(angleY);

            // Rotate around X
            const y = vy * Math.cos(angleX) - z * Math.sin(angleX);
            z = vy * Math.sin(angleX) + z * Math.cos(angleX);

            // Project to 2D
            const scale = cubeSize / (3 + z);
            const x2d = this.centerX + x * scale;
            const y2d = this.centerY + y * scale;

            return [x2d, y2d];
        });

        // Draw cube edges with color scheme
        const edges = [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];

        edges.forEach(([start, end], idx) => {
            // Use color scheme for edges
            const edgeColor = this.getColor(idx, edges.length);
            this.ctx.strokeStyle = edgeColor;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.moveTo(vertices2D[start][0], vertices2D[start][1]);
            this.ctx.lineTo(vertices2D[end][0], vertices2D[end][1]);
            this.ctx.stroke();
        });

        // Draw bars on front face - number controlled by barCount
        const numBars = Math.max(3, Math.min(12, Math.floor(barCount / 6)));
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Calculate face bounds
        const faceLeft = vertices2D[0][0];
        const faceRight = vertices2D[1][0];
        const faceTop = vertices2D[0][1];
        const faceBottom = vertices2D[3][1];
        const faceWidth = faceRight - faceLeft;

        for (let i = 0; i < numBars; i++) {
            const magIdx = Math.floor((i / numBars) * magnitudes.length);
            const magnitude = magnitudes[magIdx] || 0;
            const barLength = 20 + magnitude * 60 * (circleCount / 50);

            // Position bars across the face
            const barX = faceLeft + (faceWidth * (i + 0.5) / numBars);
            const barY = (faceTop + faceBottom) / 2;

            // Use color scheme for bars
            const barColor = this.getColor(i, numBars);
            const match = barColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            let r = 255, g = 200, b = 100;
            if (match) {
                r = parseInt(match[1]);
                g = parseInt(match[2]);
                b = parseInt(match[3]);
            }

            // Brighten based on magnitude
            const brightnessFactor = 0.7 + magnitude * 0.5;
            r = Math.min(255, Math.floor(r * brightnessFactor));
            g = Math.min(255, Math.floor(g * brightnessFactor));
            b = Math.min(255, Math.floor(b * brightnessFactor));

            this.ctx.strokeStyle = `rgb(${r}, ${g}, ${b})`;
            this.ctx.lineWidth = 3;
            this.ctx.beginPath();
            this.ctx.moveTo(barX, barY);
            this.ctx.lineTo(barX, barY - barLength);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 70: Typographic Flow
     */
    renderTypographicFlow(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);

        // Use settings
        const circleCount = this.settings.circleCount || 50;
        const barCount = this.settings.barCount || 72;

        // Spawn rate controlled by barCount (lower barCount = slower spawning)
        const spawnInterval = Math.max(15, Math.min(60, Math.floor(90 - barCount)));

        // Initialize word particles
        if (!this.wordParticles) this.wordParticles = [];

        // Spawn new words
        if (this.frameCounter % spawnInterval === 0) {
            const words = ['MUSIC', 'FLOW', 'VIBE', 'SOUND', 'WAVE', 'PULSE', 'RHYTHM'];
            const word = words[Math.floor(Math.random() * words.length)];

            // Assign a color index to each word particle
            const colorIndex = this.wordParticles.length % 10;

            this.wordParticles.push({
                word: word,
                x: Math.random() * this.canvas.width,
                y: this.canvas.height + 50,
                vy: -2 - Math.random() * 2,
                life: 1.0,
                colorIndex: colorIndex
            });
        }

        // Max words controlled by circleCount
        const maxWords = Math.max(5, Math.min(20, Math.floor(circleCount / 2.5)));
        if (this.wordParticles.length > maxWords) {
            this.wordParticles = this.wordParticles.slice(-maxWords);
        }

        // Update and draw words
        this.wordParticles = this.wordParticles.filter(particle => {
            particle.y += particle.vy;
            particle.life -= 0.01;

            if (particle.life > 0 && particle.y > -100) {
                const size = 20 + bass * 40;
                const waviness = treble * 20;
                const offsetX = Math.sin(particle.y * 0.02 + this.frameCounter * 0.1) * waviness;

                // Get color from scheme
                const wordColor = this.getColor(particle.colorIndex, 10);
                const match = wordColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                let r = 100, g = 200, b = 255;
                if (match) {
                    r = parseInt(match[1]);
                    g = parseInt(match[2]);
                    b = parseInt(match[3]);
                }

                this.ctx.save();
                this.ctx.font = `${size}px Arial`;
                this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${particle.life})`;
                this.ctx.fillText(particle.word, particle.x + offsetX, particle.y);
                this.ctx.restore();

                return true;
            }
            return false;
        });
    }

    /**
     * Mode 71: Sonar Ping
     */
    renderSonarPing(magnitudes) {
        // Use Step 4 settings
        const numBars = this.settings.numBars || 72;

        // Audio features
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Initialize blip history for trail effects
        if (!this.sonarBlips) {
            this.sonarBlips = [];
            this.sweepTrail = [];
        }

        // Rotating sweep line (speed modulated by audio)
        const sweepSpeed = 0.04 + avgMagnitude * 0.03;
        const sweepAngle = (this.frameCounter * sweepSpeed) % (Math.PI * 2);
        const sweepEndX = this.centerX + Math.cos(sweepAngle) * this.maxRadius;
        const sweepEndY = this.centerY + Math.sin(sweepAngle) * this.maxRadius;

        // Fade background for trail effect
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Get colors from scheme
        const sweepColor = this.getColor(0, numBars);
        const gridColor = this.getColor(Math.floor(numBars * 0.3), numBars);

        // Draw concentric circles (radar grid) - number scales with numBars
        const numRings = Math.max(3, Math.min(8, Math.floor(5 * (numBars / 72))));

        const gridMatch = gridColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (gridMatch) {
            const [_, r, g, b] = gridMatch;
            this.ctx.strokeStyle = `rgba(${Math.floor(parseInt(r) * 0.5)}, ${Math.floor(parseInt(g) * 0.5)}, ${Math.floor(parseInt(b) * 0.5)}, 0.5)`;
        } else {
            this.ctx.strokeStyle = 'rgba(50, 100, 50, 0.5)';
        }

        this.ctx.lineWidth = 1;
        for (let ring = 1; ring <= numRings; ring++) {
            const radius = (this.maxRadius * ring) / numRings;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();

            // Pulsing rings on bass
            if (bass > 0.6) {
                const pulseAlpha = bass * 0.3;
                if (gridMatch) {
                    const [_, r, g, b] = gridMatch;
                    this.ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${pulseAlpha})`;
                } else {
                    this.ctx.strokeStyle = `rgba(100, 200, 100, ${pulseAlpha})`;
                }
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
                this.ctx.stroke();
            }
        }

        // Draw sweep trail (fading gradient)
        this.sweepTrail.push({ angle: sweepAngle, life: 1 });
        this.sweepTrail = this.sweepTrail.filter(trail => {
            trail.life -= 0.03;
            return trail.life > 0;
        });

        // Draw sweep trails
        const sweepMatch = sweepColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        for (const trail of this.sweepTrail) {
            const trailEndX = this.centerX + Math.cos(trail.angle) * this.maxRadius;
            const trailEndY = this.centerY + Math.sin(trail.angle) * this.maxRadius;

            if (sweepMatch) {
                const [_, r, g, b] = sweepMatch;
                this.ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${trail.life * 0.4})`;
            } else {
                this.ctx.strokeStyle = `rgba(100, 255, 100, ${trail.life * 0.4})`;
            }

            this.ctx.lineWidth = 1 + trail.life;
            this.ctx.beginPath();
            this.ctx.moveTo(this.centerX, this.centerY);
            this.ctx.lineTo(trailEndX, trailEndY);
            this.ctx.stroke();
        }

        // Draw main sweep line with glow
        if (sweepMatch) {
            const [_, r, g, b] = sweepMatch;
            // Glow
            this.ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.5)`;
            this.ctx.lineWidth = 6;
            this.ctx.beginPath();
            this.ctx.moveTo(this.centerX, this.centerY);
            this.ctx.lineTo(sweepEndX, sweepEndY);
            this.ctx.stroke();

            // Main line
            this.ctx.strokeStyle = `rgb(${r}, ${g}, ${b})`;
        } else {
            this.ctx.strokeStyle = 'rgba(100, 255, 100, 0.5)';
            this.ctx.lineWidth = 6;
            this.ctx.beginPath();
            this.ctx.moveTo(this.centerX, this.centerY);
            this.ctx.lineTo(sweepEndX, sweepEndY);
            this.ctx.stroke();

            this.ctx.strokeStyle = 'rgb(100, 255, 100)';
        }

        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(this.centerX, this.centerY);
        this.ctx.lineTo(sweepEndX, sweepEndY);
        this.ctx.stroke();

        // Frequency blips appear when sweep passes
        magnitudes.forEach((magnitude, i) => {
            if (magnitude > 0.4) {
                const distance = (i / magnitudes.length) * this.maxRadius;
                const targetAngle = (i / magnitudes.length) * Math.PI * 2;

                // Check if sweep is near this angle
                let angleDiff = Math.abs(sweepAngle - targetAngle);
                if (angleDiff > Math.PI) angleDiff = Math.PI * 2 - angleDiff;

                if (angleDiff < 0.3) { // Sweep detection window
                    const blipX = this.centerX + Math.cos(targetAngle) * distance;
                    const blipY = this.centerY + Math.sin(targetAngle) * distance;

                    // Add blip to persistent array
                    this.sonarBlips.push({
                        x: blipX,
                        y: blipY,
                        size: 3 + magnitude * 12,
                        life: 1,
                        colorIndex: i,
                        magnitude: magnitude
                    });
                }
            }
        });

        // Update and draw persistent blips
        this.sonarBlips = this.sonarBlips.filter(blip => {
            blip.life -= 0.015;

            if (blip.life > 0) {
                const blipColor = this.getColor(blip.colorIndex, magnitudes.length);
                const blipMatch = blipColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);

                // Outer glow
                if (blipMatch) {
                    const [_, r, g, b] = blipMatch;
                    this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${blip.life * 0.3})`;
                } else {
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${blip.life * 0.3})`;
                }
                this.ctx.beginPath();
                this.ctx.arc(blip.x, blip.y, blip.size * 2, 0, Math.PI * 2);
                this.ctx.fill();

                // Inner bright blip
                if (blipMatch) {
                    const [_, r, g, b] = blipMatch;
                    const brightness = Math.min(255, parseInt(r) + 100);
                    this.ctx.fillStyle = `rgba(${brightness}, ${Math.min(255, parseInt(g) + 100)}, ${Math.min(255, parseInt(b) + 100)}, ${blip.life})`;
                } else {
                    const brightness = 200 + blip.magnitude * 55;
                    this.ctx.fillStyle = `rgba(${brightness}, 255, ${brightness}, ${blip.life})`;
                }
                this.ctx.beginPath();
                this.ctx.arc(blip.x, blip.y, blip.size, 0, Math.PI * 2);
                this.ctx.fill();

                return true;
            }
            return false;
        });

        // Limit blip count
        if (this.sonarBlips.length > 200) {
            this.sonarBlips = this.sonarBlips.slice(-200);
        }

        // Draw center dot
        if (sweepMatch) {
            const [_, r, g, b] = sweepMatch;
            this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
        } else {
            this.ctx.fillStyle = 'rgb(100, 255, 100)';
        }
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, 5, 0, Math.PI * 2);
        this.ctx.fill();
    }

    /**
     * Mode 72: VU Meters
     */
    renderVUMeters(magnitudes) {
        // Split audio into Left/Right
        const leftMagnitude = magnitudes.slice(0, Math.floor(magnitudes.length / 2))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 2);
        const rightMagnitude = magnitudes.slice(Math.floor(magnitudes.length / 2))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 2);

        // Initialize needle positions
        if (!this.vuNeedlePositions) this.vuNeedlePositions = [-60, -60];

        // Smooth needle movement
        const targetLeft = -60 + leftMagnitude * 120;
        const targetRight = -60 + rightMagnitude * 120;

        this.vuNeedlePositions[0] += (targetLeft - this.vuNeedlePositions[0]) * 0.3;
        this.vuNeedlePositions[1] += (targetRight - this.vuNeedlePositions[1]) * 0.3;

        // Draw VU meters
        const meterWidth = 300;
        const meterHeight = 200;

        ['L', 'R'].forEach((label, idx) => {
            const centerX = this.canvas.width / 4 + idx * this.canvas.width / 2;
            const centerY = this.centerY;
            const needleAngle = this.vuNeedlePositions[idx];

            // Draw meter face
            this.ctx.fillStyle = 'rgb(50, 50, 50)';
            this.ctx.beginPath();
            this.ctx.ellipse(centerX, centerY, meterWidth / 2, meterHeight / 2, 0, Math.PI, 2 * Math.PI);
            this.ctx.fill();

            this.ctx.strokeStyle = 'rgb(200, 200, 200)';
            this.ctx.lineWidth = 3;
            this.ctx.beginPath();
            this.ctx.ellipse(centerX, centerY, meterWidth / 2, meterHeight / 2, 0, Math.PI, 2 * Math.PI);
            this.ctx.stroke();

            // Draw scale marks
            for (let angle = -60; angle <= 60; angle += 10) {
                const markAngleRad = (Math.PI - angle * Math.PI / 180);
                const startR = meterWidth / 2 - 20;
                const endR = meterWidth / 2 - 10;

                this.ctx.strokeStyle = 'rgb(200, 200, 200)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(centerX + Math.cos(markAngleRad) * startR,
                               centerY - Math.sin(markAngleRad) * startR);
                this.ctx.lineTo(centerX + Math.cos(markAngleRad) * endR,
                               centerY - Math.sin(markAngleRad) * endR);
                this.ctx.stroke();
            }

            // Draw needle
            const needleAngleRad = (Math.PI - needleAngle * Math.PI / 180);
            this.ctx.strokeStyle = 'rgb(255, 100, 100)';
            this.ctx.lineWidth = 4;
            this.ctx.beginPath();
            this.ctx.moveTo(centerX, centerY);
            this.ctx.lineTo(centerX + Math.cos(needleAngleRad) * (meterWidth / 2 - 30),
                           centerY - Math.sin(needleAngleRad) * (meterWidth / 2 - 30));
            this.ctx.stroke();

            this.ctx.fillStyle = 'rgb(150, 150, 150)';
            this.ctx.beginPath();
            this.ctx.arc(centerX, centerY, 10, 0, Math.PI * 2);
            this.ctx.fill();

            // Label
            this.ctx.fillStyle = 'rgb(200, 200, 200)';
            this.ctx.font = '32px Arial';
            this.ctx.fillText(label, centerX - 15, centerY + 80);
        });
    }

    /**
     * Mode 73: Lightning Cloud
     */
    renderLightningCloud(magnitudes) {
        // Use Step 4 settings
        const numBars = this.settings.numBars || 72;

        // Get parameters from settings with defaults (scaled by numBars)
        const cloudDensity = Math.floor((this.settings.lightning_cloudCloudDensity || 25) * (numBars / 72));
        const cloudSize = this.settings.lightning_cloudCloudSize || 50;
        const lightningFrequency = this.settings.lightning_cloudLightningFrequency || 0.5;
        const lightningSegments = this.settings.lightning_cloudLightningSegments || 8;
        const lightningWidth = this.settings.lightning_cloudLightningWidth || 6;
        const trailOpacity = this.settings.lightning_cloudTrailOpacity || 0.12;

        // Calculate audio features
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);

        // Apply trail effect for persistence
        this.ctx.fillStyle = `rgba(0, 0, 0, ${trailOpacity})`;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Cloud formation
        const cloudHeight = this.canvas.height * 0.15 + bass * (this.canvas.height * 0.1);
        const cloudBaseY = this.canvas.height * 0.15;

        // Get base cloud color from color scheme
        const cloudBaseColor = this.getColor(0, numBars);
        const cloudMatch = cloudBaseColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);

        // Draw cloud particles
        this.ctx.globalAlpha = 0.3 + bass * 0.2;
        for (let i = 0; i < cloudDensity; i++) {
            const cloudX = (i / cloudDensity) * this.canvas.width +
                          (Math.random() - 0.5) * (this.canvas.width / cloudDensity) * 2;
            const cloudY = cloudBaseY + Math.random() * cloudHeight * 0.5;
            const particleSize = cloudSize * (0.5 + bass * 0.5) * (0.8 + Math.random() * 0.4);

            // Use color scheme for cloud with darkening
            if (cloudMatch) {
                const [_, r, g, b] = cloudMatch;
                const darkR = Math.floor(parseInt(r) * 0.2 + bass * 30);
                const darkG = Math.floor(parseInt(g) * 0.2 + bass * 30);
                const darkB = Math.floor(parseInt(b) * 0.3 + bass * 50);
                this.ctx.fillStyle = `rgb(${darkR}, ${darkG}, ${darkB})`;
            } else {
                this.ctx.fillStyle = `rgb(${30 + bass * 30}, ${30 + bass * 30}, ${50 + bass * 50})`;
            }

            this.ctx.beginPath();
            this.ctx.arc(cloudX, cloudY, particleSize, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;

        // Get lightning color from color scheme
        const lightningColor = this.getColor(Math.floor(numBars * 0.7), numBars);
        const lightningMatch = lightningColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);

        // Lightning strikes on treble hits
        const threshold = 1 - lightningFrequency;
        if (treble > threshold) {
            const numStrikes = Math.floor(1 + (treble - threshold) * 2);

            for (let strike = 0; strike < numStrikes; strike++) {
                const startX = this.canvas.width * (0.3 + Math.random() * 0.4);
                const startY = cloudBaseY + cloudHeight * 0.5;

                let x = startX;
                let y = startY;
                const points = [[x, y]];

                // Create jagged lightning path
                const segments = Math.floor(lightningSegments * (0.7 + treble * 0.3));
                for (let i = 0; i < segments; i++) {
                    x += (Math.random() - 0.5) * (this.canvas.width * 0.08);
                    y += this.canvas.height / segments * (1 + Math.random() * 0.3);
                    points.push([x, y]);
                }

                // Draw lightning glow - use color scheme
                this.ctx.lineWidth = lightningWidth * 2;
                if (lightningMatch) {
                    const [_, r, g, b] = lightningMatch;
                    this.ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${0.4 + treble * 0.3})`;
                } else {
                    this.ctx.strokeStyle = `rgba(100, 100, 255, ${0.4 + treble * 0.3})`;
                }
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.beginPath();
                points.forEach((point, i) => {
                    if (i === 0) this.ctx.moveTo(point[0], point[1]);
                    else this.ctx.lineTo(point[0], point[1]);
                });
                this.ctx.stroke();

                // Draw bright lightning core - use brightened color scheme
                this.ctx.lineWidth = lightningWidth * 0.6;
                if (lightningMatch) {
                    const [_, r, g, b] = lightningMatch;
                    const brightR = Math.min(255, parseInt(r) + 55);
                    const brightG = Math.min(255, parseInt(g) + 55);
                    const brightB = Math.min(255, parseInt(b) + 55);
                    this.ctx.strokeStyle = `rgb(${brightR}, ${brightG}, ${brightB})`;
                } else {
                    const brightness = 200 + treble * 55;
                    this.ctx.strokeStyle = `rgb(${brightness}, ${brightness}, 255)`;
                }
                this.ctx.beginPath();
                points.forEach((point, i) => {
                    if (i === 0) this.ctx.moveTo(point[0], point[1]);
                    else this.ctx.lineTo(point[0], point[1]);
                });
                this.ctx.stroke();

                // Add small branches
                if (points.length > 2) {
                    for (let i = 1; i < points.length - 1; i++) {
                        if (Math.random() > 0.7) {
                            const [bx, by] = points[i];
                            const branchX = bx + (Math.random() - 0.5) * (this.canvas.width * 0.05);
                            const branchY = by + (this.canvas.height * 0.05);

                            this.ctx.lineWidth = lightningWidth * 0.3;
                            if (lightningMatch) {
                                const [_, r, g, b] = lightningMatch;
                                const brightR = Math.min(255, parseInt(r) + 55);
                                const brightG = Math.min(255, parseInt(g) + 55);
                                const brightB = Math.min(255, parseInt(b) + 55);
                                this.ctx.strokeStyle = `rgba(${brightR}, ${brightG}, ${brightB}, 0.6)`;
                            } else {
                                const brightness = 200 + treble * 55;
                                this.ctx.strokeStyle = `rgba(${brightness}, ${brightness}, 255, 0.6)`;
                            }
                            this.ctx.beginPath();
                            this.ctx.moveTo(bx, by);
                            this.ctx.lineTo(branchX, branchY);
                            this.ctx.stroke();
                        }
                    }
                }
            }
        }
    }

    /**
     * Mode 74: Bouncing Balls
     */
    renderBouncingBalls(magnitudes) {
        // Initialize balls
        if (!this.bouncingBalls) {
            this.bouncingBalls = [];
            for (let i = 0; i < Math.min(magnitudes.length, 30); i++) {
                this.bouncingBalls.push({
                    x: (i / 30) * this.canvas.width,
                    y: this.canvas.height - 50,
                    vy: 0,
                    colorIndex: i
                });
            }
        }

        const gravity = 0.8;

        // Update and draw balls
        this.bouncingBalls.forEach((ball, i) => {
            if (i >= magnitudes.length) return;

            const magnitude = magnitudes[i];

            // Bounce based on amplitude
            if (ball.y >= this.canvas.height - 50) {
                ball.vy = -magnitude * 30 - 5;
            }

            // Apply gravity
            ball.vy += gravity;
            ball.y += ball.vy;

            // Keep ball in bounds
            if (ball.y > this.canvas.height - 50) {
                ball.y = this.canvas.height - 50;
                ball.vy *= -0.7;
            }

            // Draw ball - use color scheme
            const ballSize = 10 + magnitude * 20;
            this.ctx.fillStyle = this.getColor(ball.colorIndex, magnitudes.length);
            this.ctx.beginPath();
            this.ctx.arc(ball.x, ball.y, ballSize, 0, Math.PI * 2);
            this.ctx.fill();
        });
    }

    /**
     * Mode 75: Liquid Ink
     */
    renderLiquidInk(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);

        // Initialize blooms
        if (!this.inkBlooms) this.inkBlooms = [];

        // Bass hits create large ink blooms
        if (bass > 0.4 && this.frameCounter % 15 === 0) {
            this.inkBlooms.push({
                x: Math.random() * (this.canvas.width - 400) + 200,
                y: 100,
                radius: 10,
                maxRadius: 150 + bass * 200,
                life: 1.0,
                colorIndex: Math.floor(Math.random() * magnitudes.length)
            });
        }

        // Treble creates small bright splatters
        if (treble > 0.5) {
            for (let i = 0; i < treble * 10; i++) {
                this.inkBlooms.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    radius: 5,
                    maxRadius: 20 + treble * 40,
                    life: 1.0,
                    colorIndex: Math.floor(Math.random() * magnitudes.length)
                });
            }
        }

        // Update and draw blooms
        this.inkBlooms = this.inkBlooms.filter(bloom => {
            bloom.radius += 2;
            bloom.life -= 0.01;

            if (bloom.life > 0 && bloom.radius < bloom.maxRadius) {
                // Use color scheme for bloom
                const bloomColorStr = this.getColor(bloom.colorIndex, magnitudes.length);
                const [r, g, b] = this.parseRgbColor(bloomColorStr);

                this.ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${bloom.life})`;
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(bloom.x, bloom.y, bloom.radius, 0, Math.PI * 2);
                this.ctx.stroke();

                return true;
            }
            return false;
        });

        // Limit blooms
        if (this.inkBlooms.length > 100) {
            this.inkBlooms = this.inkBlooms.slice(-100);
        }
    }

    renderStereoLandscape(magnitudes) {
        // Mode 76: 3D perspective - left channel left mountain, right channel right mountain
        const midpoint = Math.floor(magnitudes.length / 2);
        const leftMags = magnitudes.slice(0, midpoint);
        const rightMags = magnitudes.slice(midpoint);

        // Draw left landscape
        this.ctx.beginPath();
        this.ctx.moveTo(0, this.canvas.height);

        for (let i = 0; i < leftMags.length; i++) {
            const x = (i / leftMags.length) * (this.canvas.width / 2);
            const y = this.canvas.height - 100 - leftMags[i] * 300;
            this.ctx.lineTo(x, y);
        }

        this.ctx.lineTo(this.canvas.width / 2, this.canvas.height);
        this.ctx.lineTo(0, this.canvas.height);
        this.ctx.fillStyle = 'rgba(100, 150, 255, 0.7)';
        this.ctx.fill();

        // Left landscape outline
        this.ctx.beginPath();
        for (let i = 0; i < leftMags.length; i++) {
            const x = (i / leftMags.length) * (this.canvas.width / 2);
            const y = this.canvas.height - 100 - leftMags[i] * 300;
            if (i === 0) this.ctx.moveTo(x, y);
            else this.ctx.lineTo(x, y);
        }
        this.ctx.strokeStyle = 'rgba(150, 200, 255, 1)';
        this.ctx.lineWidth = 3;
        this.ctx.stroke();

        // Draw right landscape
        this.ctx.beginPath();
        this.ctx.moveTo(this.canvas.width / 2, this.canvas.height);

        for (let i = 0; i < rightMags.length; i++) {
            const x = this.canvas.width / 2 + (i / rightMags.length) * (this.canvas.width / 2);
            const y = this.canvas.height - 100 - rightMags[i] * 300;
            this.ctx.lineTo(x, y);
        }

        this.ctx.lineTo(this.canvas.width, this.canvas.height);
        this.ctx.lineTo(this.canvas.width / 2, this.canvas.height);
        this.ctx.fillStyle = 'rgba(255, 150, 100, 0.7)';
        this.ctx.fill();

        // Right landscape outline
        this.ctx.beginPath();
        for (let i = 0; i < rightMags.length; i++) {
            const x = this.canvas.width / 2 + (i / rightMags.length) * (this.canvas.width / 2);
            const y = this.canvas.height - 100 - rightMags[i] * 300;
            if (i === 0) this.ctx.moveTo(x, y);
            else this.ctx.lineTo(x, y);
        }
        this.ctx.strokeStyle = 'rgba(255, 200, 150, 1)';
        this.ctx.lineWidth = 3;
        this.ctx.stroke();
    }

    renderAILatentWalk(magnitudes) {
        // Mode 77: Abstract latent space visualization (simulated)
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);

        // Initialize latent state
        if (this.latentMorphState === undefined) this.latentMorphState = 0;
        this.latentMorphState += avgMagnitude * 0.1;

        const numShapes = 15;
        for (let i = 0; i < numShapes; i++) {
            // Position influenced by latent state
            const angle = (i / numShapes) * Math.PI * 2 + this.latentMorphState;
            const radius = 100 + Math.sin(this.latentMorphState + i) * 200;

            const x = this.canvas.width / 2 + Math.cos(angle) * radius;
            const y = this.canvas.height / 2 + Math.sin(angle) * radius;

            // Morphing size
            const size = 20 + bass * 40 + Math.sin(this.latentMorphState * 2 + i) * 20;

            // Dream-like colors - use color scheme
            const colorStr = this.getColor(i, numShapes);
            const [r, g, b] = this.parseRgbColor(colorStr);

            // Draw with glow effect
            this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.7)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    renderPixelStorm(magnitudes) {
        // Mode 78: Blizzard of 8-bit pixels - wind direction from stereo, speed from volume
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Stereo pan (L/R balance)
        const midpoint = Math.floor(magnitudes.length / 2);
        const leftPower = magnitudes.slice(0, midpoint).reduce((a, b) => a + b, 0) / midpoint;
        const rightPower = magnitudes.slice(midpoint).reduce((a, b) => a + b, 0) / (magnitudes.length - midpoint);
        const windDirection = (rightPower - leftPower) * 5;

        // Draw background with fade effect for trails
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Initialize pixel storm
        if (!this.pixelStorm) {
            this.pixelStorm = [];
            // Initially populate the entire screen with pixels
            const initialPixels = 200;
            for (let i = 0; i < initialPixels; i++) {
                this.pixelStorm.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    vx: windDirection + (Math.random() - 0.5) * 3,
                    vy: 3 + avgMagnitude * 5,
                    colorIndex: Math.floor(Math.random() * magnitudes.length),
                    life: Math.random()
                });
            }
        }

        // Spawn pixels from top
        if (this.frameCounter % 2 === 0) {
            const numPixels = Math.floor(avgMagnitude * 30 + 10);
            for (let i = 0; i < numPixels; i++) {
                // Dominant frequency determines color
                const dominantFreqIdx = magnitudes.indexOf(Math.max(...magnitudes));

                this.pixelStorm.push({
                    x: Math.random() * this.canvas.width,
                    y: 0,
                    vx: windDirection + (Math.random() - 0.5) * 3,
                    vy: 3 + avgMagnitude * 5,
                    colorIndex: dominantFreqIdx,
                    life: 1.0
                });
            }
        }

        // Update and draw pixels
        this.pixelStorm = this.pixelStorm.filter(pixel => {
            pixel.x += pixel.vx;
            pixel.y += pixel.vy;
            pixel.life -= 0.01;

            if (pixel.life > 0 && pixel.y < this.canvas.height) {
                const colorStr = this.getColor(pixel.colorIndex, magnitudes.length);
                const [r, g, b] = this.parseRgbColor(colorStr);

                // 8-bit pixel (small rectangle)
                this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                this.ctx.fillRect(Math.floor(pixel.x), Math.floor(pixel.y), 4, 4);

                return true;
            }
            return false;
        });

        // Limit particle count
        if (this.pixelStorm.length > 400) {
            this.pixelStorm = this.pixelStorm.slice(-400);
        }
    }

    renderGrowingVine(magnitudes) {
        // Mode 79: Vine grows across screen, sprouts leaves on beats
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Use Step 4 settings - numBars affects max vine length
        const numBars = this.settings.numBars || 72;
        const maxSegments = Math.floor(200 * (numBars / 72)); // ~200 segments at default 72 bars

        // Initialize vine
        if (!this.vineSegments) {
            this.vineSegments = [];
            this.vinePhase = 0; // For swaying animation
            this.fallingLeaves = []; // Leaves that fall off
        }

        this.vinePhase += 0.02 + avgMagnitude * 0.03; // Animation phase

        // Grow vine if not complete
        if (this.vineSegments.length < maxSegments) {
            if (this.vineSegments.length === 0) {
                this.vineSegments.push({
                    x: 100,
                    y: this.canvas.height - 100,
                    baseX: 100,
                    baseY: this.canvas.height - 100,
                    leaves: []
                });
            } else {
                const last = this.vineSegments[this.vineSegments.length - 1];
                // Vine meanders - more variation with audio
                const angleVariation = (Math.random() - 0.5) * Math.PI / 4 + avgMagnitude * 0.2;
                const angle = -Math.PI / 6 + angleVariation;
                const stepSize = 12 + bass * 8; // Grow faster with bass
                const newX = last.baseX + Math.cos(angle) * stepSize;
                const newY = last.baseY + Math.sin(angle) * stepSize;

                if (newX > 0 && newX < this.canvas.width && newY > 0 && newY < this.canvas.height) {
                    const newSegment = {
                        x: newX,
                        y: newY,
                        baseX: newX,
                        baseY: newY,
                        leaves: []
                    };
                    this.vineSegments.push(newSegment);

                    // Sprout leaf on beat
                    if (bass > 0.5) {
                        const leafSize = 10 + bass * 30;
                        newSegment.leaves.push({
                            offsetX: (Math.random() - 0.5) * 30,
                            offsetY: (Math.random() - 0.5) * 30,
                            size: leafSize,
                            colorIndex: this.vineSegments.length % numBars,
                            rotation: Math.random() * Math.PI * 2,
                            rotationSpeed: (Math.random() - 0.5) * 0.1,
                            wobblePhase: Math.random() * Math.PI * 2,
                            age: 0
                        });
                    }
                }
            }
        } else {
            // Vine is complete - restart from beginning for continuous growth
            if (Math.random() < 0.01) { // 1% chance per frame to restart
                this.vineSegments = [];
                this.fallingLeaves = [];
            }
        }

        // Apply swaying motion to vine segments
        const swayStrength = 15 + treble * 20; // Treble makes it sway more
        for (let i = 0; i < this.vineSegments.length; i++) {
            const seg = this.vineSegments[i];
            const segmentRatio = i / this.vineSegments.length;
            const swayAmount = Math.sin(this.vinePhase + segmentRatio * Math.PI) * swayStrength * segmentRatio;
            seg.x = seg.baseX + swayAmount;
            seg.y = seg.baseY + Math.cos(this.vinePhase * 0.5 + segmentRatio * Math.PI) * swayStrength * 0.3 * segmentRatio;
        }

        // Get vine color from color scheme (darker for stem)
        const vineBaseColor = this.getColor(0, numBars);
        const vineMatch = vineBaseColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);

        // Draw vine with varying thickness
        if (vineMatch) {
            const [_, r, g, b] = vineMatch;
            const darkR = Math.floor(parseInt(r) * 0.3);
            const darkG = Math.floor(parseInt(g) * 0.6);
            const darkB = Math.floor(parseInt(b) * 0.3);
            this.ctx.strokeStyle = `rgb(${darkR}, ${darkG}, ${darkB})`;
        } else {
            this.ctx.strokeStyle = 'rgb(50, 120, 50)';
        }

        for (let i = 0; i < this.vineSegments.length - 1; i++) {
            const seg = this.vineSegments[i];
            const nextSeg = this.vineSegments[i + 1];
            const thickness = 4 - (i / this.vineSegments.length) * 2; // Thinner at the tip
            this.ctx.lineWidth = Math.max(1, thickness + bass * 2);
            this.ctx.lineCap = 'round';
            this.ctx.beginPath();
            this.ctx.moveTo(seg.x, seg.y);
            this.ctx.lineTo(nextSeg.x, nextSeg.y);
            this.ctx.stroke();
        }

        // Update and draw leaves with animation
        for (let segIdx = 0; segIdx < this.vineSegments.length; segIdx++) {
            const seg = this.vineSegments[segIdx];
            const leavesToKeep = [];

            for (const leaf of seg.leaves) {
                leaf.age++;
                leaf.wobblePhase += 0.05 + treble * 0.1;
                leaf.rotation += leaf.rotationSpeed + avgMagnitude * 0.05;

                // Some leaves fall off when old
                if (leaf.age > 300 && Math.random() < 0.002) {
                    // Leaf falls - add to falling leaves
                    this.fallingLeaves.push({
                        x: seg.x + leaf.offsetX,
                        y: seg.y + leaf.offsetY,
                        size: leaf.size,
                        colorIndex: leaf.colorIndex,
                        rotation: leaf.rotation,
                        vx: (Math.random() - 0.5) * 2,
                        vy: 1,
                        rotationSpeed: (Math.random() - 0.5) * 0.2
                    });
                } else {
                    leavesToKeep.push(leaf);
                }

                // Wobble effect
                const wobbleX = Math.sin(leaf.wobblePhase) * 5 * (1 + avgMagnitude);
                const wobbleY = Math.cos(leaf.wobblePhase * 0.7) * 3 * (1 + avgMagnitude);
                const leafX = seg.x + leaf.offsetX + wobbleX;
                const leafY = seg.y + leaf.offsetY + wobbleY;

                // Use color scheme for leaves
                const leafColor = this.getColor(leaf.colorIndex || 0, numBars);
                const leafMatch = leafColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);

                if (leafMatch) {
                    const [_, r, g, b] = leafMatch;
                    const brightR = Math.min(255, Math.floor(parseInt(r) * 0.6 + 100));
                    const brightG = Math.min(255, Math.floor(parseInt(g) * 1.2 + 100));
                    const brightB = Math.min(255, Math.floor(parseInt(b) * 0.6 + 100));
                    this.ctx.fillStyle = `rgb(${brightR}, ${brightG}, ${brightB})`;
                } else {
                    this.ctx.fillStyle = 'rgb(100, 255, 100)';
                }

                // Draw leaf with rotation (ellipse for more organic look)
                this.ctx.save();
                this.ctx.translate(leafX, leafY);
                this.ctx.rotate(leaf.rotation);
                this.ctx.beginPath();
                this.ctx.ellipse(0, 0, leaf.size, leaf.size * 0.6, 0, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
            }

            seg.leaves = leavesToKeep;
        }

        // Update and draw falling leaves
        this.fallingLeaves = this.fallingLeaves.filter(leaf => {
            leaf.x += leaf.vx;
            leaf.y += leaf.vy;
            leaf.vy += 0.1; // Gravity
            leaf.vx *= 0.99; // Air resistance
            leaf.rotation += leaf.rotationSpeed;

            // Remove if off screen
            if (leaf.y > this.canvas.height + 50) return false;

            // Draw falling leaf
            const leafColor = this.getColor(leaf.colorIndex || 0, numBars);
            const leafMatch = leafColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);

            if (leafMatch) {
                const [_, r, g, b] = leafMatch;
                const brightR = Math.min(255, Math.floor(parseInt(r) * 0.6 + 100));
                const brightG = Math.min(255, Math.floor(parseInt(g) * 1.2 + 100));
                const brightB = Math.min(255, Math.floor(parseInt(b) * 0.6 + 100));
                this.ctx.fillStyle = `rgba(${brightR}, ${brightG}, ${brightB}, 0.7)`;
            } else {
                this.ctx.fillStyle = 'rgba(100, 255, 100, 0.7)';
            }

            this.ctx.save();
            this.ctx.translate(leaf.x, leaf.y);
            this.ctx.rotate(leaf.rotation);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, leaf.size, leaf.size * 0.6, 0, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.restore();

            return true;
        });
    }

    renderHauntedFaces(magnitudes) {
        // Mode 80: Ghostly faces fade in/out with mid-range (vocals), eyes glow on bass
        const midRange = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 2);
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);

        // Use Step 4 settings - numBars affects number of faces
        const numBars = this.settings.numBars || 72;
        const numFaces = Math.max(2, Math.min(5, Math.floor(3 * (numBars / 72)))); // 2-5 faces, ~3 at default

        // Face opacity controlled by mid-range (vocals)
        const faceAlpha = midRange;

        if (faceAlpha > 0.2) {
            // Get base face color from color scheme
            const faceBaseColor = this.getColor(0, numBars);
            const faceMatch = faceBaseColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);

            // Get eye color from color scheme
            const eyeBaseColor = this.getColor(Math.floor(numBars * 0.5), numBars);
            const eyeMatch = eyeBaseColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);

            // Draw ghostly faces
            for (let i = 0; i < numFaces; i++) {
                const faceX = ((i + 1) * this.canvas.width) / (numFaces + 1);
                const faceY = this.canvas.height / 3 + Math.sin(this.frameCounter * 0.05 + i) * 50;
                const faceSize = 80;

                const alpha = faceAlpha * 0.5;

                // Face circle - use color scheme
                if (faceMatch) {
                    const [_, r, g, b] = faceMatch;
                    // Lighten the color for ghostly appearance
                    const lightR = Math.min(255, parseInt(r) + 100);
                    const lightG = Math.min(255, parseInt(g) + 100);
                    const lightB = Math.min(255, parseInt(b) + 100);
                    this.ctx.fillStyle = `rgba(${lightR}, ${lightG}, ${lightB}, ${alpha})`;
                } else {
                    this.ctx.fillStyle = `rgba(200, 200, 220, ${alpha})`;
                }

                this.ctx.beginPath();
                this.ctx.arc(faceX, faceY, faceSize, 0, Math.PI * 2);
                this.ctx.fill();

                // Eyes (glow on bass) - use color scheme
                const eyeOffset = 25;

                if (eyeMatch) {
                    const [_, r, g, b] = eyeMatch;
                    const glowMultiplier = bass > 0.6 ? 1.5 : 0.7;
                    const eyeR = Math.min(255, Math.floor(parseInt(r) * glowMultiplier));
                    const eyeG = Math.min(255, Math.floor(parseInt(g) * glowMultiplier));
                    const eyeB = Math.min(255, Math.floor(parseInt(b) * glowMultiplier));
                    this.ctx.fillStyle = `rgb(${eyeR}, ${eyeG}, ${eyeB})`;
                } else {
                    const eyeGlow = bass > 0.6 ? 255 : 100;
                    this.ctx.fillStyle = `rgb(${eyeGlow}, ${eyeGlow}, 50)`;
                }

                // Left eye
                this.ctx.beginPath();
                this.ctx.arc(faceX - eyeOffset, faceY - 20, 12, 0, Math.PI * 2);
                this.ctx.fill();

                // Right eye
                this.ctx.beginPath();
                this.ctx.arc(faceX + eyeOffset, faceY - 20, 12, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    renderConnectingConstellations(magnitudes) {
        // Mode 81: Stars that connect when their frequencies pass threshold
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Use Step 4 settings - numBars affects number of stars
        const numStars = Math.floor((this.settings.numBars || 72) * 0.7); // ~50 stars at default 72 bars

        // Initialize stars - reinitialize if count changed
        if (!this.constellationStars || this.constellationStars.length !== numStars) {
            this.constellationStars = [];
            for (let i = 0; i < numStars; i++) {
                this.constellationStars.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    freqIdx: Math.floor(Math.random() * magnitudes.length),
                    shining: false,
                    baseSize: 2 + Math.random() * 3,
                    colorIndex: i // Store index for consistent coloring
                });
            }
        }

        // Clear with fade
        this.ctx.fillStyle = 'rgba(0, 0, 20, 0.2)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Update stars based on their frequency
        for (const star of this.constellationStars) {
            const magnitude = magnitudes[star.freqIdx];
            star.shining = magnitude > 0.5;

            const size = star.shining ? star.baseSize * (1 + magnitude) : star.baseSize;

            // Draw star - use color scheme
            const baseColor = this.getColor(star.colorIndex, numStars);
            const colorMatch = baseColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);

            if (colorMatch) {
                const [_, r, g, b] = colorMatch;
                const brightness = star.shining ? 1.0 : 0.4;
                this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${brightness})`;
            } else {
                // Fallback
                const brightness = star.shining ? 255 : 100;
                this.ctx.fillStyle = `rgb(${brightness}, ${brightness}, 255)`;
            }

            this.ctx.beginPath();
            this.ctx.arc(star.x, star.y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        // Connect nearby shining stars - use color scheme for connections
        const connectionColor = this.getColor(0, numStars);
        const colorMatch = connectionColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);

        if (colorMatch) {
            const [_, r, g, b] = colorMatch;
            this.ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.4)`;
        } else {
            this.ctx.strokeStyle = 'rgba(100, 100, 200, 0.4)';
        }

        this.ctx.lineWidth = 1;
        for (let i = 0; i < this.constellationStars.length; i++) {
            const star1 = this.constellationStars[i];
            if (!star1.shining) continue;

            for (let j = i + 1; j < this.constellationStars.length; j++) {
                const star2 = this.constellationStars[j];
                if (!star2.shining) continue;

                const dx = star2.x - star1.x;
                const dy = star2.y - star1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 200) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(star1.x, star1.y);
                    this.ctx.lineTo(star2.x, star2.y);
                    this.ctx.stroke();
                }
            }
        }
    }

    renderMatrixRain(magnitudes) {
        // Mode 82: Falling Matrix-style characters with audio-reactive speed
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Use settings
        const circleCount = this.settings.circleCount || 50;
        const barCount = this.settings.barCount || 72;

        // Number of columns controlled by barCount
        const numColumns = Math.max(10, Math.min(80, Math.floor(barCount * 0.8)));
        const columnSpacing = this.canvas.width / numColumns;

        // Initialize columns - reinitialize if count changed
        if (!this.matrixColumns || this.matrixColumns.length !== numColumns) {
            this.matrixColumns = [];
            for (let i = 0; i < numColumns; i++) {
                this.matrixColumns.push({
                    x: i * columnSpacing,
                    y: -Math.random() * this.canvas.height,
                    speed: 2 + Math.random() * 3,
                    colorIndex: i % 10
                });
            }
        }

        // Clear with fade for trail effect
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Trail length controlled by circleCount
        const trailLength = Math.max(10, Math.min(30, Math.floor(circleCount / 2.5)));

        // Update and draw columns
        this.ctx.font = '16px monospace';
        for (const column of this.matrixColumns) {
            // Speed modulated by volume
            column.y += column.speed * (1 + avgMagnitude);

            // Reset when off screen
            if (column.y > this.canvas.height + 200) {
                column.y = -100;
            }

            // Get column color from scheme
            const baseColor = this.getColor(column.colorIndex, 10);
            const match = baseColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            let r = 50, g = 255, b = 50;
            if (match) {
                r = parseInt(match[1]);
                g = parseInt(match[2]);
                b = parseInt(match[3]);
            }

            // Draw trail of characters
            for (let i = 0; i < trailLength; i++) {
                const charY = column.y - i * 16;
                if (charY < 0 || charY > this.canvas.height) continue;

                // Brightness fades towards tail, treble adds flash
                const fadeFactor = 1 - (i / trailLength);
                const trebleBrightness = treble * 0.5;
                const brightnessFactor = (0.6 + fadeFactor * 0.4 + trebleBrightness);

                const finalR = Math.max(0, Math.min(255, Math.floor(r * brightnessFactor)));
                const finalG = Math.max(0, Math.min(255, Math.floor(g * brightnessFactor)));
                const finalB = Math.max(0, Math.min(255, Math.floor(b * brightnessFactor)));

                const char = String.fromCharCode(33 + Math.floor(Math.random() * 94));

                this.ctx.fillStyle = `rgb(${finalR}, ${finalG}, ${finalB})`;
                this.ctx.fillText(char, column.x, charY);
            }
        }
    }

    renderVoxelWorld(magnitudes) {
        // Mode 83: 3D voxel grid with audio shockwave
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        this.ctx.fillStyle = 'rgb(10, 10, 30)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // 3D grid parameters
        const gridSize = 8;
        const voxelSize = 30;
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;

        // Shockwave radius from bass
        const shockwave = bass * 300;

        // Draw voxel grid with 3D perspective
        for (let x = 0; x < gridSize; x++) {
            for (let z = 0; z < gridSize; z++) {
                const worldX = (x - gridSize / 2) * voxelSize;
                const worldZ = (z - gridSize / 2) * voxelSize;

                // Distance from center for shockwave
                const dist = Math.sqrt(worldX * worldX + worldZ * worldZ);

                // Height based on frequency and distance from shockwave
                const freqIdx = Math.floor(((x + z * gridSize) / (gridSize * gridSize)) * magnitudes.length);
                const magnitude = magnitudes[freqIdx];
                const shockwaveEffect = Math.max(0, 1 - Math.abs(dist - shockwave) / 50);
                const height = (magnitude + shockwaveEffect) * 100;

                // 3D to 2D projection (simple isometric)
                const screenX = centerX + worldX - worldZ * 0.5;
                const screenY = centerY + worldZ * 0.5 - height;

                // Color based on height - use color scheme
                const colorIndex = Math.floor(((x + z * gridSize) / (gridSize * gridSize)) * magnitudes.length);
                this.ctx.fillStyle = this.getColor(colorIndex, magnitudes.length);
                this.ctx.beginPath();
                this.ctx.moveTo(screenX, screenY);
                this.ctx.lineTo(screenX + voxelSize / 2, screenY + voxelSize / 4);
                this.ctx.lineTo(screenX, screenY + voxelSize / 2);
                this.ctx.lineTo(screenX - voxelSize / 2, screenY + voxelSize / 4);
                this.ctx.closePath();
                this.ctx.fill();
            }
        }
    }

    renderDNAHelixRungs(magnitudes) {
        // Mode 84: DNA double helix with rungs lighting up per frequency
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Use Step 4 settings
        const numBars = this.settings.numBars || 72;

        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Initialize particles for rung lighting effects
        if (!this.dnaParticles) this.dnaParticles = [];
        if (!this.dnaPhase) this.dnaPhase = 0;

        this.dnaPhase += 0.015 + avgMagnitude * 0.02;

        const numRungs = Math.floor(40 * (numBars / 72)); // Scale with numBars
        const helixRadius = 80 + bass * 40; // Pulsing radius with bass
        const centerX = this.canvas.width / 2;

        // Get colors from scheme
        const color1 = this.getColor(0, numBars);
        const color2 = this.getColor(Math.floor(numBars / 2), numBars);

        for (let i = 0; i < numRungs; i++) {
            const t = (i / numRungs) * Math.PI * 4 + this.frameCounter * 0.02;
            const y = (i / numRungs) * this.canvas.height;

            // Add breathing motion to helix
            const breathe = Math.sin(this.dnaPhase + i * 0.1) * 10;
            const helixRadiusAnimated = helixRadius + breathe + avgMagnitude * 20;

            // Left strand
            const x1 = centerX + Math.cos(t) * helixRadiusAnimated;
            // Right strand
            const x2 = centerX + Math.cos(t + Math.PI) * helixRadiusAnimated;

            // Strand beads with pulsing size
            const beadSize = 6 + Math.sin(this.dnaPhase + i * 0.2) * 2 + avgMagnitude * 4;

            // Parse colors for strands
            const color1Match = color1.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            const color2Match = color2.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);

            // Left strand bead
            if (color1Match) {
                const [_, r, g, b] = color1Match;
                this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
            } else {
                this.ctx.fillStyle = 'rgba(100, 150, 255, 0.8)';
            }
            this.ctx.beginPath();
            this.ctx.arc(x1, y, beadSize, 0, Math.PI * 2);
            this.ctx.fill();

            // Add glow
            const glowSize = beadSize + 4;
            if (color1Match) {
                const [_, r, g, b] = color1Match;
                this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
            } else {
                this.ctx.fillStyle = 'rgba(100, 150, 255, 0.3)';
            }
            this.ctx.beginPath();
            this.ctx.arc(x1, y, glowSize, 0, Math.PI * 2);
            this.ctx.fill();

            // Right strand bead
            if (color2Match) {
                const [_, r, g, b] = color2Match;
                this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
            } else {
                this.ctx.fillStyle = 'rgba(255, 100, 150, 0.8)';
            }
            this.ctx.beginPath();
            this.ctx.arc(x2, y, beadSize, 0, Math.PI * 2);
            this.ctx.fill();

            // Add glow
            if (color2Match) {
                const [_, r, g, b] = color2Match;
                this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
            } else {
                this.ctx.fillStyle = 'rgba(255, 100, 150, 0.3)';
            }
            this.ctx.beginPath();
            this.ctx.arc(x2, y, glowSize, 0, Math.PI * 2);
            this.ctx.fill();

            // Rung connecting strands (lit by frequency)
            const freqIdx = Math.floor((i / numRungs) * magnitudes.length);
            const magnitude = magnitudes[freqIdx];

            if (magnitude > 0.3) {
                // Animated rung thickness
                const rungThickness = 2 + magnitude * 6;

                // Get rung color
                const rungColor = this.getColor(freqIdx, magnitudes.length);
                const rungMatch = rungColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);

                if (rungMatch) {
                    const [_, r, g, b] = rungMatch;
                    const brightness = Math.min(255, parseInt(r) + magnitude * 100);
                    this.ctx.strokeStyle = `rgba(${brightness}, ${Math.min(255, parseInt(g) + magnitude * 100)}, ${Math.min(255, parseInt(b) + magnitude * 100)}, ${magnitude})`;
                } else {
                    const brightness = magnitude * 255;
                    this.ctx.strokeStyle = `rgba(${brightness}, 255, ${brightness}, ${magnitude})`;
                }

                this.ctx.lineWidth = rungThickness;
                this.ctx.lineCap = 'round';
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y);
                this.ctx.lineTo(x2, y);
                this.ctx.stroke();

                // Emit particles when rung is very bright
                if (magnitude > 0.7 && Math.random() < 0.3) {
                    const midX = (x1 + x2) / 2;
                    this.dnaParticles.push({
                        x: midX,
                        y: y,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 1,
                        colorIndex: freqIdx,
                        size: 2 + magnitude * 3
                    });
                }
            }
        }

        // Update and draw particles
        this.dnaParticles = this.dnaParticles.filter(particle => {
            particle.x += particle.vx;
            particle.y += particle.vy;
            particle.life -= 0.02;
            particle.vx *= 0.98;
            particle.vy *= 0.98;

            if (particle.life > 0) {
                const particleColor = this.getColor(particle.colorIndex, magnitudes.length);
                const particleMatch = particleColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);

                if (particleMatch) {
                    const [_, r, g, b] = particleMatch;
                    this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${particle.life})`;
                } else {
                    this.ctx.fillStyle = `rgba(255, 255, 100, ${particle.life})`;
                }

                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                this.ctx.fill();

                return true;
            }
            return false;
        });
    }

    renderAudioReactiveShader(magnitudes) {
        // Mode 85: Procedural shader-like effect with audio modulation
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Pixel-based shader effect
        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        const data = imageData.data;

        const time = this.frameCounter * 0.01;
        const scale = 0.02 + avgMagnitude * 0.02;

        for (let y = 0; y < this.canvas.height; y += 2) {
            for (let x = 0; x < this.canvas.width; x += 2) {
                const idx = (y * this.canvas.width + x) * 4;

                // Normalized coordinates
                const nx = x / this.canvas.width - 0.5;
                const ny = y / this.canvas.height - 0.5;

                // Distance from center
                const dist = Math.sqrt(nx * nx + ny * ny);

                // Procedural pattern
                const wave1 = Math.sin(nx * 10 * scale + time + bass * 5) * 0.5 + 0.5;
                const wave2 = Math.cos(ny * 10 * scale + time + treble * 5) * 0.5 + 0.5;
                const pattern = wave1 * wave2;

                // Radial influence
                const radialEffect = 1 - dist;

                // Color based on pattern and audio
                const r = pattern * 255 * (1 + bass);
                const g = (1 - pattern) * 255 * avgMagnitude;
                const b = Math.sin(dist * 20 + time) * 127 + 128;

                data[idx] = Math.min(255, r * radialEffect);
                data[idx + 1] = Math.min(255, g * radialEffect);
                data[idx + 2] = Math.min(255, b * radialEffect * (1 + treble));
                data[idx + 3] = 255;
            }
        }

        this.ctx.putImageData(imageData, 0, 0);
    }

    renderSpirograph(magnitudes) {
        // Mode 86: Spirograph pattern - radii controlled by frequencies
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const mids = magnitudes.slice(Math.floor(magnitudes.length * 0.25), Math.floor(magnitudes.length * 0.75)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.5);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Clear with fade
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Spirograph parameters modulated by audio
        const R = 150 + bass * 100;  // Outer wheel radius
        const r = 50 + mids * 50;    // Inner wheel radius
        const d = 30 + treble * 40;  // Pen distance

        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;

        // Draw spirograph
        this.ctx.beginPath();
        let firstPoint = true;

        for (let t = 0; t < Math.PI * 10; t += 0.02) {
            const x = centerX + (R - r) * Math.cos(t) + d * Math.cos((R - r) / r * t);
            const y = centerY + (R - r) * Math.sin(t) - d * Math.sin((R - r) / r * t);

            if (x >= 0 && x < this.canvas.width && y >= 0 && y < this.canvas.height) {
                if (firstPoint) {
                    this.ctx.moveTo(x, y);
                    firstPoint = false;
                } else {
                    this.ctx.lineTo(x, y);
                }
            }
        }

        // Color based on treble - use color scheme
        const colorIndex = Math.floor(treble * magnitudes.length);
        this.ctx.strokeStyle = this.getColor(colorIndex, magnitudes.length);
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
    }

    renderEqualizerTower(magnitudes) {
        // Mode 87: 3D tower of stacked glowing rings
        this.ctx.fillStyle = 'rgb(0, 0, 0)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        const numRings = Math.min(magnitudes.length, 40);
        const ringHeight = this.canvas.height / numRings;
        const centerX = this.canvas.width / 2;

        for (let i = 0; i < numRings; i++) {
            const magnitude = magnitudes[i];
            const y = this.canvas.height - (i + 1) * ringHeight;
            const radius = magnitude * (this.canvas.width / 3);

            // Color gradient - use color scheme
            this.ctx.strokeStyle = this.getColor(i, numRings);

            // Ring thickness
            const thickness = 2 + magnitude * 10;
            this.ctx.lineWidth = thickness;
            this.ctx.beginPath();
            this.ctx.arc(centerX, y, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
    }

    renderAudioDrivenDoodles(magnitudes) {
        // Mode 88: Generative doodle bot - bass=90 turns, treble=shakiness
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const mids = magnitudes.slice(Math.floor(magnitudes.length * 0.25), Math.floor(magnitudes.length * 0.75)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.5);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Initialize path
        if (!this.doodlePath) {
            this.doodlePath = [{
                x: this.canvas.width / 2,
                y: this.canvas.height / 2,
                angle: 0
            }];
            this.doodleCounter = 0;
        }

        this.doodleCounter++;

        // Clear with fade
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Current position
        const current = this.doodlePath[this.doodlePath.length - 1];

        // Bass hit causes 90 turn
        if (bass > 0.6 && this.doodleCounter % 10 === 0) {
            current.angle += Math.PI / 2;
        }

        // Move forward
        const stepSize = 5 + mids * 5;
        const shakiness = treble * 10;
        let newX = current.x + Math.cos(current.angle) * stepSize + (Math.random() - 0.5) * shakiness;
        let newY = current.y + Math.sin(current.angle) * stepSize + (Math.random() - 0.5) * shakiness;

        // Keep in bounds
        newX = Math.max(50, Math.min(this.canvas.width - 50, newX));
        newY = Math.max(50, Math.min(this.canvas.height - 50, newY));

        this.doodlePath.push({ x: newX, y: newY, angle: current.angle });

        // Limit path length
        if (this.doodlePath.length > 500) {
            this.doodlePath = this.doodlePath.slice(-500);
        }

        // Draw path
        for (let i = 0; i < this.doodlePath.length - 1; i++) {
            const p1 = this.doodlePath[i];
            const p2 = this.doodlePath[i + 1];

            // Color based on mids - use color scheme
            const alpha = i / this.doodlePath.length;
            const colorIndex = Math.floor(i / this.doodlePath.length * magnitudes.length);
            const colorStr = this.getColor(colorIndex, magnitudes.length);
            const color = this.parseRgbColor(colorStr);

            this.ctx.strokeStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.lineWidth = 3;
            this.ctx.beginPath();
            this.ctx.moveTo(p1.x, p1.y);
            this.ctx.lineTo(p2.x, p2.y);
            this.ctx.stroke();
        }
    }

    renderFireworkShow(magnitudes) {
        // Mode 89: Bass launches rockets, they explode at peak with mid-range color
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const mids = magnitudes.slice(Math.floor(magnitudes.length * 0.25), Math.floor(magnitudes.length * 0.75)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.5);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Get parameters with defaults
        const bassThreshold = this.settings.fireworkShowBassThreshold || 0.3;
        const particleCount = this.settings.fireworkShowParticleCount || 150;
        const rocketSpeed = this.settings.fireworkShowRocketSpeed || 12;
        const particleSpeed = this.settings.fireworkShowParticleSpeed || 6;
        const particleSize = this.settings.fireworkShowParticleSize || 4;
        const trailLength = this.settings.fireworkShowTrailLength || 0.15;

        // Initialize rockets array
        if (!this.fireworkRockets) {
            this.fireworkRockets = [];
        }

        // Clear with fade (controlled by trailLength parameter)
        this.ctx.fillStyle = `rgba(0, 0, 10, ${trailLength})`;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Calculate average magnitude for general activity
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Launch rockets on bass hits OR periodically with any audio activity
        const shouldLaunchBass = bass > bassThreshold && this.frameCounter % 10 === 0;
        const shouldLaunchAny = avgMagnitude > 0.2 && this.frameCounter % 30 === 0;
        const shouldLaunchIdle = this.frameCounter % 60 === 0; // Always launch some even without audio

        if (shouldLaunchBass || shouldLaunchAny || shouldLaunchIdle) {
            // Store color index for this rocket so explosion uses consistent color
            const colorIndex = Math.floor(Math.random() * magnitudes.length);

            // Use bass for velocity if available, otherwise use avg magnitude
            const velocityMultiplier = bass > 0.1 ? bass : Math.max(avgMagnitude, 0.3);

            // Calculate target explosion position in the middle of the screen
            // Randomize around center with limited spread
            const spreadX = this.canvas.width * 0.2; // 20% spread horizontally
            const targetX = this.centerX + (Math.random() - 0.5) * spreadX;
            const targetY = this.centerY + (Math.random() - 0.5) * this.canvas.height * 0.3; // 30% spread vertically around center

            // Calculate initial velocity to reach target position
            const rocketX = Math.random() * (this.canvas.width / 2) + this.canvas.width / 4;
            const rocketY = this.canvas.height - 50;
            const baseSpeed = rocketSpeed + velocityMultiplier * 8;

            this.fireworkRockets.push({
                x: rocketX,
                y: rocketY,
                vy: -baseSpeed,
                targetY: targetY,
                targetX: targetX,
                exploded: false,
                particles: [],
                colorIndex: colorIndex
            });
        }

        // Update rockets
        const newRockets = [];
        for (const rocket of this.fireworkRockets) {
            if (!rocket.exploded) {
                rocket.y += rocket.vy;
                rocket.vy += 0.3;  // Gravity

                // Move horizontally towards target
                const dx = rocket.targetX - rocket.x;
                rocket.x += dx * 0.05;

                // Draw rocket trail (use the rocket's assigned color)
                const rocketColorStr = this.getColor(rocket.colorIndex, magnitudes.length);
                const rocketColor = this.parseRgbColor(rocketColorStr);
                this.ctx.fillStyle = `rgb(${rocketColor[0]}, ${rocketColor[1]}, ${rocketColor[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(rocket.x, rocket.y, 5, 0, Math.PI * 2);
                this.ctx.fill();

                // Explode at target position or when velocity becomes positive
                const reachedTarget = rocket.y <= rocket.targetY;
                const reachedPeak = rocket.vy > 0;

                if (reachedTarget || reachedPeak) {
                    rocket.exploded = true;
                    // Snap to target position for explosion
                    rocket.x = rocket.targetX;
                    rocket.y = rocket.targetY;

                    // Create particle burst (particle count controlled by parameter)
                    const numParticles = Math.floor(particleCount * (0.5 + mids * 0.5));
                    for (let i = 0; i < numParticles; i++) {
                        const angle = Math.random() * 2 * Math.PI;
                        const speed = particleSpeed * (0.5 + Math.random() * 0.5);

                        // Vary color slightly for each particle
                        const colorVariation = Math.floor((i / numParticles) * magnitudes.length);
                        const particleColorIndex = (rocket.colorIndex + colorVariation) % magnitudes.length;

                        rocket.particles.push({
                            x: rocket.x,
                            y: rocket.y,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            life: 1.0,
                            colorIndex: particleColorIndex
                        });
                    }
                }
            }

            // Update explosion particles
            if (rocket.exploded) {
                const newParticles = [];
                for (const particle of rocket.particles) {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.2;  // Gravity
                    particle.life -= 0.015;

                    if (particle.life > 0) {
                        // Use particle's stored color index for consistent coloring
                        const colorStr = this.getColor(particle.colorIndex, magnitudes.length);
                        const color = this.parseRgbColor(colorStr);

                        // Size controlled by parameter and audio reactivity
                        const size = particleSize * (0.5 + treble * 0.5) * particle.life;
                        this.ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${particle.life})`;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                        this.ctx.fill();

                        newParticles.push(particle);
                    }
                }

                rocket.particles = newParticles;
                if (rocket.particles.length > 0) {
                    newRockets.push(rocket);
                }
            } else {
                newRockets.push(rocket);
            }
        }

        this.fireworkRockets = newRockets.slice(0, 20);
    }

    renderMicroscopicView(magnitudes) {
        // Mode 90: Cells jiggle and divide based on frequency
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75)).reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Use Step 4 settings
        const numBars = this.settings.numBars || 72;

        // Initialize cells and animation state
        if (!this.microscopicCells) {
            this.microscopicCells = [];
            const initialCellCount = Math.floor(10 * (numBars / 72));
            for (let i = 0; i < initialCellCount; i++) {
                this.microscopicCells.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    radius: 30 + Math.random() * 30,
                    baseRadius: 30 + Math.random() * 30,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    freqIdx: i % magnitudes.length,
                    pulsePhase: Math.random() * Math.PI * 2,
                    wobblePhase: Math.random() * Math.PI * 2,
                    organelles: [] // Internal structures
                });

                // Add organelles (nuclei, mitochondria-like structures)
                const lastCell = this.microscopicCells[this.microscopicCells.length - 1];
                const numOrganelles = 2 + Math.floor(Math.random() * 3);
                for (let j = 0; j < numOrganelles; j++) {
                    lastCell.organelles.push({
                        angle: Math.random() * Math.PI * 2,
                        distance: Math.random() * lastCell.radius * 0.5,
                        size: 3 + Math.random() * 5,
                        rotationSpeed: (Math.random() - 0.5) * 0.05
                    });
                }
            }
            this.cellPhase = 0;
        }

        this.cellPhase += 0.02 + avgMagnitude * 0.03;

        // Clear with slight transparency for trails
        this.ctx.fillStyle = 'rgba(240, 240, 250, 0.9)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Update cells
        const newCells = [];
        const maxCells = Math.floor(50 * (numBars / 72));

        for (const cell of this.microscopicCells) {
            const freqIdx = cell.freqIdx % magnitudes.length;
            const magnitude = magnitudes[freqIdx];

            // Pulsing/breathing animation
            cell.pulsePhase += 0.05 + magnitude * 0.1;
            const pulseFactor = 1 + Math.sin(cell.pulsePhase) * 0.15 * (1 + magnitude);
            cell.radius = cell.baseRadius * pulseFactor;

            // Wobbling membrane
            cell.wobblePhase += 0.03 + treble * 0.05;

            // Jiggle (agitation from overall volume)
            const jiggleX = (Math.random() - 0.5) * avgMagnitude * 15;
            const jiggleY = (Math.random() - 0.5) * avgMagnitude * 15;

            // Organic movement (like swimming)
            const swimAngle = Math.atan2(cell.vy, cell.vx);
            const swimForce = 0.1 + magnitude * 0.2;
            cell.vx += Math.cos(swimAngle + Math.sin(this.cellPhase) * 0.5) * swimForce;
            cell.vy += Math.sin(swimAngle + Math.sin(this.cellPhase) * 0.5) * swimForce;

            // Damping for more fluid motion
            cell.vx *= 0.98;
            cell.vy *= 0.98;

            cell.x += cell.vx + jiggleX;
            cell.y += cell.vy + jiggleY;

            // Bounce off walls with damping
            if (cell.x < cell.radius || cell.x > this.canvas.width - cell.radius) {
                cell.vx *= -0.8;
                cell.x = Math.max(cell.radius, Math.min(this.canvas.width - cell.radius, cell.x));
            }
            if (cell.y < cell.radius || cell.y > this.canvas.height - cell.radius) {
                cell.vy *= -0.8;
                cell.y = Math.max(cell.radius, Math.min(this.canvas.height - cell.radius, cell.y));
            }

            // Divide when amplitude is high
            if (magnitude > 0.7 && newCells.length < maxCells && Math.random() < 0.03) {
                const angle = Math.random() * Math.PI * 2;
                const distance = cell.radius * 0.5;

                // Create daughter cell with inheritance
                const daughterCell = {
                    x: cell.x + Math.cos(angle) * distance,
                    y: cell.y + Math.sin(angle) * distance,
                    radius: cell.baseRadius * 0.6,
                    baseRadius: cell.baseRadius * 0.6,
                    vx: Math.cos(angle) * 2,
                    vy: Math.sin(angle) * 2,
                    freqIdx: freqIdx,
                    pulsePhase: Math.random() * Math.PI * 2,
                    wobblePhase: Math.random() * Math.PI * 2,
                    organelles: []
                };

                // Daughter gets organelles
                const numOrganelles = 1 + Math.floor(Math.random() * 2);
                for (let j = 0; j < numOrganelles; j++) {
                    daughterCell.organelles.push({
                        angle: Math.random() * Math.PI * 2,
                        distance: Math.random() * daughterCell.radius * 0.5,
                        size: 2 + Math.random() * 4,
                        rotationSpeed: (Math.random() - 0.5) * 0.05
                    });
                }

                newCells.push(daughterCell);
                cell.baseRadius *= 0.8; // Parent shrinks slightly
            }

            // Draw cell membrane with wobble
            const cellColor = this.getColor(freqIdx, magnitudes.length);
            this.ctx.fillStyle = cellColor;
            this.ctx.beginPath();

            // Draw wobbling membrane (not perfect circle)
            const numPoints = 20;
            for (let i = 0; i <= numPoints; i++) {
                const angle = (i / numPoints) * Math.PI * 2;
                const wobble = Math.sin(angle * 4 + cell.wobblePhase) * 3 * (1 + magnitude * 0.5);
                const r = cell.radius + wobble;
                const x = cell.x + Math.cos(angle) * r;
                const y = cell.y + Math.sin(angle) * r;

                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }
            this.ctx.closePath();
            this.ctx.fill();

            // Cell membrane outline
            const strokeColorIndex = (freqIdx + 1) % magnitudes.length;
            this.ctx.strokeStyle = this.getColor(strokeColorIndex, magnitudes.length);
            this.ctx.lineWidth = 2 + magnitude * 2;
            this.ctx.stroke();

            // Draw organelles (rotating internal structures)
            for (const organelle of cell.organelles) {
                organelle.angle += organelle.rotationSpeed + avgMagnitude * 0.02;

                const orgX = cell.x + Math.cos(organelle.angle) * organelle.distance;
                const orgY = cell.y + Math.sin(organelle.angle) * organelle.distance;

                // Organelle glow
                const orgGlow = this.ctx.createRadialGradient(orgX, orgY, 0, orgX, orgY, organelle.size * 2);
                const orgColor = this.getColor((freqIdx + 10) % magnitudes.length, magnitudes.length);
                const orgMatch = orgColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);

                if (orgMatch) {
                    const [_, r, g, b] = orgMatch;
                    orgGlow.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.8)`);
                    orgGlow.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0.1)`);
                } else {
                    orgGlow.addColorStop(0, 'rgba(255, 100, 100, 0.8)');
                    orgGlow.addColorStop(1, 'rgba(255, 100, 100, 0.1)');
                }

                this.ctx.fillStyle = orgGlow;
                this.ctx.beginPath();
                this.ctx.arc(orgX, orgY, organelle.size, 0, Math.PI * 2);
                this.ctx.fill();
            }

            newCells.push(cell);
        }

        this.microscopicCells = newCells.slice(0, maxCells);
    }

    /**
     * Mode 91: Burning Paper
     * Spectrum bars as flames, embers on high freq, paper curls on bass
     */
    renderBurningPaper(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Fade background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw flame bars
        const barWidth = this.canvas.width / magnitudes.length;
        for (let i = 0; i < magnitudes.length; i++) {
            const magnitude = magnitudes[i];
            const barHeight = magnitude * this.canvas.height * 0.7;
            const x = i * barWidth;
            const yBase = this.canvas.height - 50;

            // Flame effect (multiple layers)
            for (let layer = 0; layer < 3; layer++) {
                const yOffset = layer * 15;
                const layerHeight = barHeight - yOffset;
                if (layerHeight > 0) {
                    const y = yBase - layerHeight;

                    // Flame color gradient - use color scheme
                    const colorIndex = (i + layer) % magnitudes.length;
                    this.ctx.fillStyle = this.getColor(colorIndex, magnitudes.length);

                    // Flickering width
                    const flicker = Math.floor((Math.random() - 0.5) * 5);
                    this.ctx.fillRect(x + flicker, y, barWidth - 2, yBase - y);
                }
            }
        }

        // Embers on treble
        if (treble > 0.5) {
            for (let i = 0; i < treble * 20; i++) {
                const emberX = Math.random() * this.canvas.width;
                const emberY = this.canvas.height - 50 - Math.random() * 100;
                const emberColorIndex = Math.floor(Math.random() * magnitudes.length);
                this.ctx.fillStyle = this.getColor(emberColorIndex, magnitudes.length);
                this.ctx.beginPath();
                this.ctx.arc(emberX, emberY, 2, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        // Paper curl effect on bass (darken corners)
        if (bass > 0.4) {
            const curlAlpha = bass * 0.5;
            this.ctx.fillStyle = `rgba(10, 20, 20, ${curlAlpha})`;
            this.ctx.beginPath();
            this.ctx.moveTo(0, 0);
            this.ctx.lineTo(this.canvas.width * 0.2, 0);
            this.ctx.lineTo(0, this.canvas.height * 0.2);
            this.ctx.closePath();
            this.ctx.fill();
        }
    }

    /**
     * Mode 92: Swarm Intelligence
     * Boid flocking - cohesion/separation modulated by audio
     */
    renderSwarmIntelligence(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Use Step 4 settings - numBars affects number of boids
        const numBoids = Math.floor((this.settings.numBars || 72) * 0.55); // ~40 boids at default 72 bars

        // Initialize boids - reinitialize if count changed
        if (!this.swarmBoids || this.swarmBoids.length !== numBoids) {
            this.swarmBoids = [];
            for (let i = 0; i < numBoids; i++) {
                this.swarmBoids.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    colorIndex: i // Store index for consistent coloring
                });
            }
        }

        // Fade background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Boid rules modulated by audio
        const cohesionFactor = 0.01 * (1 - bass);  // Bass scatters
        const separationFactor = 0.5 + treble * 1.5;  // Treble aligns
        const alignmentFactor = 0.05 + treble * 0.1;

        for (let boid of this.swarmBoids) {
            // Calculate forces
            let cohesionX = 0, cohesionY = 0;
            let separationX = 0, separationY = 0;
            let alignmentVx = 0, alignmentVy = 0;
            let neighbors = 0;

            for (let other of this.swarmBoids) {
                if (other === boid) continue;

                const dx = other.x - boid.x;
                const dy = other.y - boid.y;
                const dist = Math.sqrt(dx * dx + dy * dy) + 0.1;

                if (dist < 100) {
                    // Cohesion
                    cohesionX += dx;
                    cohesionY += dy;

                    // Alignment
                    alignmentVx += other.vx;
                    alignmentVy += other.vy;

                    neighbors++;
                }

                if (dist < 30) {
                    // Separation
                    separationX -= dx / dist;
                    separationY -= dy / dist;
                }
            }

            if (neighbors > 0) {
                cohesionX /= neighbors;
                cohesionY /= neighbors;
                alignmentVx /= neighbors;
                alignmentVy /= neighbors;
            }

            // Apply forces
            boid.vx += cohesionX * cohesionFactor + separationX * separationFactor + alignmentVx * alignmentFactor;
            boid.vy += cohesionY * cohesionFactor + separationY * separationFactor + alignmentVy * alignmentFactor;

            // Limit speed
            const speed = Math.sqrt(boid.vx * boid.vx + boid.vy * boid.vy);
            const maxSpeed = 5 + treble * 5;
            if (speed > maxSpeed) {
                boid.vx = (boid.vx / speed) * maxSpeed;
                boid.vy = (boid.vy / speed) * maxSpeed;
            }

            // Update position
            boid.x += boid.vx;
            boid.y += boid.vy;

            // Wrap around
            boid.x = (boid.x + this.canvas.width) % this.canvas.width;
            boid.y = (boid.y + this.canvas.height) % this.canvas.height;

            // Draw boid - use color scheme
            const boidColor = this.getColor(boid.colorIndex, numBoids);
            this.ctx.fillStyle = boidColor;
            this.ctx.beginPath();
            this.ctx.arc(boid.x, boid.y, 5, 0, Math.PI * 2);
            this.ctx.fill();

            // Draw velocity direction - use slightly lighter version of boid color
            const colorMatch = boidColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            if (colorMatch) {
                const [_, r, g, b] = colorMatch;
                // Lighten the color for velocity line
                const lighterR = Math.min(255, parseInt(r) + 50);
                const lighterG = Math.min(255, parseInt(g) + 50);
                const lighterB = Math.min(255, parseInt(b) + 50);
                this.ctx.strokeStyle = `rgb(${lighterR}, ${lighterG}, ${lighterB})`;
            } else {
                this.ctx.strokeStyle = 'rgb(255, 220, 150)';
            }

            const endX = boid.x + boid.vx * 3;
            const endY = boid.y + boid.vy * 3;
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.moveTo(boid.x, boid.y);
            this.ctx.lineTo(endX, endY);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 93: Pendulum Wave
     * Multiple pendulums with slightly different periods - force from frequency
     */
    renderPendulumWave(magnitudes) {
        const numPendulums = Math.min(magnitudes.length, 30);

        // Initialize pendulum angles
        if (!this.pendulumAngles) {
            this.pendulumAngles = new Array(numPendulums).fill(0);
        }

        // Clear background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Update and draw pendulums
        for (let i = 0; i < numPendulums; i++) {
            const magnitude = i < magnitudes.length ? magnitudes[i] : 0;

            // Period slightly different for each pendulum
            const period = 0.05 + i * 0.001;

            // Force from audio
            this.pendulumAngles[i] += period + magnitude * 0.1;

            // Pendulum position
            const xBase = (i / numPendulums) * this.canvas.width;
            const yBase = 100;

            const pendulumLength = 200 + magnitude * 100;
            const xEnd = xBase + Math.sin(this.pendulumAngles[i]) * pendulumLength;
            const yEnd = yBase + pendulumLength;

            // Draw rod
            this.ctx.strokeStyle = 'rgb(150, 150, 150)';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.moveTo(xBase, yBase);
            this.ctx.lineTo(xEnd, yEnd);
            this.ctx.stroke();

            // Draw bob - use color scheme
            const bobSize = 5 + magnitude * 15;
            this.ctx.fillStyle = this.getColor(i, numPendulums);
            this.ctx.beginPath();
            this.ctx.arc(xEnd, yEnd, bobSize, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 94: Retro Scanlines
     * Waveform on old CRT with scanlines and static
     */
    renderRetroScanlines(magnitudes) {
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Initialize CRT flicker state
        if (this.crtFlicker === undefined) {
            this.crtFlicker = 0;
        }

        // CRT phosphor background - dark with slight green tint (classic monochrome CRT)
        this.ctx.fillStyle = 'rgba(5, 12, 8, 0.4)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw phosphor glow effect for waveform
        const waveformColor = 'rgb(0, 255, 100)'; // Bright phosphor green
        this.ctx.shadowBlur = 15 * this.scaleFactor;
        this.ctx.shadowColor = waveformColor;
        this.ctx.strokeStyle = waveformColor;
        this.ctx.lineWidth = 2 * this.scaleFactor;
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        this.ctx.beginPath();

        for (let i = 0; i < magnitudes.length; i++) {
            const x = (i / magnitudes.length) * this.canvas.width;
            const y = this.canvas.height / 2 + (magnitudes[i] - 0.5) * this.canvas.height * 0.6;

            if (i === 0) {
                this.ctx.moveTo(x, y);
            } else {
                this.ctx.lineTo(x, y);
            }
        }
        this.ctx.stroke();

        // Draw second pass with brighter core
        this.ctx.shadowBlur = 5 * this.scaleFactor;
        this.ctx.strokeStyle = 'rgb(200, 255, 220)';
        this.ctx.lineWidth = 1 * this.scaleFactor;
        this.ctx.beginPath();
        for (let i = 0; i < magnitudes.length; i++) {
            const x = (i / magnitudes.length) * this.canvas.width;
            const y = this.canvas.height / 2 + (magnitudes[i] - 0.5) * this.canvas.height * 0.6;
            if (i === 0) {
                this.ctx.moveTo(x, y);
            } else {
                this.ctx.lineTo(x, y);
            }
        }
        this.ctx.stroke();
        this.ctx.shadowBlur = 0;

        // Scanlines (horizontal)
        for (let y = 0; y < this.canvas.height; y += 3) {
            this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.canvas.width, y);
            this.ctx.stroke();
        }

        // Phosphor static/noise with green tint
        const noiseIntensity = Math.floor(20 + treble * 30);
        for (let i = 0; i < noiseIntensity; i++) {
            const x = Math.random() * this.canvas.width;
            const y = Math.random() * this.canvas.height;
            const brightness = Math.floor(Math.random() * 100) + 100;
            this.ctx.fillStyle = `rgba(0, ${brightness}, ${Math.floor(brightness * 0.6)}, 0.3)`;
            this.ctx.fillRect(x, y, 1, 1);
        }

        // CRT flicker with green tint
        this.crtFlicker = (this.crtFlicker + treble * 10) % 20;
        if (this.crtFlicker > 18) {
            this.ctx.fillStyle = 'rgba(0, 255, 100, 0.05)';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }

        // Vignette effect to simulate CRT curvature/edge darkening
        const gradient = this.ctx.createRadialGradient(
            this.canvas.width / 2, this.canvas.height / 2, 0,
            this.canvas.width / 2, this.canvas.height / 2, Math.max(this.canvas.width, this.canvas.height) * 0.7
        );
        gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0.6)');
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }

    /**
     * Mode 95: Pulsing Polygon
     * Central polygon with vertices pushed by frequency bands
     */
    renderPulsingPolygon(magnitudes) {
        const numVertices = Math.min(magnitudes.length, 12);

        // Fade background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Calculate vertex positions
        const vertices = [];
        for (let i = 0; i < numVertices; i++) {
            const angle = (i / numVertices) * 2 * Math.PI;
            const magnitude = i < magnitudes.length ? magnitudes[i] : 0;

            // Base radius and pushed radius
            const baseRadius = Math.min(this.canvas.width, this.canvas.height) * 0.25;
            const pushedRadius = baseRadius + magnitude * 200;

            const x = this.canvas.width / 2 + Math.cos(angle) * pushedRadius;
            const y = this.canvas.height / 2 + Math.sin(angle) * pushedRadius;
            vertices.push({ x, y });
        }

        // Draw filled polygon
        if (vertices.length > 2) {
            const avgMagnitude = magnitudes.slice(0, numVertices).reduce((a, b) => a + b, 0) / numVertices;

            // Use color scheme for polygon
            const colorIndex = Math.floor(avgMagnitude * magnitudes.length);
            this.ctx.fillStyle = this.getColor(colorIndex, magnitudes.length);
            this.ctx.beginPath();
            this.ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < vertices.length; i++) {
                this.ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            this.ctx.closePath();
            this.ctx.fill();

            // Draw outline - use color scheme
            const outlineColorIndex = (colorIndex + 1) % magnitudes.length;
            this.ctx.strokeStyle = this.getColor(outlineColorIndex, magnitudes.length);
            this.ctx.lineWidth = 3;
            this.ctx.stroke();
        }
    }

    /**
     * Mode 96: Chromatic Orb
     * 3D sphere with chromatic shader and moving light source
     */
    renderChromaticOrb(magnitudes) {
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Light source moves with stereo pan
        const left = magnitudes.slice(0, Math.floor(magnitudes.length / 2))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 2);
        const right = magnitudes.slice(Math.floor(magnitudes.length / 2))
            .reduce((a, b) => a + b, 0) / (magnitudes.length / 2);

        if (!this.chromaticOrbRotation) this.chromaticOrbRotation = 0;
        this.chromaticOrbRotation += (right - left) * 0.1;
        const lightAngle = this.chromaticOrbRotation;
        const lightX = Math.cos(lightAngle);
        const lightY = Math.sin(lightAngle);

        // Fade background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw orb
        const orbRadius = 150 + bass * 50;
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;

        for (let angleIdx = 0; angleIdx < 60; angleIdx++) {
            const angle = (angleIdx / 60) * Math.PI * 2;
            for (let radiusIdx = 0; radiusIdx < 20; radiusIdx++) {
                const radiusFactor = radiusIdx / 20;
                const radius = orbRadius * radiusFactor;

                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;

                // Lighting calculation
                const dot = Math.cos(angle) * lightX + Math.sin(angle) * lightY;
                const brightness = Math.max(0, dot) * 200 + 55;

                // Chromatic color - use color scheme
                const colorIndex = Math.floor(((angleIdx + radiusIdx) / 80) * magnitudes.length);
                this.ctx.fillStyle = this.getColor(colorIndex, magnitudes.length);
                this.ctx.beginPath();
                this.ctx.arc(x, y, 3, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 97: Textured Bars
     * Bars filled with scrolling animated texture
     */
    renderTexturedBars(magnitudes) {
        const barWidth = this.canvas.width / magnitudes.length;

        // Clear background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        for (let i = 0; i < magnitudes.length; i++) {
            const magnitude = magnitudes[i];
            const barHeight = magnitude * this.canvas.height * 0.7;
            const x = i * barWidth;
            const y = this.canvas.height - barHeight;

            // Scrolling texture (simulated with pattern)
            for (let ty = y; ty < this.canvas.height; ty += 5) {
                const scrollOffset = Math.floor((this.frameCounter * magnitude * 2) % 10);
                const patternY = (ty + scrollOffset) % 10;

                // Use color scheme for texture pattern
                const colorIndex = patternY < 5 ? i : (i + 1) % magnitudes.length;
                this.ctx.strokeStyle = this.getColor(colorIndex, magnitudes.length);

                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(x, ty);
                this.ctx.lineTo(x + barWidth - 2, ty);
                this.ctx.stroke();
            }
        }
    }

    /**
     * Mode 98: Voronoi Tessellation
     * Voronoi diagram with cells pulsing and seed points moving
     */
    renderVoronoiTessellation(magnitudes) {
        // Use settings - circleCount controls number of seeds
        const circleCount = this.settings.circleCount || 50;
        const barCount = this.settings.barCount || 72;

        // Number of seeds controlled by circleCount
        const numSeeds = Math.max(8, Math.min(30, Math.floor(circleCount / 2.5)));

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Initialize seed positions - reinitialize if count changed
        if (!this.voronoiSeeds || this.voronoiSeeds.length !== numSeeds) {
            this.voronoiSeeds = [];
            for (let i = 0; i < numSeeds; i++) {
                this.voronoiSeeds.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height
                });
            }
        }

        // Update seed positions
        for (let i = 0; i < numSeeds && i < this.voronoiSeeds.length; i++) {
            const seed = this.voronoiSeeds[i];
            const magnitude = i < magnitudes.length ? magnitudes[i] : 0;

            // Seeds move slightly
            seed.x += (Math.random() - 0.5) * bass * 5;
            seed.y += (Math.random() - 0.5) * bass * 5;

            // Keep in bounds
            seed.x = Math.max(0, Math.min(this.canvas.width, seed.x));
            seed.y = Math.max(0, Math.min(this.canvas.height, seed.y));
        }

        // Cell resolution controlled by barCount
        const cellSize = Math.max(3, Math.min(8, Math.floor(10 - barCount / 18)));

        // Draw Voronoi cells (simplified - sample points)
        for (let y = 0; y < this.canvas.height; y += cellSize) {
            for (let x = 0; x < this.canvas.width; x += cellSize) {
                // Find closest seed
                let minDist = Infinity;
                let closestIdx = 0;

                for (let i = 0; i < numSeeds && i < this.voronoiSeeds.length; i++) {
                    const seed = this.voronoiSeeds[i];
                    const dist = (x - seed.x) ** 2 + (y - seed.y) ** 2;
                    if (dist < minDist) {
                        minDist = dist;
                        closestIdx = i;
                    }
                }

                // Use color scheme instead of hard-coded HSV
                const baseColor = this.getColor(closestIdx, numSeeds);
                const match = baseColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                let r = 100, g = 100, b = 150;
                if (match) {
                    r = parseInt(match[1]);
                    g = parseInt(match[2]);
                    b = parseInt(match[3]);
                }

                // Adjust brightness based on magnitude
                const magnitude = closestIdx < magnitudes.length ? magnitudes[closestIdx] : 0;
                const brightnessFactor = 0.4 + magnitude * 0.6;
                r = Math.floor(r * brightnessFactor);
                g = Math.floor(g * brightnessFactor);
                b = Math.floor(b * brightnessFactor);

                this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                this.ctx.fillRect(x, y, cellSize, cellSize);
            }
        }

        // Draw seed points
        for (let i = 0; i < numSeeds && i < this.voronoiSeeds.length; i++) {
            const seed = this.voronoiSeeds[i];

            // Get seed color from scheme (use lighter version)
            const seedColor = this.getColor(i, numSeeds);
            const seedMatch = seedColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            let seedR = 255, seedG = 255, seedB = 255;
            if (seedMatch) {
                seedR = Math.min(255, parseInt(seedMatch[1]) + 100);
                seedG = Math.min(255, parseInt(seedMatch[2]) + 100);
                seedB = Math.min(255, parseInt(seedMatch[3]) + 100);
            }

            this.ctx.fillStyle = `rgb(${seedR}, ${seedG}, ${seedB})`;
            this.ctx.beginPath();
            this.ctx.arc(seed.x, seed.y, 6, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 99: Shattering Glass
     * Glass pane with cracks appearing on beats
     */
    renderShatteringGlass(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        if (!this.glassCracks) this.glassCracks = [];

        // Fade background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Glass pane (semi-transparent overlay)
        this.ctx.fillStyle = 'rgba(240, 220, 200, 0.3)';
        this.ctx.fillRect(100, 100, this.canvas.width - 200, this.canvas.height - 200);

        // Create cracks on strong beats
        if (bass > 0.65 && this.glassCracks.length < 50) {
            const crackCenter = {
                x: this.canvas.width / 2 + (Math.random() - 0.5) * 200,
                y: this.canvas.height / 2 + (Math.random() - 0.5) * 200
            };

            // Radiating crack lines
            const numLines = Math.floor(4 + bass * 8);
            for (let i = 0; i < numLines; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const length = 50 + bass * 150;

                const endX = crackCenter.x + Math.cos(angle) * length;
                const endY = crackCenter.y + Math.sin(angle) * length;

                this.glassCracks.push({
                    start: crackCenter,
                    end: { x: endX, y: endY },
                    complexity: treble
                });
            }
        }

        // Draw cracks
        for (const crack of this.glassCracks) {
            const thickness = 1 + crack.complexity * 3;
            this.ctx.strokeStyle = 'rgb(50, 50, 50)';
            this.ctx.lineWidth = thickness;
            this.ctx.beginPath();
            this.ctx.moveTo(crack.start.x, crack.start.y);
            this.ctx.lineTo(crack.end.x, crack.end.y);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 100: Sunrise Sunset
     * Gradient sky with pulsing sun and glittering stars
     */
    renderSunriseSunset(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const mids = magnitudes.slice(Math.floor(magnitudes.length * 0.25), Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.5);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Use settings
        const circleCount = this.settings.circleCount || 50;
        const barCount = this.settings.barCount || 72;

        // Sky gradient using color scheme
        for (let y = 0; y < this.canvas.height; y++) {
            const gradientFactor = y / this.canvas.height;

            // Get color from scheme
            const baseColor = this.getColor(y, this.canvas.height);
            const match = baseColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            let r = 100, g = 100, b = 150;
            if (match) {
                r = parseInt(match[1]);
                g = parseInt(match[2]);
                b = parseInt(match[3]);
            }

            // Apply gradient darkening based on vertical position and audio
            const darkenFactor = gradientFactor * (0.6 - mids * 0.3);
            r = Math.max(0, Math.floor(r * (1 - darkenFactor)));
            g = Math.max(0, Math.floor(g * (1 - darkenFactor)));
            b = Math.max(0, Math.floor(b * (1 - darkenFactor)));

            this.ctx.strokeStyle = `rgb(${r}, ${g}, ${b})`;
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.canvas.width, y);
            this.ctx.stroke();
        }

        // Sun/Moon (pulses with bass) - size affected by circleCount
        if (!this.sunPosition) this.sunPosition = this.canvas.height * 0.3;
        this.sunPosition = this.canvas.height * 0.3 + Math.sin(this.frameCounter * 0.02) * 50;
        const sunRadius = (40 + bass * 40) * (circleCount / 50);

        // Get sun color from scheme primary color
        const sunColorBase = this.getColor(0, 1);
        const sunMatch = sunColorBase.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        let sunR = 255, sunG = 200, sunB = 100;
        if (sunMatch) {
            sunR = parseInt(sunMatch[1]);
            sunG = parseInt(sunMatch[2]);
            sunB = parseInt(sunMatch[3]);
        }

        // Brighten the sun color based on bass
        const brightnessFactor = 1 + bass * 0.3;
        sunR = Math.min(255, Math.floor(sunR * brightnessFactor));
        sunG = Math.min(255, Math.floor(sunG * brightnessFactor));
        sunB = Math.min(255, Math.floor(sunB * brightnessFactor));

        const sunColor = `rgb(${sunR}, ${sunG}, ${sunB})`;
        this.ctx.fillStyle = sunColor;
        this.ctx.beginPath();
        this.ctx.arc(this.canvas.width / 2, this.sunPosition, sunRadius, 0, Math.PI * 2);
        this.ctx.fill();

        this.ctx.strokeStyle = sunColor;
        this.ctx.lineWidth = 3;
        this.ctx.globalAlpha = 0.7;
        this.ctx.beginPath();
        this.ctx.arc(this.canvas.width / 2, this.sunPosition, sunRadius + 10, 0, Math.PI * 2);
        this.ctx.stroke();
        this.ctx.globalAlpha = 1;

        // Stars glitter on treble - number controlled by circleCount and barCount
        if (mids < 0.3) {
            const baseStarCount = Math.floor((circleCount + barCount) / 2);
            const numStars = Math.floor(treble * baseStarCount + Math.floor(baseStarCount / 5));

            for (let i = 0; i < numStars; i++) {
                const starX = Math.random() * this.canvas.width;
                const starY = Math.random() * (this.canvas.height / 2);

                // Get star color from scheme (use secondary color)
                const starColorBase = this.getColor(1, 2);
                const starMatch = starColorBase.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                let starR = 200, starG = 200, starB = 200;
                if (starMatch) {
                    starR = parseInt(starMatch[1]);
                    starG = parseInt(starMatch[2]);
                    starB = parseInt(starMatch[3]);
                }

                // Brighten stars based on treble
                const starBrightness = 0.7 + treble * 0.3;
                starR = Math.min(255, Math.floor(starR * starBrightness + 100));
                starG = Math.min(255, Math.floor(starG * starBrightness + 100));
                starB = Math.min(255, Math.floor(starB * starBrightness + 100));

                this.ctx.fillStyle = `rgb(${starR}, ${starG}, ${starB})`;
                this.ctx.beginPath();
                this.ctx.arc(starX, starY, 2, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 101: Neural Pulse
     * Neural network with pulsing nodes and lighting connections
     */
    renderNeuralPulse(magnitudes) {
        // Get parameters from settings
        const nodeCount = this.settings.neuralPulseNodeCount || 30;
        const layerCount = this.settings.neuralPulseLayerCount || 3;
        const connectionThreshold = this.settings.neuralPulseConnectionThreshold || 50;
        const nodeSize = (this.settings.neuralPulseNodeSize || 8) * this.scaleFactor;
        const pulseIntensity = (this.settings.neuralPulsePulseIntensity || 20) * this.scaleFactor;
        const trailFade = this.settings.neuralPulseTrailFade || 0.1;
        const glowRadius = (this.settings.neuralPulseGlowRadius || 3) * this.scaleFactor;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const mids = magnitudes.slice(Math.floor(magnitudes.length * 0.25), Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.5);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Initialize neural network nodes (reinitialize if parameters changed)
        if (!this.neuralNodes || this.neuralNodes.length !== nodeCount || this.lastLayerCount !== layerCount) {
            this.neuralNodes = [];
            this.lastLayerCount = layerCount;
            for (let i = 0; i < nodeCount; i++) {
                this.neuralNodes.push({
                    x: 100 * this.scaleFactor + Math.random() * (this.canvas.width - 200 * this.scaleFactor),
                    y: 100 * this.scaleFactor + Math.random() * (this.canvas.height - 200 * this.scaleFactor),
                    layer: i % layerCount,
                    active: 0
                });
            }
        }

        // Fade background with configurable trail
        this.ctx.fillStyle = `rgba(0, 0, 0, ${trailFade})`;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Update node activation based on frequency bands
        for (const node of this.neuralNodes) {
            const layerIndex = node.layer % 3;
            if (layerIndex === 0) node.active = bass;
            else if (layerIndex === 1) node.active = mids;
            else node.active = treble;
        }

        // Draw connections that flash with amplitude
        for (let i = 0; i < this.neuralNodes.length; i++) {
            const node1 = this.neuralNodes[i];
            for (let j = i + 1; j < this.neuralNodes.length; j++) {
                const node2 = this.neuralNodes[j];
                if (Math.abs(node1.layer - node2.layer) === 1) {
                    const intensity = (node1.active + node2.active) * 127.5;
                    if (intensity > connectionThreshold) {
                        const thickness = intensity < 150 ? 1 : 2;
                        this.ctx.strokeStyle = `rgb(${intensity}, ${intensity * 0.5}, ${intensity + 50})`;
                        this.ctx.lineWidth = thickness * this.scaleFactor;
                        this.ctx.beginPath();
                        this.ctx.moveTo(node1.x, node1.y);
                        this.ctx.lineTo(node2.x, node2.y);
                        this.ctx.stroke();
                    }
                }
            }
        }

        // Draw pulsing nodes
        for (const node of this.neuralNodes) {
            const radius = nodeSize + node.active * pulseIntensity;
            const hue = 140 + node.layer * (180 / layerCount);
            const intensity = 200 + node.active * 55;
            const color = this.hsvToRgb(hue, 100, intensity / 255 * 100);

            this.ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
            this.ctx.beginPath();
            this.ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
            this.ctx.fill();

            this.ctx.strokeStyle = 'rgb(255, 255, 255)';
            this.ctx.lineWidth = 1 * this.scaleFactor;
            this.ctx.beginPath();
            this.ctx.arc(node.x, node.y, radius + glowRadius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 102: Liquid Mercury
     * Metallic liquid that ripples with physics
     */
    renderLiquidMercury(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const mids = magnitudes.slice(Math.floor(magnitudes.length * 0.25), Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.5);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        if (!this.liquidMercuryParticles) this.liquidMercuryParticles = [];

        // Fade background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Get color scheme
        const scheme = COLOR_SCHEMES[this.settings.colorScheme];
        const color1 = scheme.primary;
        const color2 = scheme.secondary;

        // Spawn mercury droplets on high treble
        if (treble > 0.5 && this.frameCounter % 3 === 0) {
            this.liquidMercuryParticles.push({
                x: 100 + Math.random() * (this.canvas.width - 200),
                y: 100,
                vx: (Math.random() - 0.5) * 4,
                vy: 0,
                radius: 10 + treble * 20
            });
        }

        // Update and draw mercury particles
        const newParticles = [];
        for (const particle of this.liquidMercuryParticles) {
            particle.vy += 0.5;  // Gravity
            particle.y += particle.vy;
            particle.x += particle.vx;

            // Boundary bouncing
            if (particle.y > this.canvas.height - 100) {
                particle.vy *= -0.7;
                particle.y = this.canvas.height - 100;
            }

            if (particle.x < 50 || particle.x > this.canvas.width - 50) {
                particle.vx *= -0.7;
            }

            if (particle.y < this.canvas.height) {
                // Draw with color scheme
                this.ctx.fillStyle = `rgb(${color1[0]}, ${color1[1]}, ${color1[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                this.ctx.fill();

                // Highlight with lighter version of secondary color
                this.ctx.fillStyle = `rgb(${Math.min(255, color2[0] + 55)}, ${Math.min(255, color2[1] + 55)}, ${Math.min(255, color2[2] + 55)})`;
                this.ctx.beginPath();
                this.ctx.arc(particle.x - 5, particle.y - 5, particle.radius / 3, 0, Math.PI * 2);
                this.ctx.fill();

                newParticles.push(particle);
            }
        }
        this.liquidMercuryParticles = newParticles;

        // Mid-range creates surface ripples
        for (let i = 0; i < mids * 5; i++) {
            const rippleX = this.canvas.width / 2 + Math.sin(this.frameCounter * 0.1 + i) * 200;
            const rippleY = this.canvas.height - 100;
            const rippleRadius = 30 + i * 20 + mids * 30;
            const midColor = `rgb(${Math.round((color1[0] + color2[0]) / 2)}, ${Math.round((color1[1] + color2[1]) / 2)}, ${Math.round((color1[2] + color2[2]) / 2)})`;
            this.ctx.strokeStyle = midColor;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(rippleX, rippleY, rippleRadius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 103: Cosmic Strings
     * Vibrating strings in space like guitar strings
     */
    renderCosmicStrings(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Use settings - barCount controls number of strings
        const barCount = this.settings.barCount || 72;
        const circleCount = this.settings.circleCount || 50;
        const numStrings = Math.max(6, Math.min(24, Math.floor(barCount / 6)));

        // Initialize strings - reinitialize if count changed
        if (!this.cosmicStrings || this.cosmicStrings.length !== numStrings) {
            this.cosmicStrings = [];
            for (let i = 0; i < numStrings; i++) {
                this.cosmicStrings.push({
                    y: 100 + i * (this.canvas.height - 200) / numStrings,
                    frequency: i + 1,
                    magnitude: 0
                });
            }
        }

        // Fade background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Update and draw vibrating strings
        for (let i = 0; i < this.cosmicStrings.length; i++) {
            const string = this.cosmicStrings[i];
            string.magnitude = magnitudes[Math.min(i * 10, magnitudes.length - 1)];

            // Amplitude affected by circleCount
            const amplitude = string.magnitude * 80 * (circleCount / 50);

            // Use color scheme instead of hard-coded gold
            const baseColor = this.getColor(i, numStrings);
            const match = baseColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            let r = 255, g = 200, b = 100;
            if (match) {
                r = parseInt(match[1]);
                g = parseInt(match[2]);
                b = parseInt(match[3]);
            }

            // Brighten based on magnitude
            const brightnessFactor = 0.8 + string.magnitude * 0.4;
            r = Math.min(255, Math.floor(r * brightnessFactor));
            g = Math.min(255, Math.floor(g * brightnessFactor));
            b = Math.min(255, Math.floor(b * brightnessFactor));

            this.ctx.strokeStyle = `rgb(${r}, ${g}, ${b})`;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();

            for (let x = 0; x < this.canvas.width; x += 10) {
                const wave = Math.sin(x * 0.02 * string.frequency + this.frameCounter * 0.1);
                const y = string.y + wave * amplitude;

                if (x === 0) this.ctx.moveTo(x, y);
                else this.ctx.lineTo(x, y);
            }
            this.ctx.stroke();

            // Add glow using lighter version of the color
            const glowR = Math.min(255, r + 50);
            const glowG = Math.min(255, g + 50);
            const glowB = Math.min(255, b + 50);
            this.ctx.strokeStyle = `rgb(${glowR}, ${glowG}, ${glowB})`;
            this.ctx.lineWidth = 1;
            this.ctx.stroke();
        }
    }

    /**
     * Mode 104: Particle Swarm
     * Thousands of particles forming shapes
     */
    renderParticleSwarm(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const mids = magnitudes.slice(Math.floor(magnitudes.length * 0.25), Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.5);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);

        // Get parameters with defaults
        const particleCount = this.settings.particleSwarmParticleCount || 1000;
        const spawnRate = this.settings.particleSwarmSpawnRate || 10;
        const formationRadius = (this.settings.particleSwarmFormationRadius || 150) * this.scaleFactor;
        const movementSpeed = this.settings.particleSwarmMovementSpeed || 0.05;
        const trailLength = this.settings.particleSwarmTrailLength || 5;
        const particleSize = (this.settings.particleSwarmParticleSize || 2) * this.scaleFactor;
        const trailOpacity = this.settings.particleSwarmTrailOpacity || 0.05;

        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;

        // Initialize particle array - spawn all particles immediately for instant preview
        if (!this.particleSwarmArray) {
            this.particleSwarmArray = [];
            // Spawn all particles at once for immediate visibility in preview
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const distance = Math.random() * formationRadius * 1.5;
                this.particleSwarmArray.push({
                    x: centerX + Math.cos(angle) * distance,
                    y: centerY + Math.sin(angle) * distance,
                    vx: 0,
                    vy: 0,
                    trail: [],
                    colorIndex: Math.floor(Math.random() * magnitudes.length)
                });
            }
        }

        // Fade background (controlled by trailOpacity parameter)
        this.ctx.fillStyle = `rgba(0, 0, 0, ${trailOpacity})`;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Spawn additional particles gradually if count increased (controlled by particleCount and spawnRate parameters)
        if (this.particleSwarmArray.length < particleCount) {
            for (let i = 0; i < spawnRate; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const distance = Math.random() * formationRadius * 1.5;
                this.particleSwarmArray.push({
                    x: centerX + Math.cos(angle) * distance,
                    y: centerY + Math.sin(angle) * distance,
                    vx: 0,
                    vy: 0,
                    trail: [],
                    colorIndex: Math.floor(Math.random() * magnitudes.length)
                });
            }
        }

        // Calculate target radius based on bass and parameters (scaled for consistency)
        const targetRadius = formationRadius + bass * formationRadius * 1.5;

        // Get color scheme
        const scheme = COLOR_SCHEMES[this.settings.colorScheme];
        const numColors = magnitudes.length;

        // Update particle positions
        for (let i = 0; i < this.particleSwarmArray.length; i++) {
            const particle = this.particleSwarmArray[i];
            const dx = centerX - particle.x;
            const dy = centerY - particle.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 0) {
                const angle = Math.atan2(dy, dx);

                let targetX, targetY;
                if (bass > 0.5) {
                    // Form circular shape on strong bass
                    targetX = centerX + Math.cos(angle) * targetRadius;
                    targetY = centerY + Math.sin(angle) * targetRadius;
                } else {
                    // Create spiral/swirling motion on treble
                    const rotationSpeed = treble * Math.PI;
                    const expansionFactor = 1 + treble * 0.5;
                    targetX = centerX + Math.cos(angle + rotationSpeed) * (distance * expansionFactor);
                    targetY = centerY + Math.sin(angle + rotationSpeed) * (distance * expansionFactor);
                }

                // Apply movement speed parameter
                particle.vx = (targetX - particle.x) * movementSpeed;
                particle.vy = (targetY - particle.y) * movementSpeed;
            }

            particle.x += particle.vx;
            particle.y += particle.vy;

            // Update trail (length controlled by parameter)
            particle.trail.push({ x: particle.x, y: particle.y });
            if (particle.trail.length > trailLength) particle.trail.shift();

            // Get color from color scheme based on particle's velocity and position
            const velocity = Math.sqrt(particle.vx ** 2 + particle.vy ** 2);
            const velocityFactor = Math.min(velocity * 50, 1);

            // Blend between primary and secondary colors based on velocity
            const colorStr = this.getColor(particle.colorIndex, numColors);
            const color = this.parseRgbColor(colorStr);

            // Add velocity-based brightness
            const brightnessFactor = 0.7 + velocityFactor * 0.3;
            const r = Math.min(255, Math.floor(color[0] * brightnessFactor));
            const g = Math.min(255, Math.floor(color[1] * brightnessFactor));
            const b = Math.min(255, Math.floor(color[2] * brightnessFactor));

            // Draw trail with fading alpha
            if (particle.trail.length > 1 && trailLength > 0) {
                for (let t = 0; t < particle.trail.length - 1; t++) {
                    const alpha = (t / particle.trail.length) * 0.5;
                    this.ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.moveTo(particle.trail[t].x, particle.trail[t].y);
                    this.ctx.lineTo(particle.trail[t + 1].x, particle.trail[t + 1].y);
                    this.ctx.stroke();
                }
            }

            // Draw particle with size parameter
            const size = particleSize * (0.8 + velocityFactor * 0.4);
            this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
            this.ctx.beginPath();
            this.ctx.arc(particle.x, particle.y, size / 2, 0, Math.PI * 2);
            this.ctx.fill();

            // Add glow effect for brighter particles
            if (velocityFactor > 0.5) {
                this.ctx.fillStyle = `rgba(${Math.min(255, r + 50)}, ${Math.min(255, g + 50)}, ${Math.min(255, b + 50)}, 0.4)`;
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        // Remove excess particles if count was reduced
        if (this.particleSwarmArray.length > particleCount) {
            this.particleSwarmArray = this.particleSwarmArray.slice(0, particleCount);
        }
    }

    /**
     * Mode 105: Crystal Lattice
     * 3D crystal structure with pulsing nodes
     */
    renderCrystalLattice(magnitudes) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length * 0.25))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.25);
        const mids = magnitudes.slice(Math.floor(magnitudes.length * 0.25), Math.floor(magnitudes.length * 0.75))
            .reduce((a, b) => a + b, 0) / (magnitudes.length * 0.5);

        // Use settings - circleCount controls grid density
        const circleCount = this.settings.circleCount || 50;
        const barCount = this.settings.barCount || 72;

        // Grid size controlled by circleCount (3-7 range)
        const gridSize = Math.max(3, Math.min(7, Math.floor(3 + circleCount / 16.67)));

        // Initialize crystal lattice nodes - reinitialize if grid size changed
        if (!this.crystalLatticeNodes || !this.lastCrystalGridSize || this.lastCrystalGridSize !== gridSize) {
            this.crystalLatticeNodes = [];
            this.lastCrystalGridSize = gridSize;
            const spacing = Math.min(this.canvas.width, this.canvas.height) / (gridSize + 1);
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    for (let k = 0; k < gridSize; k++) {
                        this.crystalLatticeNodes.push({
                            x3d: (i - gridSize / 2) * spacing,
                            y3d: (j - gridSize / 2) * spacing,
                            z3d: (k - gridSize / 2) * spacing,
                            magnitude: 0,
                            index: i * gridSize * gridSize + j * gridSize + k
                        });
                    }
                }
            }
        }

        // Fade background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        const angle = this.frameCounter * 0.02;
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;

        // Update magnitudes and project nodes
        for (let i = 0; i < this.crystalLatticeNodes.length; i++) {
            const node = this.crystalLatticeNodes[i];
            node.magnitude = magnitudes[Math.min(i * 2, magnitudes.length - 1)];

            // 3D rotation
            let x = node.x3d;
            let y = node.y3d * Math.cos(angle) - node.z3d * Math.sin(angle);
            let z = node.y3d * Math.sin(angle) + node.z3d * Math.cos(angle);

            const xRot = x * Math.cos(angle) - z * Math.sin(angle);
            const zRot = x * Math.sin(angle) + z * Math.cos(angle);

            // Perspective projection
            const scale = 300 / (300 + zRot);
            node.x2d = centerX + xRot * scale;
            node.y2d = centerY + y * scale;
            node.z2d = zRot;
        }

        // Connection distance threshold controlled by barCount
        const connectionThreshold = 150 + (barCount / 72) * 100;

        // Draw connections between nearby nodes
        for (let i = 0; i < this.crystalLatticeNodes.length; i++) {
            const node1 = this.crystalLatticeNodes[i];
            for (let j = i + 1; j < Math.min(i + 10, this.crystalLatticeNodes.length); j++) {
                const node2 = this.crystalLatticeNodes[j];
                const dist = Math.sqrt(
                    (node1.x3d - node2.x3d) ** 2 +
                    (node1.y3d - node2.y3d) ** 2 +
                    (node1.z3d - node2.z3d) ** 2
                );

                if (dist < connectionThreshold) {
                    const intensity = (node1.magnitude + node2.magnitude) * 127.5;
                    if (intensity > 30) {
                        // Use color scheme for connections
                        const connColor = this.getColor(i, this.crystalLatticeNodes.length);
                        const connMatch = connColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                        let connR = 128, connG = 128, connB = 150;
                        if (connMatch) {
                            connR = parseInt(connMatch[1]);
                            connG = parseInt(connMatch[2]);
                            connB = parseInt(connMatch[3]);
                        }

                        // Dim the connection colors
                        const dimFactor = 0.3 + (intensity / 255) * 0.4;
                        connR = Math.floor(connR * dimFactor);
                        connG = Math.floor(connG * dimFactor);
                        connB = Math.floor(connB * dimFactor);

                        this.ctx.strokeStyle = `rgb(${connR}, ${connG}, ${connB})`;
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.moveTo(node1.x2d, node1.y2d);
                        this.ctx.lineTo(node2.x2d, node2.y2d);
                        this.ctx.stroke();
                    }
                }
            }
        }

        // Draw nodes with color scheme
        for (let i = 0; i < this.crystalLatticeNodes.length; i++) {
            const node = this.crystalLatticeNodes[i];
            const radius = 5 + node.magnitude * 15;

            // Use color scheme instead of hard-coded HSV
            const baseColor = this.getColor(i, this.crystalLatticeNodes.length);
            const match = baseColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            let r = 150, g = 150, b = 200;
            if (match) {
                r = parseInt(match[1]);
                g = parseInt(match[2]);
                b = parseInt(match[3]);
            }

            // Brighten based on magnitude
            const brightnessFactor = 0.7 + node.magnitude * 0.5;
            r = Math.min(255, Math.floor(r * brightnessFactor));
            g = Math.min(255, Math.floor(g * brightnessFactor));
            b = Math.min(255, Math.floor(b * brightnessFactor));

            this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
            this.ctx.beginPath();
            this.ctx.arc(node.x2d, node.y2d, radius, 0, Math.PI * 2);
            this.ctx.fill();

            // Outline using lighter version of color
            const outlineR = Math.min(255, r + 80);
            const outlineG = Math.min(255, g + 80);
            const outlineB = Math.min(255, b + 80);
            this.ctx.strokeStyle = `rgb(${outlineR}, ${outlineG}, ${outlineB})`;
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.arc(node.x2d, node.y2d, radius + 2, 0, Math.PI * 2);
            this.ctx.stroke();
        }
    }

    /**
     * Generate preview frame
     */

    /**
     * Placeholder renderer for modes under development
     */
    renderPlaceholder(magnitudes, modeName, modeNumber) {
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));

        // Draw circular bars as placeholder
        const numBars = this.settings.numBars || 72;
        const angleStep = (Math.PI * 2) / numBars;
        // Use the innerRadius from settings, respecting preview mode settings
        const innerRadius = this.getEffectiveInnerRadius() !== undefined ? this.getEffectiveInnerRadius() : 180;

        for (let i = 0; i < numBars; i++) {
            const magnitude = magnitudes[Math.floor((i / numBars) * magnitudes.length)] || 0;
            const angle = i * angleStep;
            const barLength = magnitude * this.maxRadius * 0.8;

            const startX = this.centerX + Math.cos(angle) * innerRadius;
            const startY = this.centerY + Math.sin(angle) * innerRadius;
            const endX = this.centerX + Math.cos(angle) * (innerRadius + barLength);
            const endY = this.centerY + Math.sin(angle) * (innerRadius + barLength);

            const color = this.getColor(i, numBars);

            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = (this.settings.barWidthMultiplier || 0.8) * 8;
            this.ctx.lineCap = 'round';

            this.ctx.beginPath();
            this.ctx.moveTo(startX, startY);
            this.ctx.lineTo(endX, endY);
            this.ctx.stroke();
        }

        // Display mode name and number
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        this.ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(`Mode ${modeNumber}: ${modeName}`, this.centerX, this.centerY);
    }

    /**
     * Mode 106: Aurora Waves
     * Mode 106: Aurora borealis flowing curtains
     */
        render116LightningStorm(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 117: Cellular Growth
     * Mode 117: Biological cell division and growth
     */
        render117CellularGrowth(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 118: Sound Ribbons
     * Mode 118: 3D ribbons twisting through space
     */
        render118SoundRibbons(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numWaves = Math.floor(8 * complexity);
        for (let i = 0; i < numWaves; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const baseY = this.centerY + (i - numWaves / 2) * 20;

            const hue = ((i * 40 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.lineWidth = 2 + magnitude * 3 * intensity;
            this.ctx.beginPath();

            for (let x = 0; x < this.canvas.width; x += 10) {
                const y = baseY + Math.sin(x * 0.02 + this.frameCounter * 0.05 * speed + i) * magnitude * 50 * intensity;
                if (x === 0) this.ctx.moveTo(x, y);
                else this.ctx.lineTo(x, y);
            }
            this.ctx.stroke();
        }
    }

    /**
     * Mode 119: Matrix Rain
     * Mode 119: Matrix code rain
     */
        render119MatrixRain(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 120: Fire Mandala
     * Mode 120: Circular mandala made of flames
     */
        render120FireMandala(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 121: Tessellation Shift
     * Mode 121: Escher-style morphing tessellations
     */
        render121TessellationShift(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 122: Seismic Waves
     * Mode 122: Seismograph readings with P-waves and S-waves
     */
        render122SeismicWaves(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 123: Neon City
     * Mode 123: Cyberpunk city with pulsing lights
     */
        render123NeonCity(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 124: Magnetic Field
     * Mode 124: Magnetic field lines with particle clustering
     */
        render124MagneticField(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 125: Bubble Fusion
     * Mode 125: Bubbles that float, merge, and pop
     */
        render125BubbleFusion(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 126: Tribal Drums
     * Mode 126: Tribal patterns pulsing like drum skins
     */
        render126TribalDrums(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 127: Glass Shatter
     * Mode 127: Glass forming and shattering
     */
        render127GlassShatter(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 128: Bioluminescence
     * Mode 128: Deep ocean bioluminescent creatures
     */
        render128Bioluminescence(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 129: Sound Architecture
     * Mode 129: Impossible architecture constructing/deconstructing
     */
        render129SoundArchitecture(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 130: Plasma Ball
     * Mode 130: Plasma globe with electrical tendrils
     */
        render130PlasmaBall(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 131: Sand Mandala
     * Mode 131: Tibetan sand mandala forming grain by grain
     */
        render131SandMandala(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 132: Laser Show
     * Mode 132: Concert laser beams sweeping and bouncing
     */
        render132LaserShow(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 133: Coral Reef
     * Mode 133: Growing coral reef with swaying polyps
     */
        render133CoralReef(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 134: Wireframe Morph
     * Mode 134: 3D wireframe objects morphing between shapes
     */
        render134WireframeMorph(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 135: Sound Garden
     * Mode 135: Abstract garden with blooming flowers
     */
        render135SoundGarden(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 136: Hologram Glitch
     * Mode 136: Glitching holographic interface
     */
        render136HologramGlitch(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 137: Pendulum Wave
     * Mode 137: Multiple pendulums creating wave patterns
     */
        render137PendulumWave(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 138: Volcano Eruption
     * Mode 138: Volcano erupting with lava and ash
     */
        render138VolcanoEruption(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 139: Butterfly Effect
     * Mode 139: Chaos theory Lorenz attractor
     */
        render139ButterflyEffect(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 140: Silk Weaving
     * Mode 140: Silk threads weaving patterns
     */
        render140SilkWeaving(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 141: Clock Gears
     * Mode 141: Interlocking clockwork gears turning
     */
        render141ClockGears(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 142: Smoke Signals
     * Mode 142: Rising smoke plumes forming patterns
     */
        render142SmokeSignals(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 143: Stained Glass
     * Mode 143: Glowing stained glass window
     */
        render143StainedGlass(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 144: String Theory
     * Mode 144: Theoretical strings vibrating in multiple dimensions
     */
        render144StringTheory(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 145: Paper Craft
     * Mode 145: Paper cutouts folding into 3D shapes
     */
        render145PaperCraft(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 146: Northern Lights
     * Mode 146: Realistic aurora borealis dancing
     */
        render146NorthernLights(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 147: Cellular Automata
     * Mode 147: Conway's Game of Life with audio triggers
     */
        render147CellularAutomata(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 148: Dragon Curve
     * Mode 148: Fractal dragon curve growing
     */
        render148DragonCurve(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 149: Rain Circles
     * Mode 149: Concentric circles like raindrops
     */
        render149RainCircles(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 150: Fourier Epicycles
     * Mode 150: Rotating circles tracing Fourier series
     */
        render150FourierEpicycles(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 151: Neon Halo Burst
     * Mode 151: Circular ring whose radius pulses with kick; emits radial spikes on snare
     */
        render151NeonHaloBurst(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 152: Twin Orbiters
     * Mode 152: Two dots orbit a center with elastic distance; trails draw lissajous figure
     */
        render152TwinOrbiters(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 153: Bar Spiral Galaxy
     * Mode 153: Bars arranged in a spiral. Each bar length follows its band
     */
        render153BarSpiralGalaxy(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numPoints = Math.floor(100 * complexity);
        const hue = (this.frameCounter % 360) / 360;
        const rgb = this.hsvToRgb(hue, 0.8, 0.9);

        this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.6)`;
        this.ctx.lineWidth = 2 * intensity;
        this.ctx.beginPath();

        for (let i = 0; i < numPoints; i++) {
            const t = i / numPoints;
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = t * Math.PI * 6 + this.frameCounter * 0.01 * speed;
            const radius = t * this.maxRadius * (0.8 + magnitude * 0.2) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            if (i === 0) this.ctx.moveTo(x, y);
            else this.ctx.lineTo(x, y);
        }
        this.ctx.stroke();
    }

    /**
     * Mode 154: Ribbon Wave
     * Mode 154: Wide ribbon undulates like cloth; bass lifts amplitude
     */
        render154RibbonWave(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 155: Voxel City
     * Mode 155: 3D grid of extruded cubes like skyline; building heights react per frequency
     */
        render155VoxelCity(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 156: Sunburst Dial
     * Mode 156: 360 radial meter with ticks; ticks bend outward on mids
     */
        render156SunburstDial(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 157: Waterline Oscilloscope
     * Mode 157: Horizontal waveform floats like water surface
     */
        render158LaserTunnel(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 159: Vector Field Sprites
     * Mode 159: Thousands of particles follow a noise flow; velocity multiplies on mids
     */
        render159VectorFieldSprites(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 160: Orbit Rings Meter
     * Mode 160: Nested orbits with dots; each ring maps to a band
     */
        render160OrbitRingsMeter(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 161: Stitch Bars
     * Mode 161: Stacked micro-bars like embroidered stitches
     */
        render161StitchBars(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 162: Aurora Curtain
     * Mode 162: Vertical curtains waving; bass widens curtain
     */
        render162AuroraCurtain(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 164: Polygon Heartbeat
     * Mode 164: Regular polygon in the center inflates on kicks
     */
        render164PolygonHeartbeat(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 165: Confetti Impulse
     * Mode 165: On peaks, spawn confetti bursts
     */
        render165ConfettiImpulse(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numWaves = Math.floor(8 * complexity);
        for (let i = 0; i < numWaves; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const baseY = this.centerY + (i - numWaves / 2) * 20;

            const hue = ((i * 40 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.lineWidth = 2 + magnitude * 3 * intensity;
            this.ctx.beginPath();

            for (let x = 0; x < this.canvas.width; x += 10) {
                const y = baseY + Math.sin(x * 0.02 + this.frameCounter * 0.05 * speed + i) * magnitude * 50 * intensity;
                if (x === 0) this.ctx.moveTo(x, y);
                else this.ctx.lineTo(x, y);
            }
            this.ctx.stroke();
        }
    }

    /**
     * Mode 166: Wireframe Dome
     * Mode 166: Hemispherical mesh; vertices displace along normals
     */
        render166WireframeDome(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 167: Pulse Dashes
     * Mode 167: Circular dashed stroke; dash length oscillates with mids
     */
        render167PulseDashes(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numWaves = Math.floor(8 * complexity);
        for (let i = 0; i < numWaves; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const baseY = this.centerY + (i - numWaves / 2) * 20;

            const hue = ((i * 40 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.lineWidth = 2 + magnitude * 3 * intensity;
            this.ctx.beginPath();

            for (let x = 0; x < this.canvas.width; x += 10) {
                const y = baseY + Math.sin(x * 0.02 + this.frameCounter * 0.05 * speed + i) * magnitude * 50 * intensity;
                if (x === 0) this.ctx.moveTo(x, y);
                else this.ctx.lineTo(x, y);
            }
            this.ctx.stroke();
        }
    }

    /**
     * Mode 168: Terrain Sweep
     * Mode 168: Scrolling heightmap like synthwave hills
     */
        render168TerrainSweep(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 169: Chromatic Bars Mirror
     * Mode 169: Mirrored bars with central symmetry; hue rotates
     */
        render169ChromaticBarsMirror(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 170: Bubble Choir
     * Mode 170: Bubbles rise; size from band energy; pop on snare
     */
        render170BubbleChoir(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 171: Starfield Quantizer
     * Mode 171: Stars quantized to a grid; cell brightness follows local band
     */
        render171StarfieldQuantizer(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 172: Dna Ladder
     * Mode 172: Two sinusoid strands; rung length follows mids
     */
        render172DnaLadder(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 173: Arc Meter Trio
     * Mode 173: Three concentric arcs for lows/mids/highs
     */
        render173ArcMeterTrio(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 174: Ink Splatter Scope
     * Mode 174: Oscilloscope line with ink-style splats at transients
     */
        render175HexCellBloom(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 176: Event Horizon Lattice
     * Mode 176: Event Horizon Lattice - warped grid bends toward a black hole; streaks on transients
     */
        render176EventHorizonLattice(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 177: Comet Conveyor
     * Mode 177: Comet Conveyor - endless belt carries comets; tails shear on treble
     */
        render177CometConveyor(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 178: Quantum Foam Micro
     * Mode 178: Quantum Foam Micro - foamy micro-bubbles pop; cascades on peaks
     */
        render178QuantumFoamMicro(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 179: Aurora Crown
     * Mode 179: Aurora Crown - polar aurora dome overhead; ribbons brighten by mids
     */
        render179AuroraCrown(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 180: Asteroid Excavator
     * Mode 180: Asteroid Excavator - drill depth increases with bass; debris size follows highs
     */
        render180AsteroidExcavator(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 181: Hyperloop Spectrotrain
     * Mode 181: Hyperloop Spectrotrain - car length scales to energy; station lights strobe
     */
        render181HyperloopSpectrotrain(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 182: Galactic Pinball
     * Mode 182: Galactic Pinball - bumpers map to bands; ball boosts on peaks
     */
        render182GalacticPinball(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 183: Nebula Inkblot
     * Mirrored volumetric smoke with hue by dominant band
     */
    render183NebulaInkblot(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        // Use Step 4 settings
        const barCount = this.settings.barCount || 72;
        const innerRadius = this.getEffectiveInnerRadius();

        // Calculate frequency bands
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        // Create volumetric smoke effect with fade trails
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
        this.ctx.fillRect(0, 0, this.width, this.height);

        // Determine dominant band for color influence
        let dominantBand = 0;
        if (bass > mids && bass > treble) dominantBand = 0; // Bass - more red
        else if (mids > bass && mids > treble) dominantBand = 0.5; // Mids - green
        else dominantBand = 1; // Treble - blue

        // Number of particles affected by barCount and complexity
        const numParticles = Math.floor(40 * complexity * (barCount / 72));

        // Initialize particle history if not exists
        if (!this.nebulaParticles || this.nebulaParticles.length !== numParticles) {
            this.nebulaParticles = [];
            for (let i = 0; i < numParticles; i++) {
                this.nebulaParticles.push({
                    angle: (i / numParticles) * Math.PI * 2,
                    offset: Math.random() * Math.PI * 2
                });
            }
        }

        for (let i = 0; i < numParticles; i++) {
            const particle = this.nebulaParticles[i];
            const magnitude = magnitudes[i % magnitudes.length];

            // Update particle position with flowing motion
            particle.angle += 0.005 * speed;
            const flowAngle = particle.angle + Math.sin(this.frameCounter * 0.02 + particle.offset) * 0.5;

            // Distance from center affected by innerRadius and magnitude
            const baseDistance = (innerRadius / 180) * 0.2 + 0.4;
            const distance = this.maxRadius * (baseDistance + Math.sin(this.frameCounter * 0.03 + particle.offset) * 0.2) * (0.5 + magnitude * 0.5) * intensity;

            // Calculate position
            const offsetX = Math.cos(flowAngle) * distance;
            const offsetY = Math.sin(flowAngle) * distance;

            const size = (3 + magnitude * 8 * intensity) * (Math.min(innerRadius, 120) / 120);

            // Get base color from gradient
            const baseColor = this.getColor(i, numParticles);
            const match = baseColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            let r = 150, g = 150, b = 200;
            if (match) {
                r = parseInt(match[1]);
                g = parseInt(match[2]);
                b = parseInt(match[3]);
            }

            // Apply dominant band color shift
            const bandInfluence = 0.5 + magnitude * 0.3;
            if (dominantBand < 0.3) { // Bass - enhance red
                r = Math.min(255, r * (1 + bandInfluence * 0.5));
                b = Math.max(0, b * (1 - bandInfluence * 0.3));
            } else if (dominantBand > 0.7) { // Treble - enhance blue
                b = Math.min(255, b * (1 + bandInfluence * 0.5));
                r = Math.max(0, r * (1 - bandInfluence * 0.3));
            } else { // Mids - enhance green
                g = Math.min(255, g * (1 + bandInfluence * 0.4));
            }

            const opacity = (0.3 + magnitude * 0.5) * intensity;
            this.ctx.fillStyle = `rgba(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)}, ${opacity})`;
            this.ctx.shadowBlur = 15 * intensity * (1 + magnitude);
            this.ctx.shadowColor = `rgba(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)}, 0.6)`;

            // Draw mirrored particles (Rorschach inkblot effect)
            // Right side
            this.ctx.beginPath();
            this.ctx.arc(this.centerX + offsetX, this.centerY + offsetY, size, 0, Math.PI * 2);
            this.ctx.fill();

            // Left side (mirrored)
            this.ctx.beginPath();
            this.ctx.arc(this.centerX - offsetX, this.centerY + offsetY, size, 0, Math.PI * 2);
            this.ctx.fill();

            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 184: Satellite Telemetry Rings
     * Mode 184: Satellite Telemetry Rings - rippling rings with dashed spectrum
     */
        render184SatelliteTelemetryRings(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 185: Wormhole Origami
     * Mode 185: Wormhole Origami - sheet folds into portal; depth by bass
     */
        render185WormholeOrigami(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 186: Holographic Jellyfish
     * Mode 186: Holographic Jellyfish - bell pulsates with lows; tentacles sparkle with highs
     */
        render186HolographicJellyfish(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 187: Moon Quarry Crane
     * Mode 187: Moon Quarry Crane - bins heights equal band magnitude; dust on kicks
     */
        render187MoonQuarryCrane(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 188: Constellation Typoplot
     * Mode 188: Constellation TypoPlot - letters as stars; lines draw when band is hot
     */
        render188ConstellationTypoplot(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 189: Cryo Crystal Garden
     * Mode 189: Cryo Crystal Garden - crystals grow per frequency slice; flare on treble
     */
        render189CryoCrystalGarden(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 190: Meteorite Blueprint
     * Mode 190: Meteorite Blueprint - technical UI; callouts to bands; red stamp on peaks
     */
        render190MeteoriteBlueprint(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 191: Lunar Tide Pool
     * Mode 191: Lunar Tide Pool - water level by bass; caustics sharpen with highs
     */
        render191LunarTidePool(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 192: Orbital Barcode Slicer
     * Mode 192: Orbital Barcode Slicer - rings slice vertical barcode; brightness per band
     */
        render192OrbitalBarcodeSlicer(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 193: Satellite Swarm Flocking
     * Mode 193: Satellite Swarm Flocking - simple flock; thrust bursts on kick
     */
        render193SatelliteSwarmFlocking(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 194: Astro Pulse Weave
     * Mode 194: Astro Pulse Weave - two opposing spiral waves; brightness sum of bands
     */
        render194AstroPulseWeave(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numWaves = Math.floor(8 * complexity);
        for (let i = 0; i < numWaves; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const baseY = this.centerY + (i - numWaves / 2) * 20;

            const hue = ((i * 40 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.lineWidth = 2 + magnitude * 3 * intensity;
            this.ctx.beginPath();

            for (let x = 0; x < this.canvas.width; x += 10) {
                const y = baseY + Math.sin(x * 0.02 + this.frameCounter * 0.05 * speed + i) * magnitude * 50 * intensity;
                if (x === 0) this.ctx.moveTo(x, y);
                else this.ctx.lineTo(x, y);
            }
            this.ctx.stroke();
        }
    }

    /**
     * Mode 195: Zero G Paint Spheres
     * Mode 195: Zero-G Paint Spheres - spheres merge on peaks and split on highs
     */
        render195ZeroGPaintSpheres(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 196: Supernova Countdown
     * Mode 196: Supernova Countdown - star swells with energy; blasts at threshold
     */
        render196SupernovaCountdown(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 197: Martian Wind Harp
     * Mode 197: Martian Wind Harp - dunes as strings; ripples by mids; dust devils on snares
     */
        render197MartianWindHarp(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 198: Teleporting Bar Choir
     * Mode 198: Teleporting Bar Choir - bars pop at random radial positions; decay persists
     */
        render198TeleportingBarChoir(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 199: Cosmic Vinyl Halo
     * Mode 199: Cosmic Vinyl Halo - record edge-on; grooves shimmer with spectrum
     */
        render199CosmicVinylHalo(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 200: Photon Origination Chamber
     * Mode 200: Photon Origination Chamber - photons exit slits; rate per band bucket
     */
        render200PhotonOriginationChamber(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 201: Meteor Net
     * Mode 201: Meteor Net - hex net catches meteors; nodes glow by band
     */
        render301ForestCanopy(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 302: Ocean Waves
     * Mode 302: Flowing ocean waves with foam
     */
        render302OceanWaves(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 303: Coral Reef
     * Mode 303: Coral formations with flowing tentacles
     */
        render303CoralReef(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 304: Butterfly Swarm
     * Mode 304: Butterflies dancing to music
     */
        render304ButterflySwarm(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 305: Mountain Peaks
     * Mode 305: Mountain ranges responding to frequencies
     */
        render305MountainPeaks(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 306: Fireflies
     * Mode 306: Fireflies glowing and flickering
     */
        render306Fireflies(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 307: Flower Bloom
     * Mode 307: Flowers blooming radially
     */
        render307FlowerBloom(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 308: Rain Ripples
     * Mode 308: Rain creating ripples on water surface
     */
        render308RainRipples(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 309: Leaf Fall
     * Mode 309: Autumn leaves falling
     */
        render309LeafFall(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 310: Tree Rings
     * Mode 310: Growth rings of a tree
     */
        render310TreeRings(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 311: Lightning Storm
     * Mode 311: Lightning bolts during storm
     */
        render311LightningStorm(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 312: Pond Koi
     * Mode 312: Koi fish swimming in pond
     */
        render312PondKoi(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 313: Moss Growth
     * Mode 313: Moss spreading organically
     */
        render313MossGrowth(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 314: Aurora Forest
     * Mode 314: Northern lights over forest
     */
        render314AuroraForest(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 315: Dandelion Seeds
     * Mode 315: Dandelion seeds floating in wind
     */
        render315DandelionSeeds(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 316: Fern Fractals
     * Mode 316: Fractal fern patterns
     */
        render316FernFractals(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 317: Beehive Cells
     * Mode 317: Hexagonal honeycomb pattern
     */
        render317BeehiveCells(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 318: Wheat Field
     * Mode 318: Wheat swaying in wind
     */
        render318WheatField(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 319: Spider Web
     * Mode 319: Spider web with dew drops
     */
        render319SpiderWeb(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 320: Mushroom Spores
     * Mode 320: Mushroom spores floating
     */
        render320MushroomSpores(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 321: Bamboo Forest
     * Mode 321: Bamboo stalks swaying
     */
        render321BambooForest(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 322: Tide Pools
     * Mode 322: Tide pools with sea life
     */
        render322TidePools(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 323: Vine Tendrils
     * Mode 323: Growing vine tendrils
     */
        render323VineTendrils(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 324: Crystal Cave
     * Mode 324: Crystalline cave formations
     */
        render324CrystalCave(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 325: Bird Murmuration
     * Mode 325: Flock of birds in murmuration
     */
        render325BirdMurmuration(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 326: River Flow
     * Mode 326: River flowing with currents
     */
        render326RiverFlow(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numWaves = Math.floor(8 * complexity);
        for (let i = 0; i < numWaves; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const baseY = this.centerY + (i - numWaves / 2) * 20;

            const hue = ((i * 40 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.lineWidth = 2 + magnitude * 3 * intensity;
            this.ctx.beginPath();

            for (let x = 0; x < this.canvas.width; x += 10) {
                const y = baseY + Math.sin(x * 0.02 + this.frameCounter * 0.05 * speed + i) * magnitude * 50 * intensity;
                if (x === 0) this.ctx.moveTo(x, y);
                else this.ctx.lineTo(x, y);
            }
            this.ctx.stroke();
        }
    }

    /**
     * Mode 327: Seed Pods
     * Mode 327: Seed pods bursting open
     */
        render327SeedPods(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 328: Algae Bloom
     * Mode 328: Algae blooming in water
     */
        render328AlgaeBloom(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 329: Cactus Spines
     * Mode 329: Cactus with radiating spines
     */
        render329CactusSpines(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 330: Snowflakes
     * Mode 330: Unique snowflakes falling
     */
        render330Snowflakes(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 331: Lava Flow
     * Mode 331: Molten lava flowing
     */
        render331LavaFlow(magnitudes) {
        // Get parameters with defaults
        const lavaLayers = this.settings.mode331LavaFlowLavaLayers || 6;
        const flowSpeed = this.settings.mode331LavaFlowFlowSpeed || 1.5;
        const viscosity = this.settings.mode331LavaFlowViscosity || 0.03;
        const waveAmplitude = (this.settings.mode331LavaFlowWaveAmplitude || 40) * this.scaleFactor;
        const glowIntensity = this.settings.mode331LavaFlowGlowIntensity || 1;
        const trailOpacity = this.settings.mode331LavaFlowTrailOpacity || 0.15;

        // Calculate audio bands
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        // Initialize lava flow particles
        if (!this.lavaFlowParticles) {
            this.lavaFlowParticles = [];
        }

        // Fade background for trail effect
        this.ctx.fillStyle = `rgba(10, 0, 0, ${trailOpacity})`;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.frameCounter = (this.frameCounter || 0) + flowSpeed * 0.02;

        // Get color scheme
        const scheme = COLOR_SCHEMES[this.settings.colorScheme];
        const color1 = scheme.primary;
        const color2 = scheme.secondary;

        // Create lava-specific warm gradient from color scheme
        // Shift colors toward red/orange/yellow for lava effect
        const lavaColor1 = [
            Math.min(255, color1[0] + 50),  // Add red
            Math.max(0, color1[1] - 20),     // Reduce green
            Math.max(0, color1[2] - 50)      // Reduce blue
        ];
        const lavaColor2 = [
            Math.min(255, color2[0] + 80),   // More red
            Math.min(200, color2[1] + 30),   // Add some yellow
            Math.max(0, color2[2] - 80)      // Much less blue
        ];

        // Spawn lava bubbles on strong bass
        if (bass > 0.4 && Math.random() < bass * 0.3) {
            const spawnY = this.canvas.height - 50 * this.scaleFactor;
            const spawnX = Math.random() * this.canvas.width;
            this.lavaFlowParticles.push({
                x: spawnX,
                y: spawnY,
                vy: -(2 + bass * 4) * this.scaleFactor,
                vx: (Math.random() - 0.5) * 2 * this.scaleFactor,
                size: (5 + bass * 10) * this.scaleFactor,
                life: 1.0,
                colorIndex: Math.floor(Math.random() * magnitudes.length)
            });
        }

        // Draw flowing lava layers
        const layerSpacing = this.canvas.height / (lavaLayers + 1);

        for (let layer = 0; layer < lavaLayers; layer++) {
            const baseY = this.canvas.height - layerSpacing * (layer + 1);
            const magnitude = magnitudes[Math.floor((layer / lavaLayers) * magnitudes.length)];

            // Calculate wave properties
            const waveFrequency = viscosity * (layer + 1);
            const phaseShift = layer * 0.5;

            // Interpolate between lava colors based on layer depth
            const colorBlend = layer / lavaLayers;
            const r = Math.floor(lavaColor1[0] * (1 - colorBlend) + lavaColor2[0] * colorBlend);
            const g = Math.floor(lavaColor1[1] * (1 - colorBlend) + lavaColor2[1] * colorBlend);
            const b = Math.floor(lavaColor1[2] * (1 - colorBlend) + lavaColor2[2] * colorBlend);

            // Add heat glow based on magnitude
            const heatBoost = magnitude * glowIntensity;
            const glowR = Math.min(255, r + heatBoost * 50);
            const glowG = Math.min(255, g + heatBoost * 30);
            const glowB = Math.max(0, b);

            // Draw flowing lava wave
            this.ctx.beginPath();
            this.ctx.moveTo(0, this.canvas.height);

            for (let x = 0; x <= this.canvas.width; x += 5) {
                const wave1 = Math.sin(x * waveFrequency + this.frameCounter + phaseShift) * waveAmplitude;
                const wave2 = Math.sin(x * waveFrequency * 1.5 + this.frameCounter * 0.7) * waveAmplitude * 0.5;
                const audioReactive = magnitude * waveAmplitude * 0.5;
                const y = baseY + wave1 + wave2 + audioReactive;

                this.ctx.lineTo(x, y);
            }

            this.ctx.lineTo(this.canvas.width, this.canvas.height);
            this.ctx.closePath();

            // Fill with gradient
            const gradient = this.ctx.createLinearGradient(0, baseY - waveAmplitude, 0, baseY + waveAmplitude);
            gradient.addColorStop(0, `rgba(${glowR}, ${glowG}, ${glowB}, ${0.3 + magnitude * 0.4})`);
            gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, ${0.6 + magnitude * 0.3})`);

            this.ctx.fillStyle = gradient;
            this.ctx.fill();

            // Add glow on top
            if (glowIntensity > 0.5) {
                this.ctx.strokeStyle = `rgba(${glowR}, ${glowG}, ${glowB}, ${0.4 * magnitude})`;
                this.ctx.lineWidth = 2 * this.scaleFactor;
                this.ctx.stroke();
            }
        }

        // Update and draw lava bubbles/splashes
        const newParticles = [];
        for (const particle of this.lavaFlowParticles) {
            particle.x += particle.vx;
            particle.y += particle.vy;
            particle.vy += 0.3 * this.scaleFactor; // Gravity
            particle.life -= 0.02;

            if (particle.life > 0 && particle.y < this.canvas.height) {
                // Get color from scheme
                const colorStr = this.getColor(particle.colorIndex, magnitudes.length);
                const color = this.parseRgbColor(colorStr);

                // Make it lava-colored
                const lavaR = Math.min(255, color[0] + 80);
                const lavaG = Math.min(180, color[1]);
                const lavaB = Math.max(0, color[2] - 80);

                const alpha = particle.life * 0.8;
                const size = particle.size * particle.life;

                // Draw bubble with glow
                this.ctx.shadowBlur = 20 * this.scaleFactor * glowIntensity;
                this.ctx.shadowColor = `rgba(${lavaR}, ${Math.min(255, lavaG + 50)}, ${lavaB}, ${alpha})`;

                this.ctx.fillStyle = `rgba(${lavaR}, ${lavaG}, ${lavaB}, ${alpha})`;
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                this.ctx.fill();

                // Bright core
                this.ctx.fillStyle = `rgba(255, ${200 + mids * 55}, ${100 + treble * 100}, ${alpha * 0.6})`;
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, size * 0.5, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.shadowBlur = 0;

                newParticles.push(particle);
            }
        }
        this.lavaFlowParticles = newParticles;

        // Add heat distortion effect on strong audio
        if (bass > 0.6 || treble > 0.7) {
            const numHeatWaves = Math.floor(3 + (bass + treble) * 5);
            for (let i = 0; i < numHeatWaves; i++) {
                const x = Math.random() * this.canvas.width;
                const y = this.canvas.height - Math.random() * this.canvas.height * 0.3;
                const size = (10 + Math.random() * 30) * this.scaleFactor;

                const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, size);
                gradient.addColorStop(0, 'rgba(255, 150, 0, 0.1)');
                gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');

                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 332: Ice Crystals
     * Mode 332: Ice crystal formations
     */
        render332IceCrystals(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 333: Pine Cones
     * Mode 333: Pine cone spiral patterns
     */
        render333PineCones(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 334: Geyser Eruption
     * Mode 334: Geyser water erupting
     */
        render334GeyserEruption(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 335: Pollen Cloud
     * Mode 335: Pollen drifting in air
     */
        render335PollenCloud(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 336: Desert Dunes
     * Mode 336: Sand dunes in wind
     */
        render336DesertDunes(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 337: Lily Pads
     * Mode 337: Water lilies on pond
     */
        render337LilyPads(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 338: Termite Mound
     * Mode 338: Termite mound structure
     */
        render338TermiteMound(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 339: Cherry Blossoms
     * Mode 339: Cherry blossom petals falling
     */
        render339CherryBlossoms(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 340: Root System
     * Mode 340: Underground root network
     */
        render340RootSystem(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 341: Plankton Swarm
     * Mode 341: Bioluminescent plankton
     */
        render341PlanktonSwarm(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 342: Frost Patterns
     * Mode 342: Frost forming on glass
     */
        render342FrostPatterns(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 343: Ant Trails
     * Mode 343: Ant colony foraging trails
     */
        render343AntTrails(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 344: Seaweed Sway
     * Mode 344: Seaweed swaying underwater
     */
        render344SeaweedSway(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 345: Volcano Ash
     * Mode 345: Volcanic ash cloud
     */
        render345VolcanoAsh(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 346: Dragonfly Wings
     * Mode 346: Dragonfly wing patterns
     */
        render346DragonflyWings(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 347: Pebble Ripples
     * Mode 347: Pebbles dropping in water
     */
        render347PebbleRipples(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numWaves = Math.floor(8 * complexity);
        for (let i = 0; i < numWaves; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const baseY = this.centerY + (i - numWaves / 2) * 20;

            const hue = ((i * 40 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.lineWidth = 2 + magnitude * 3 * intensity;
            this.ctx.beginPath();

            for (let x = 0; x < this.canvas.width; x += 10) {
                const y = baseY + Math.sin(x * 0.02 + this.frameCounter * 0.05 * speed + i) * magnitude * 50 * intensity;
                if (x === 0) this.ctx.moveTo(x, y);
                else this.ctx.lineTo(x, y);
            }
            this.ctx.stroke();
        }
    }

    /**
     * Mode 348: Moss Tendrils
     * Mode 348: Moss growing on stone
     */
        render348MossTendrils(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 349: Starfish Arms
     * Mode 349: Starfish with moving arms
     */
        render349StarfishArms(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 350: Venus Flytrap
     * Mode 350: Venus flytrap opening and closing
     */
        render350VenusFlytrap(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 351: Rainbow Mist
     * Mode 351: Rainbow appearing in mist
     */
        render351RainbowMist(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 352: Geode Crystals
     * Mode 352: Crystal formations inside geode
     */
        render352GeodeCrystals(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 353: Snake Scales
     * Mode 353: Snake skin scale pattern
     */
        render353SnakeScales(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 354: Whirlpool
     * Mode 354: Water spiraling into whirlpool
     */
        render354Whirlpool(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numPoints = Math.floor(100 * complexity);
        const hue = (this.frameCounter % 360) / 360;
        const rgb = this.hsvToRgb(hue, 0.8, 0.9);

        this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.6)`;
        this.ctx.lineWidth = 2 * intensity;
        this.ctx.beginPath();

        for (let i = 0; i < numPoints; i++) {
            const t = i / numPoints;
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = t * Math.PI * 6 + this.frameCounter * 0.01 * speed;
            const radius = t * this.maxRadius * (0.8 + magnitude * 0.2) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            if (i === 0) this.ctx.moveTo(x, y);
            else this.ctx.lineTo(x, y);
        }
        this.ctx.stroke();
    }

    /**
     * Mode 355: Owl Eyes
     * Mode 355: Owl eyes blinking
     */
        render355OwlEyes(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 356: Tornado Funnel
     * Mode 356: Tornado funnel with debris
     */
        render356TornadoFunnel(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 357: Peacock Feathers
     * Mode 357: Peacock tail feather display
     */
        render357PeacockFeathers(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 358: Jellyfish Pulse
     * Mode 358: Jellyfish pulsating
     */
        render358JellyfishPulse(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 359: Sand Ripples
     * Mode 359: Ripples in sand from wind
     */
        render359SandRipples(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numWaves = Math.floor(8 * complexity);
        for (let i = 0; i < numWaves; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const baseY = this.centerY + (i - numWaves / 2) * 20;

            const hue = ((i * 40 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.lineWidth = 2 + magnitude * 3 * intensity;
            this.ctx.beginPath();

            for (let x = 0; x < this.canvas.width; x += 10) {
                const y = baseY + Math.sin(x * 0.02 + this.frameCounter * 0.05 * speed + i) * magnitude * 50 * intensity;
                if (x === 0) this.ctx.moveTo(x, y);
                else this.ctx.lineTo(x, y);
            }
            this.ctx.stroke();
        }
    }

    /**
     * Mode 360: Bat Swarm - Murmuration
     * Mode 360: Birds/bats moving in realistic flocking patterns like a murmuration
     */
        render360BatSwarm(magnitudes) {
        const params = this.settings.modeParameters || {};
        // Use mode-specific parameters
        const batCount = params.batCount || 50;
        const swarmSpeed = params.swarmSpeed || 0.08;
        const wingSpan = params.wingSpan || 12;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;
        const trailLength = params.trailLength !== undefined ? params.trailLength : 0.15;
        const glowIntensity = params.glowIntensity !== undefined ? params.glowIntensity : 8;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length * 0.25);
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Initialize boid array for flocking behavior
        if (!this.batSwarmBoids || this.batSwarmBoids.length !== batCount) {
            this.batSwarmBoids = [];
            for (let i = 0; i < batCount; i++) {
                this.batSwarmBoids.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    phase: Math.random() * Math.PI * 2
                });
            }
        }

        // Add motion trail effect
        if (trailLength > 0) {
            this.ctx.fillStyle = `rgba(0, 0, 0, ${trailLength})`;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        } else {
            this.drawBackground();
        }

        // Enable glow
        this.ctx.shadowBlur = glowIntensity;

        // Audio-reactive parameters
        const flockRadius = 80 + complexity * 10;
        const separationDist = 30;
        const maxSpeed = 2 + swarmSpeed * speed * 10 + bass * 3;
        const maxForce = 0.05 + energy * 0.05;

        // Update each boid with flocking behavior
        for (let i = 0; i < this.batSwarmBoids.length; i++) {
            const boid = this.batSwarmBoids[i];
            const magnitude = magnitudes[i % magnitudes.length];

            // Flocking forces
            let separationX = 0, separationY = 0;
            let alignmentX = 0, alignmentY = 0;
            let cohesionX = 0, cohesionY = 0;
            let neighborCount = 0;

            // Check neighbors
            for (let j = 0; j < this.batSwarmBoids.length; j++) {
                if (i === j) continue;

                const other = this.batSwarmBoids[j];
                const dx = other.x - boid.x;
                const dy = other.y - boid.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < flockRadius) {
                    // Separation: steer away from close neighbors
                    if (dist < separationDist && dist > 0) {
                        separationX -= dx / dist;
                        separationY -= dy / dist;
                    }

                    // Alignment: match velocity of neighbors
                    alignmentX += other.vx;
                    alignmentY += other.vy;

                    // Cohesion: move towards center of neighbors
                    cohesionX += other.x;
                    cohesionY += other.y;

                    neighborCount++;
                }
            }

            // Calculate steering forces
            if (neighborCount > 0) {
                // Average alignment
                alignmentX /= neighborCount;
                alignmentY /= neighborCount;

                // Average cohesion position
                cohesionX /= neighborCount;
                cohesionY /= neighborCount;
                cohesionX -= boid.x;
                cohesionY -= boid.y;
            }

            // Apply forces with weights
            const separationWeight = 1.5;
            const alignmentWeight = 1.0;
            const cohesionWeight = 1.0;

            boid.vx += separationX * separationWeight * maxForce;
            boid.vy += separationY * separationWeight * maxForce;
            boid.vx += alignmentX * alignmentWeight * maxForce * 0.05;
            boid.vy += alignmentY * alignmentWeight * maxForce * 0.05;
            boid.vx += cohesionX * cohesionWeight * maxForce * 0.01;
            boid.vy += cohesionY * cohesionWeight * maxForce * 0.01;

            // Add audio-reactive drift and flow
            const flowAngle = (this.frameCounter || 0) * 0.02 * speed + i * 0.1;
            const flowForce = energy * 0.3;
            boid.vx += Math.cos(flowAngle) * flowForce * maxForce;
            boid.vy += Math.sin(flowAngle) * flowForce * maxForce;

            // Add organic wobble based on audio
            boid.vx += Math.sin((this.frameCounter || 0) * 0.1 + i) * magnitude * maxForce * 2;
            boid.vy += Math.cos((this.frameCounter || 0) * 0.15 + i) * magnitude * maxForce * 2;

            // Limit speed
            const currentSpeed = Math.sqrt(boid.vx * boid.vx + boid.vy * boid.vy);
            if (currentSpeed > maxSpeed) {
                boid.vx = (boid.vx / currentSpeed) * maxSpeed;
                boid.vy = (boid.vy / currentSpeed) * maxSpeed;
            }

            // Update position
            boid.x += boid.vx;
            boid.y += boid.vy;

            // Wrap around edges
            if (boid.x < -50) boid.x = this.canvas.width + 50;
            if (boid.x > this.canvas.width + 50) boid.x = -50;
            if (boid.y < -50) boid.y = this.canvas.height + 50;
            if (boid.y > this.canvas.height + 50) boid.y = -50;

            // Update wing flap phase
            boid.phase += (0.3 + treble * 0.2) * speed;

            // Draw the boid
            const batColor = this.getColor(i, this.batSwarmBoids.length);
            const match = batColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            let r = 20, g = 20, b = 20;
            if (match) {
                r = parseInt(match[1]);
                g = parseInt(match[2]);
                b = parseInt(match[3]);
            }

            const opacity = 0.7 + magnitude * 0.3;
            const batSize = 1.0 + magnitude * 0.3;

            this.ctx.shadowColor = `rgba(${r}, ${g}, ${b}, ${opacity * 0.8})`;
            this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
            this.ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
            this.ctx.lineWidth = 2 * batSize;

            // Wing flap animation
            const wingFlap = Math.sin(boid.phase) * 0.4 + 0.6;
            const currentWingSpan = wingSpan * wingFlap * batSize;

            // Calculate heading angle for direction
            const heading = Math.atan2(boid.vy, boid.vx);

            // Draw bird/bat with heading
            this.ctx.save();
            this.ctx.translate(boid.x, boid.y);
            this.ctx.rotate(heading);

            // Draw wings
            this.ctx.beginPath();
            this.ctx.moveTo(-currentWingSpan, 2);
            this.ctx.quadraticCurveTo(-currentWingSpan * 0.5, -6 * batSize, -2 * batSize, -3 * batSize);
            this.ctx.lineTo(0, -5 * batSize);
            this.ctx.lineTo(2 * batSize, -3 * batSize);
            this.ctx.quadraticCurveTo(currentWingSpan * 0.5, -6 * batSize, currentWingSpan, 2);
            this.ctx.stroke();

            // Body
            this.ctx.beginPath();
            this.ctx.arc(0, 0, 2.5 * batSize, 0, Math.PI * 2);
            this.ctx.fill();

            this.ctx.restore();
        }

        // Reset shadow
        this.ctx.shadowBlur = 0;

        this.frameCounter = (this.frameCounter || 0) + 1;
    }

    /**
     * Mode 361: Tide Motion
     * Mode 361: Tidal motion advancing and retreating
     */
        render361TideMotion(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 362: Lichen Growth
     * Mode 362: Lichen spreading on rock
     */
        render362LichenGrowth(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 363: Eagle Soar
     * Mode 363: Eagle soaring in thermals
     */
        render363EagleSoar(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 364: Mangrove Roots
     * Mode 364: Mangrove root system
     */
        render364MangroveRoots(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 365: Aurora Waves
     * Mode 365: Aurora borealis curtain waves
     */
        render365AuroraWaves(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 366: Dolphin Leap
     * Mode 366: Dolphins leaping from water
     */
        render366DolphinLeap(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 367: Tumbleweed Roll
     * Mode 367: Tumbleweed rolling across desert
     */
        render367TumbleweedRoll(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 368: Coral Polyps
     * Mode 368: Coral polyps extending tentacles
     */
        render368CoralPolyps(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 369: Smoke Wisps
     * Mode 369: Smoke wisps rising
     */
        render369SmokeWisps(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 370: Nautilus Shell
     * Mode 370: Nautilus shell spiral
     */
        render370NautilusShell(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 371: Wolf Howl
     * Mode 371: Wolf howling at moon with sound waves
     */
        render371WolfHowl(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 372: Seashell Patterns
     * Mode 372: Various seashell patterns
     */
        render372SeashellPatterns(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 373: Grass Blades
     * Mode 373: Individual grass blades swaying
     */
        render373GrassBlades(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 374: Stalactites
     * Mode 374: Cave stalactites and stalagmites
     */
        render374Stalactites(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 375: Amoeba Movement
     * Mode 375: Amoeba-like organic movement
     */
        render375AmoebaMovement(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 376: Pine Needles
     * Mode 376: Pine needle clusters
     */
        render376PineNeedles(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 377: Water Droplet
     * Mode 377: Water droplet impact and splash
     */
        render377WaterDroplet(magnitudes) {
        // Get parameters with defaults
        const dropletSize = (this.settings.mode377WaterDropletDropletSize || 8) * this.scaleFactor;
        const dropFrequency = this.settings.mode377WaterDropletDropFrequency || 0.1;
        const splashIntensity = this.settings.mode377WaterDropletSplashIntensity || 1;
        const rippleCount = this.settings.mode377WaterDropletRippleCount || 5;
        const impactThreshold = this.settings.mode377WaterDropletImpactThreshold || 0.4;
        const trailOpacity = this.settings.mode377WaterDropletTrailOpacity || 0.08;

        // Calculate audio bands
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4))
            .reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        // Initialize droplet arrays
        if (!this.waterDroplets) this.waterDroplets = [];
        if (!this.waterRipples) this.waterRipples = [];
        if (!this.waterSplashes) this.waterSplashes = [];

        // Fade background for trail effect
        this.ctx.fillStyle = `rgba(0, 5, 15, ${trailOpacity})`;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Get color scheme (make it water-themed)
        const scheme = COLOR_SCHEMES[this.settings.colorScheme];
        const color1 = scheme.primary;
        const color2 = scheme.secondary;

        // Create water-specific colors (shift toward blue/cyan)
        const waterColor1 = [
            Math.max(0, color1[0] - 50),      // Reduce red
            Math.min(255, color1[1] + 30),    // Add green
            Math.min(255, color1[2] + 80)     // Add blue
        ];
        const waterColor2 = [
            Math.max(0, color2[0] - 80),      // Much less red
            Math.min(255, color2[1] + 50),    // More green
            Math.min(255, color2[2] + 100)    // Much more blue
        ];

        // Spawn water droplets
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const spawnChance = dropFrequency * (0.5 + avgMagnitude * 0.5);

        if (Math.random() < spawnChance || (bass > impactThreshold && Math.random() < 0.3)) {
            const x = this.centerX + (Math.random() - 0.5) * this.canvas.width * 0.6;
            const colorIndex = Math.floor(Math.random() * magnitudes.length);
            this.waterDroplets.push({
                x: x,
                y: 0,
                vy: (2 + Math.random() * 3) * this.scaleFactor,
                size: dropletSize * (0.7 + Math.random() * 0.6),
                colorIndex: colorIndex
            });
        }

        // Water surface level
        const waterLevel = this.canvas.height * 0.7;

        // Update and draw falling droplets
        const newDroplets = [];
        for (const droplet of this.waterDroplets) {
            droplet.y += droplet.vy;
            droplet.vy += 0.2 * this.scaleFactor; // Gravity

            // Check if droplet hits water surface
            if (droplet.y >= waterLevel) {
                // Create splash
                const splashSize = droplet.size * splashIntensity;
                const numSplashParticles = Math.floor(8 + bass * 12);

                for (let i = 0; i < numSplashParticles; i++) {
                    const angle = (i / numSplashParticles) * Math.PI - Math.PI / 2;
                    const speed = (2 + Math.random() * 4) * splashIntensity * this.scaleFactor;
                    this.waterSplashes.push({
                        x: droplet.x,
                        y: waterLevel,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: splashSize * (0.5 + Math.random() * 0.5),
                        life: 1.0,
                        colorIndex: droplet.colorIndex
                    });
                }

                // Create ripples
                this.waterRipples.push({
                    x: droplet.x,
                    y: waterLevel,
                    radius: 0,
                    maxRadius: (50 + bass * 100) * this.scaleFactor,
                    life: 1.0,
                    colorIndex: droplet.colorIndex
                });
            } else if (droplet.y < waterLevel) {
                // Draw falling droplet
                const colorStr = this.getColor(droplet.colorIndex, magnitudes.length);
                const color = this.parseRgbColor(colorStr);

                // Make it water-colored
                const waterR = Math.max(0, color[0] - 50);
                const waterG = Math.min(255, color[1] + 30);
                const waterB = Math.min(255, color[2] + 80);

                // Draw droplet with motion blur
                this.ctx.fillStyle = `rgba(${waterR}, ${waterG}, ${waterB}, 0.7)`;
                this.ctx.beginPath();
                this.ctx.ellipse(droplet.x, droplet.y, droplet.size * 0.6, droplet.size, 0, 0, Math.PI * 2);
                this.ctx.fill();

                // Highlight
                this.ctx.fillStyle = `rgba(${Math.min(255, waterR + 100)}, ${Math.min(255, waterG + 100)}, 255, 0.6)`;
                this.ctx.beginPath();
                this.ctx.arc(droplet.x - droplet.size * 0.2, droplet.y - droplet.size * 0.2, droplet.size * 0.3, 0, Math.PI * 2);
                this.ctx.fill();

                newDroplets.push(droplet);
            }
        }
        this.waterDroplets = newDroplets;

        // Update and draw splash particles
        const newSplashes = [];
        for (const splash of this.waterSplashes) {
            splash.x += splash.vx;
            splash.y += splash.vy;
            splash.vy += 0.3 * this.scaleFactor; // Gravity
            splash.life -= 0.02;

            if (splash.life > 0 && splash.y < waterLevel + 50 * this.scaleFactor) {
                const colorStr = this.getColor(splash.colorIndex, magnitudes.length);
                const color = this.parseRgbColor(colorStr);

                const waterR = Math.max(0, color[0] - 50);
                const waterG = Math.min(255, color[1] + 30);
                const waterB = Math.min(255, color[2] + 80);

                const alpha = splash.life * 0.7;
                const size = splash.size * splash.life;

                this.ctx.fillStyle = `rgba(${waterR}, ${waterG}, ${waterB}, ${alpha})`;
                this.ctx.beginPath();
                this.ctx.arc(splash.x, splash.y, size, 0, Math.PI * 2);
                this.ctx.fill();

                newSplashes.push(splash);
            }
        }
        this.waterSplashes = newSplashes;

        // Update and draw ripples
        const newRipples = [];
        for (const ripple of this.waterRipples) {
            ripple.radius += (ripple.maxRadius / 50) * this.scaleFactor;
            ripple.life -= 0.015;

            if (ripple.life > 0 && ripple.radius < ripple.maxRadius) {
                const colorStr = this.getColor(ripple.colorIndex, magnitudes.length);
                const color = this.parseRgbColor(colorStr);

                const waterR = Math.max(0, color[0] - 50);
                const waterG = Math.min(255, color[1] + 30);
                const waterB = Math.min(255, color[2] + 80);

                // Draw multiple concentric ripples
                for (let i = 0; i < rippleCount; i++) {
                    const rippleRadius = ripple.radius - i * 20 * this.scaleFactor;
                    if (rippleRadius > 0) {
                        const alpha = ripple.life * (0.3 - i * 0.05);
                        const lineWidth = (2 + mids * 3) * this.scaleFactor;

                        this.ctx.strokeStyle = `rgba(${waterR}, ${waterG}, ${waterB}, ${alpha})`;
                        this.ctx.lineWidth = lineWidth;
                        this.ctx.beginPath();
                        this.ctx.arc(ripple.x, ripple.y, rippleRadius, 0, Math.PI * 2);
                        this.ctx.stroke();

                        // Bright highlight
                        this.ctx.strokeStyle = `rgba(${Math.min(255, waterR + 100)}, ${Math.min(255, waterG + 100)}, 255, ${alpha * 0.5})`;
                        this.ctx.lineWidth = lineWidth * 0.5;
                        this.ctx.stroke();
                    }
                }

                newRipples.push(ripple);
            }
        }
        this.waterRipples = newRipples;

        // Draw water surface
        this.ctx.strokeStyle = `rgba(${waterColor1[0]}, ${waterColor1[1]}, ${waterColor1[2]}, 0.3)`;
        this.ctx.lineWidth = 2 * this.scaleFactor;
        this.ctx.beginPath();

        for (let x = 0; x <= this.canvas.width; x += 5) {
            const wave = Math.sin(x * 0.02 + this.frameCounter * 0.1) * 5 * this.scaleFactor * mids;
            const y = waterLevel + wave;
            if (x === 0) this.ctx.moveTo(x, y);
            else this.ctx.lineTo(x, y);
        }
        this.ctx.stroke();

        // Add shimmer effect on water surface
        if (treble > 0.5) {
            const numShimmers = Math.floor(3 + treble * 7);
            for (let i = 0; i < numShimmers; i++) {
                const x = Math.random() * this.canvas.width;
                const size = (5 + Math.random() * 15) * this.scaleFactor;

                const gradient = this.ctx.createRadialGradient(x, waterLevel, 0, x, waterLevel, size);
                gradient.addColorStop(0, `rgba(${Math.min(255, waterColor2[0] + 100)}, ${Math.min(255, waterColor2[1] + 100)}, 255, 0.4)`);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(x, waterLevel, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        this.frameCounter = (this.frameCounter || 0) + 1;
    }

    /**
     * Mode 378: Succulent Rosette
     * Mode 378: Succulent plant rosette pattern
     */
        render378SucculentRosette(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 379: Salmon Upstream
     * Mode 379: Salmon swimming upstream
     */
        render379SalmonUpstream(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numWaves = Math.floor(8 * complexity);
        for (let i = 0; i < numWaves; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const baseY = this.centerY + (i - numWaves / 2) * 20;

            const hue = ((i * 40 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.lineWidth = 2 + magnitude * 3 * intensity;
            this.ctx.beginPath();

            for (let x = 0; x < this.canvas.width; x += 10) {
                const y = baseY + Math.sin(x * 0.02 + this.frameCounter * 0.05 * speed + i) * magnitude * 50 * intensity;
                if (x === 0) this.ctx.moveTo(x, y);
                else this.ctx.lineTo(x, y);
            }
            this.ctx.stroke();
        }
    }

    /**
     * Mode 380: Cloud Formation
     * Mode 380: Clouds forming and dispersing
     */
        render380CloudFormation(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 381: Fox Tail
     * Mode 381: Fox tail swishing
     */
        render381FoxTail(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 382: Clover Field
     * Mode 382: Field of four-leaf clovers
     */
        render382CloverField(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 383: Geyser Field
     * Mode 383: Multiple geysers erupting
     */
        render383GeyserField(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 384: Insect Compound Eye
     * Mode 384: Compound eye of an insect
     */
        render384InsectCompoundEye(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 385: Moonflower Bloom
     * Mode 385: Moonflower blooming at night
     */
        render385MoonflowerBloom(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 386: Sand Dollar
     * Mode 386: Sand dollar pattern
     */
        render386SandDollar(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 387: Glacier Crevasse
     * Mode 387: Deep crevasse in glacier
     */
        render387GlacierCrevasse(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 388: Antler Growth
     * Mode 388: Deer antler branching pattern
     */
        render388AntlerGrowth(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 389: Plume Worm
     * Mode 389: Feather duster worm plume
     */
        render389PlumeWorm(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 390: Reed Marsh
     * Mode 390: Reeds swaying in marsh
     */
        render390ReedMarsh(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 391: Beetle Shell
     * Mode 391: Iridescent beetle shell pattern
     */
        render391BeetleShell(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 392: Tide Anemone
     * Mode 392: Sea anemone in tidal zone
     */
        render392TideAnemone(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 393: Earthquake Waves
     * Mode 393: Seismic waves propagating
     */
        render393EarthquakeWaves(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 394: Butterfly Lifecycle
     * Mode 394: Butterfly metamorphosis stages
     */
        render394ButterflyLifecycle(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 395: Coconut Palm
     * Mode 395: Palm tree with coconuts
     */
        render395CoconutPalm(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 396: Frost Ferns
     * Mode 396: Frost fern patterns on window
     */
        render396FrostFerns(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 397: Bioluminescent Bay
     * Mode 397: Bioluminescent organisms in bay
     */
        render397BioluminescentBay(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 398: Erosion Patterns
     * Mode 398: Water erosion creating patterns
     */
        render398ErosionPatterns(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 399: Hedge Maze
     * Mode 399: Hedge maze from above
     */
        render399HedgeMaze(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 400: Water Lily Reflection
     * Mode 400: Water lily with mirror reflection
     */
        render701BinaryRain(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 702: Hexadecimal Grid
     * Mode 702: Hexadecimal grid visualization
     */
        render702HexadecimalGrid(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 703: Circuit Board
     * Mode 703: Circuit board visualization
     */
        render703CircuitBoard(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 704: Data Flow
     * Mode 704: Data flow visualization
     */
        render704DataFlow(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 705: Packet Transmission
     * Mode 705: Packet transmission visualization
     */
        render705PacketTransmission(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 706: Network Topology
     * Mode 706: Network topology visualization
     */
        render706NetworkTopology(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 707: Server Cluster
     * Mode 707: Server cluster visualization
     */
        render707ServerCluster(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 708: Cloud Computing
     * Mode 708: Cloud computing visualization
     */
        render708CloudComputing(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 709: Distributed System
     * Mode 709: Distributed system visualization
     */
        render709DistributedSystem(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 710: Peer To Peer
     * Mode 710: Peer-to-peer visualization
     */
        render710PeerToPeer(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 711: Blockchain
     * Mode 711: Blockchain visualization
     */
        render711Blockchain(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 712: Hash Function
     * Mode 712: Hash function visualization
     */
        render712HashFunction(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 713: Encryption
     * Mode 713: Encryption visualization
     */
        render713Encryption(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 714: Public Key
     * Mode 714: Public key visualization
     */
        render714PublicKey(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 715: Digital Signature
     * Mode 715: Digital signature visualization
     */
        render715DigitalSignature(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 716: Zero Knowledge Proof
     * Mode 716: Zero knowledge proof visualization
     */
        render716ZeroKnowledgeProof(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 717: Homomorphic Encryption
     * Mode 717: Homomorphic encryption visualization
     */
        render717HomomorphicEncryption(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 718: Secure Multiparty Computation
     * Mode 718: Secure multiparty computation visualization
     */
        render718SecureMultipartyComputation(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 719: Differential Privacy
     * Mode 719: Differential privacy visualization
     */
        render719DifferentialPrivacy(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 720: Federated Learning
     * Mode 720: Federated learning visualization
     */
        render720FederatedLearning(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 721: Neural Network
     * Mode 721: Neural network visualization
     */
        render721NeuralNetwork(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 722: Deep Learning
     * Mode 722: Deep learning visualization
     */
        render722DeepLearning(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 723: Convolutional Layer
     * Mode 723: Convolutional layer visualization
     */
        render723ConvolutionalLayer(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 724: Recurrent Connection
     * Mode 724: Recurrent connection visualization
     */
        render724RecurrentConnection(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numWaves = Math.floor(8 * complexity);
        for (let i = 0; i < numWaves; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const baseY = this.centerY + (i - numWaves / 2) * 20;

            const hue = ((i * 40 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.lineWidth = 2 + magnitude * 3 * intensity;
            this.ctx.beginPath();

            for (let x = 0; x < this.canvas.width; x += 10) {
                const y = baseY + Math.sin(x * 0.02 + this.frameCounter * 0.05 * speed + i) * magnitude * 50 * intensity;
                if (x === 0) this.ctx.moveTo(x, y);
                else this.ctx.lineTo(x, y);
            }
            this.ctx.stroke();
        }
    }

    /**
     * Mode 725: Attention Mechanism
     * Mode 725: Attention mechanism visualization
     */
        render725AttentionMechanism(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 726: Transformer Architecture
     * Mode 726: Transformer architecture visualization
     */
        render726TransformerArchitecture(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 727: Residual Connection
     * Mode 727: Residual connection visualization
     */
        render727ResidualConnection(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 728: Skip Connection
     * Mode 728: Skip connection visualization
     */
        render728SkipConnection(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 729: Batch Normalization
     * Mode 729: Batch normalization visualization
     */
        render729BatchNormalization(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 730: Dropout Regularization
     * Mode 730: Dropout regularization visualization
     */
        render730DropoutRegularization(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 731: Activation Function
     * Mode 731: Activation function visualization
     */
        render731ActivationFunction(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 732: Gradient Descent
     * Mode 732: Gradient descent visualization
     */
        render732GradientDescent(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 733: Backpropagation
     * Mode 733: Backpropagation visualization
     */
        render733Backpropagation(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 734: Loss Landscape
     * Mode 734: Loss landscape visualization
     */
        render734LossLandscape(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 735: Optimizer Trajectory
     * Mode 735: Optimizer trajectory visualization
     */
        render735OptimizerTrajectory(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 736: Learning Rate Schedule
     * Mode 736: Learning rate schedule visualization
     */
        render736LearningRateSchedule(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 737: Momentum
     * Mode 737: Momentum visualization
     */
        render737Momentum(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 738: Adaptive Learning
     * Mode 738: Adaptive learning visualization
     */
        render738AdaptiveLearning(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 739: Weight Decay
     * Mode 739: Weight decay visualization
     */
        render739WeightDecay(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 740: Early Stopping
     * Mode 740: Early stopping visualization
     */
        render740EarlyStopping(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 741: Cross Validation
     * Mode 741: Cross validation visualization
     */
        render741CrossValidation(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 742: Ensemble Method
     * Mode 742: Ensemble method visualization
     */
        render742EnsembleMethod(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 743: Boosting
     * Mode 743: Boosting visualization
     */
        render743Boosting(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 744: Bagging
     * Mode 744: Bagging visualization
     */
        render744Bagging(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 745: Random Forest
     * Mode 745: Random forest visualization
     */
        render745RandomForest(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 746: Decision Tree
     * Mode 746: Decision tree visualization
     */
        render746DecisionTree(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numElements = Math.floor(20 * complexity);
        for (let i = 0; i < numElements; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numElements) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const radius = this.maxRadius * (0.3 + magnitude * 0.5) * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + magnitude * 8 * intensity;
            const hue = ((i * 15 + this.frameCounter) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.7, 0.8);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.4 + magnitude * 0.6})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    /**
     * Mode 747: Support Vector Machine
     * Mode 747: Support vector machine visualization
     */
        render747SupportVectorMachine(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 748: Kernel Trick
     * Mode 748: Kernel trick visualization
     */
        render748KernelTrick(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 749: Feature Space
     * Mode 749: Feature space visualization
     */
        render749FeatureSpace(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 750: Dimensionality Reduction
     * Mode 750: Dimensionality reduction visualization
     */
        render750DimensionalityReduction(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 751: Principal Component Analysis
     * Mode 751: Principal component analysis visualization
     */
        render751PrincipalComponentAnalysis(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 752: T Sne Embedding
     * Mode 752: T-sne embedding visualization
     */
        render752TSneEmbedding(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 753: Autoencoder Latent Space
     * Mode 753: Autoencoder latent space visualization
     */
        render753AutoencoderLatentSpace(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 754: Variational Autoencoder
     * Mode 754: Variational autoencoder visualization
     */
        render754VariationalAutoencoder(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 755: Generative Adversarial Network
     * Mode 755: Generative adversarial network visualization
     */
        render755GenerativeAdversarialNetwork(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 756: Discriminator Network
     * Mode 756: Discriminator network visualization
     */
        render756DiscriminatorNetwork(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 757: Generator Network
     * Mode 757: Generator network visualization
     */
        render757GeneratorNetwork(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 758: Style Transfer
     * Mode 758: Style transfer visualization
     */
        render758StyleTransfer(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 759: Content Loss
     * Mode 759: Content loss visualization
     */
        render759ContentLoss(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 760: Gram Matrix
     * Mode 760: Gram matrix visualization
     */
        render760GramMatrix(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 761: Perceptual Loss
     * Mode 761: Perceptual loss visualization
     */
        render761PerceptualLoss(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 762: Adversarial Loss
     * Mode 762: Adversarial loss visualization
     */
        render762AdversarialLoss(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 763: Cycle Consistency
     * Mode 763: Cycle consistency visualization
     */
        render763CycleConsistency(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 764: Identity Loss
     * Mode 764: Identity loss visualization
     */
        render764IdentityLoss(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 765: Reconstruction Loss
     * Mode 765: Reconstruction loss visualization
     */
        render765ReconstructionLoss(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 766: Kl Divergence
     * Mode 766: Kl divergence visualization
     */
        render766KlDivergence(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 767: Wasserstein Distance
     * Mode 767: Wasserstein distance visualization
     */
        render767WassersteinDistance(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 768: Earth Mover Distance
     * Mode 768: Earth mover distance visualization
     */
        render768EarthMoverDistance(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 769: Inception Score
     * Mode 769: Inception score visualization
     */
        render769InceptionScore(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 770: Frechet Inception Distance
     * Mode 770: Frechet inception distance visualization
     */
        render770FrechetInceptionDistance(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 771: Bleu Score
     * Mode 771: Bleu score visualization
     */
        render771BleuScore(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 772: Rouge Score
     * Mode 772: Rouge score visualization
     */
        render772RougeScore(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 773: Perplexity
     * Mode 773: Perplexity visualization
     */
        render773Perplexity(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 774: Cross Entropy
     * Mode 774: Cross entropy visualization
     */
        render774CrossEntropy(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 775: Mutual Information
     * Mode 775: Mutual information visualization
     */
        render775MutualInformation(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 776: Information Bottleneck
     * Mode 776: Information bottleneck visualization
     */
        render776InformationBottleneck(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 777: Rate Distortion
     * Mode 777: Rate distortion visualization
     */
        render777RateDistortion(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 778: Source Coding
     * Mode 778: Source coding visualization
     */
        render778SourceCoding(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 779: Channel Coding
     * Mode 779: Channel coding visualization
     */
        render779ChannelCoding(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 780: Error Correction
     * Mode 780: Error correction visualization
     */
        render780ErrorCorrection(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 781: Hamming Distance
     * Mode 781: Hamming distance visualization
     */
        render781HammingDistance(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 782: Reed Solomon
     * Mode 782: Reed solomon visualization
     */
        render782ReedSolomon(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 783: Turbo Code
     * Mode 783: Turbo code visualization
     */
        render783TurboCode(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 784: Ldpc Code
     * Mode 784: Ldpc code visualization
     */
        render784LdpcCode(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 785: Polar Code
     * Mode 785: Polar code visualization
     */
        render785PolarCode(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 786: Quantum Error Correction
     * Mode 786: Quantum error correction visualization
     */
        render786QuantumErrorCorrection(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 787: Surface Code
     * Mode 787: Surface code visualization
     */
        render787SurfaceCode(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 788: Toric Code
     * Mode 788: Toric code visualization
     */
        render788ToricCode(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 789: Color Code
     * Mode 789: Color code visualization
     */
        render789ColorCode(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 790: Stabilizer Formalism
     * Mode 790: Stabilizer formalism visualization
     */
        render790StabilizerFormalism(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 791: Clifford Gate
     * Mode 791: Clifford gate visualization
     */
        render791CliffordGate(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 792: Pauli Group
     * Mode 792: Pauli group visualization
     */
        render792PauliGroup(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numParticles = Math.floor(30 * complexity);
        for (let i = 0; i < numParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numParticles) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const distance = this.maxRadius * (0.5 + Math.sin(this.frameCounter * 0.03 + i) * 0.3) * magnitude * intensity;

            const x = this.centerX + Math.cos(angle) * distance;
            const y = this.centerY + Math.sin(angle) * distance;

            const size = 1 + magnitude * 4 * intensity;
            const hue = ((i * 10 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.3 + magnitude * 0.7})`;
            this.ctx.shadowBlur = 8 * intensity;
            this.ctx.shadowColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }

    /**
     * Mode 793: Measurement Based Quantum Computing
     * Mode 793: Measurement based quantum computing visualization
     */
        render793MeasurementBasedQuantumComputing(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 794: One Way Quantum Computer
     * Mode 794: One way quantum computer visualization
     */
        render794OneWayQuantumComputer(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 795: Adiabatic Quantum Computation
     * Mode 795: Adiabatic quantum computation visualization
     */
        render795AdiabaticQuantumComputation(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 796: Quantum Annealing
     * Mode 796: Quantum annealing visualization
     */
        render796QuantumAnnealing(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 797: Variational Quantum Eigensolver
     * Mode 797: Variational quantum eigensolver visualization
     */
        render797VariationalQuantumEigensolver(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 798: Quantum Approximate Optimization
     * Mode 798: Quantum approximate optimization visualization
     */
        render798QuantumApproximateOptimization(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 799: Quantum Phase Estimation
     * Mode 799: Quantum phase estimation visualization
     */
        render799QuantumPhaseEstimation(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 800: Quantum Fourier Transform
     * Mode 800: Quantum fourier transform visualization
     */
        render800QuantumFourierTransform(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numLines = Math.floor(15 * complexity);
        for (let i = 0; i < numLines; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const angle = (i / numLines) * Math.PI * 2;
            const length = (50 + magnitude * 200) * intensity;

            const x1 = this.centerX + Math.cos(angle) * 30;
            const y1 = this.centerY + Math.sin(angle) * 30;
            const x2 = this.centerX + Math.cos(angle) * length;
            const y2 = this.centerY + Math.sin(angle) * length;

            const hue = ((i * 25 + this.frameCounter * 0.5) % 360) / 360;
            const rgb = this.hsvToRgb(hue, 0.8, 0.9);

            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.5 + magnitude * 0.5})`;
            this.ctx.lineWidth = 2 * intensity;
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }
    }

    /**
     * Mode 801: Mandala
     * Mode 801: Mandala visualization
     */
    render801Mandala(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 802: Yantra
     * Mode 802: Yantra visualization
     */
    render802Yantra(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 803: Lotus
     * Mode 803: Lotus visualization
     */
    render803Lotus(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 804: Om Symbol
     * Mode 804: Om symbol visualization
     */
    render804OmSymbol(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 805: Chakra
     * Mode 805: Chakra visualization
     */
    render805Chakra(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 806: Aura Field
     * Mode 806: Aura field visualization
     */
    render806AuraField(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 807: Third Eye
     * Mode 807: Third eye visualization
     */
    render807ThirdEye(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 808: Kundalini
     * Mode 808: Kundalini visualization
     */
    render808Kundalini(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 809: Merkaba
     * Mode 809: Merkaba visualization
     */
    render809Merkaba(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 810: Flower Of Life
     * Mode 810: Flower of life visualization
     */
    render810FlowerOfLife(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 811: Seed Of Life
     * Mode 811: Seed of life visualization
     */
    render811SeedOfLife(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 812: Tree Of Life
     * Mode 812: Tree of life visualization
     */
    render812TreeOfLife(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        // Use settings for modular control
        const circleCount = this.settings.circleCount || 50;
        const barCount = this.settings.barCount || 72;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        // Ring-based pattern - numRings affected by circleCount
        const numRings = Math.max(3, Math.floor(5 * complexity / 5 * (circleCount / 50)));

        // Calculate total number of circles for color distribution
        let totalCircles = 0;
        for (let ring = 0; ring < numRings; ring++) {
            totalCircles += 6 + ring * 4 * (barCount / 72);
        }

        let circleIndex = 0;

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            // numPoints affected by barCount
            const numPoints = Math.floor((6 + ring * 4) * (barCount / 72));

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;

                // Use color scheme instead of hard-coded HSV
                const baseColor = this.getColor(circleIndex, totalCircles);
                const match = baseColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                let r = 150, g = 150, b = 200;
                if (match) {
                    r = parseInt(match[1]);
                    g = parseInt(match[2]);
                    b = parseInt(match[3]);
                }

                // Brighten based on magnitude
                const brightnessFactor = 0.6 + mag * 0.6;
                r = Math.min(255, Math.floor(r * brightnessFactor));
                g = Math.min(255, Math.floor(g * brightnessFactor));
                b = Math.min(255, Math.floor(b * brightnessFactor));

                this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();

                circleIndex++;
            }
        }
    }

    /**
     * Mode 813: Metatron Cube
     * Mode 813: Metatron cube visualization
     */
    render813MetatronCube(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 814: Sri Yantra
     * Mode 814: Sri yantra visualization
     */
    render814SriYantra(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 815: Shri Yantra
     * Mode 815: Shri yantra visualization
     */
    render815ShriYantra(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 816: Tibetan Sand Mandala
     * Mode 816: Tibetan sand mandala visualization
     */
    render816TibetanSandMandala(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 817: Zen Circle
     * Mode 817: Zen circle visualization
     */
    render817ZenCircle(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 818: Yin Yang
     * Mode 818: Yin yang visualization
     */
    render818YinYang(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 819: Tao Symbol
     * Mode 819: Tao symbol visualization
     */
    render819TaoSymbol(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 820: Bagua
     * Mode 820: Bagua visualization
     */
    render820Bagua(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 821: I Ching Hexagram
     * Mode 821: I ching hexagram visualization
     */
    render821IChingHexagram(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 822: Trigram
     * Mode 822: Trigram visualization
     */
    render822Trigram(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 823: Medicine Wheel
     * Mode 823: Medicine wheel visualization
     */
    render823MedicineWheel(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 824: Dreamcatcher
     * Mode 824: Dreamcatcher visualization
     */
    render824Dreamcatcher(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 825: Totem
     * Mode 825: Totem visualization
     */
    render825Totem(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 826: Spirit Animal
     * Mode 826: Spirit animal visualization
     */
    render826SpiritAnimal(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 827: Shamanic Journey
     * Mode 827: Shamanic journey visualization
     */
    render827ShamanicJourney(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 828: Ayahuasca Vision
     * Mode 828: Ayahuasca vision visualization
     */
    render828AyahuascaVision(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 829: Dmt Realm
     * Mode 829: Dmt realm visualization
     */
    render829DmtRealm(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 830: Astral Projection
     * Mode 830: Astral projection visualization
     */
    render830AstralProjection(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 831: Out Of Body Experience
     * Mode 831: Out of body experience visualization
     */
    render831OutOfBodyExperience(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 832: Near Death Experience
     * Mode 832: Near death experience visualization
     */
    render832NearDeathExperience(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 833: Tunnel Of Light
     * Mode 833: Tunnel of light visualization
     */
    render833TunnelOfLight(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 834: Life Review
     * Mode 834: Life review visualization
     */
    render834LifeReview(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 835: Soul Retrieval
     * Mode 835: Soul retrieval visualization
     */
    render835SoulRetrieval(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 836: Past Life Regression
     * Mode 836: Past life regression visualization
     */
    render836PastLifeRegression(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 837: Akashic Records
     * Mode 837: Akashic records visualization
     */
    render837AkashicRecords(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 838: Collective Unconscious
     * Mode 838: Collective unconscious visualization
     */
    render838CollectiveUnconscious(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 839: Archetypal Realm
     * Mode 839: Archetypal realm visualization
     */
    render839ArchetypalRealm(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 840: Synchronicity
     * Mode 840: Synchronicity visualization
     */
    render840Synchronicity(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 841: Meaningful Coincidence
     * Mode 841: Meaningful coincidence visualization
     */
    render841MeaningfulCoincidence(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 842: Serendipity
     * Mode 842: Serendipity visualization
     */
    render842Serendipity(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 843: Providence
     * Mode 843: Providence visualization
     */
    render843Providence(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 844: Fate
     * Mode 844: Fate visualization
     */
    render844Fate(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 845: Destiny
     * Mode 845: Destiny visualization
     */
    render845Destiny(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 846: Karma
     * Mode 846: Karma visualization
     */
    render846Karma(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 847: Dharma
     * Mode 847: Dharma visualization
     */
    render847Dharma(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 848: Samsara
     * Mode 848: Samsara visualization
     */
    render848Samsara(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 849: Nirvana
     * Mode 849: Nirvana visualization
     */
    render849Nirvana(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 850: Enlightenment
     * Mode 850: Enlightenment visualization
     */
    render850Enlightenment(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 851: Samadhi
     * Mode 851: Samadhi visualization
     */
    render851Samadhi(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 852: Satori
     * Mode 852: Satori visualization
     */
    render852Satori(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 853: Kensho
     * Mode 853: Kensho visualization
     */
    render853Kensho(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 854: Moksha
     * Mode 854: Moksha visualization
     */
    render854Moksha(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 855: Liberation
     * Mode 855: Liberation visualization
     */
    render855Liberation(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 856: Self Realization
     * Mode 856: Self realization visualization
     */
    render856SelfRealization(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 857: God Consciousness
     * Mode 857: God consciousness visualization
     */
    render857GodConsciousness(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 858: Cosmic Consciousness
     * Mode 858: Cosmic consciousness visualization
     */
    render858CosmicConsciousness(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 859: Unity Consciousness
     * Mode 859: Unity consciousness visualization
     */
    render859UnityConsciousness(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 860: Non Dual Awareness
     * Mode 860: Non-dual awareness visualization
     */
    render860NonDualAwareness(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 861: Witness Consciousness
     * Mode 861: Witness consciousness visualization
     */
    render861WitnessConsciousness(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 862: Pure Awareness
     * Mode 862: Pure awareness visualization
     */
    render862PureAwareness(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 863: Presence
     * Mode 863: Presence visualization
     */
    render863Presence(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 864: Now Moment
     * Mode 864: Now moment visualization
     */
    render864NowMoment(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 865: Eternal Present
     * Mode 865: Eternal present visualization
     */
    render865EternalPresent(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 866: Timeless Being
     * Mode 866: Timeless being visualization
     */
    render866TimelessBeing(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 867: Infinite Space
     * Mode 867: Infinite space visualization
     */
    render867InfiniteSpace(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 868: Boundless Compassion
     * Mode 868: Boundless compassion visualization
     */
    render868BoundlessCompassion(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 869: Unconditional Love
     * Mode 869: Unconditional love visualization
     */
    render869UnconditionalLove(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 870: Divine Grace
     * Mode 870: Divine grace visualization
     */
    render870DivineGrace(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 871: Holy Spirit
     * Mode 871: Holy spirit visualization
     */
    render871HolySpirit(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 872: Shekinah
     * Mode 872: Shekinah visualization
     */
    render872Shekinah(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 873: Divine Feminine
     * Mode 873: Divine feminine visualization
     */
    render873DivineFeminine(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 874: Goddess Energy
     * Flowing ethereal energy with graceful ribbons and divine aura
     */
    render874GoddessEnergy(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const flowSpeed = params.flowSpeed !== undefined ? params.flowSpeed : 1.2;
        const ribbonCount = params.ribbonCount !== undefined ? params.ribbonCount : 6;
        const auraSize = params.auraSize !== undefined ? params.auraSize : 1;
        const gracefulness = params.gracefulness !== undefined ? params.gracefulness : 1;
        const glowIntensity = params.glowIntensity !== undefined ? params.glowIntensity : 30;

        // Use Step 4 settings
        const barCount = this.settings.barCount || 72;
        const innerRadius = this.getEffectiveInnerRadius();

        // Initialize animation time
        this.frameCounter = (this.frameCounter || 0) + flowSpeed * 0.3;

        // Calculate energy
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Clear canvas for transparent background (no background fill)
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Divine aura (central glow that pulses with energy)
        const auraPulse = (Math.sin(this.frameCounter * 0.1) + 1) / 2;
        const auraRadius = (innerRadius * 0.5 + energy * innerRadius * 0.5) * auraSize;

        this.ctx.shadowBlur = glowIntensity * 1.5;
        for (let i = 0; i < 4; i++) {
            const layerRadius = auraRadius + i * 20 * auraSize;
            const layerAlpha = (0.15 - i * 0.03) * (0.7 + auraPulse * 0.3);

            const auraColor = this.getColor(Math.floor(barCount / 4 + i * 10), barCount);
            this.ctx.fillStyle = auraColor;
            this.ctx.shadowColor = auraColor;
            this.ctx.globalAlpha = layerAlpha;

            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, layerRadius, 0, Math.PI * 2);
            this.ctx.fill();
        }

        // Flowing energy ribbons
        this.ctx.shadowBlur = glowIntensity;

        for (let r = 0; r < ribbonCount; r++) {
            const ribbonProgress = r / ribbonCount;
            const ribbonAngleOffset = ribbonProgress * Math.PI * 2;

            // Get magnitude for this ribbon
            const magIdx = Math.floor(ribbonProgress * magnitudes.length);
            const magnitude = magnitudes[magIdx] * intensity;

            // Ribbon color from scheme
            const color = this.getColor(Math.floor(r * (barCount / ribbonCount)), barCount);
            this.ctx.strokeStyle = color;
            this.ctx.shadowColor = color;
            this.ctx.lineWidth = 2 + magnitude * 4;
            this.ctx.globalAlpha = 0.6 + magnitude * 0.3;

            // Draw flowing ribbon with graceful curves
            this.ctx.beginPath();

            const numPoints = 50;
            for (let p = 0; p < numPoints; p++) {
                const t = p / numPoints;

                // Spiral outward with graceful flow
                const angle = ribbonAngleOffset + t * Math.PI * 4 * gracefulness + this.frameCounter * 0.05;
                const radius = innerRadius * 0.3 + t * this.maxRadius * 0.7;

                // Add flowing wave motion
                const wave1 = Math.sin(this.frameCounter * 0.1 + r + t * 3) * 20 * gracefulness;
                const wave2 = Math.cos(this.frameCounter * 0.15 + r * 2 + t * 4) * 15 * gracefulness;

                // Audio-reactive amplitude
                const audioWave = magnitude * 30;

                const x = this.centerX + Math.cos(angle) * (radius + wave1 + audioWave);
                const y = this.centerY + Math.sin(angle) * (radius + wave2 + audioWave);

                if (p === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }

            this.ctx.stroke();

            // Add flowing particles along the ribbons
            const particleCount = 3 + Math.floor(magnitude * 5);
            for (let i = 0; i < particleCount; i++) {
                const t = ((this.frameCounter * 0.02 + r * 0.2 + i * 0.15) % 1);

                const angle = ribbonAngleOffset + t * Math.PI * 4 * gracefulness + this.frameCounter * 0.05;
                const radius = innerRadius * 0.3 + t * this.maxRadius * 0.7;

                const wave1 = Math.sin(this.frameCounter * 0.1 + r + t * 3) * 20 * gracefulness;
                const wave2 = Math.cos(this.frameCounter * 0.15 + r * 2 + t * 4) * 15 * gracefulness;
                const audioWave = magnitude * 30;

                const px = this.centerX + Math.cos(angle) * (radius + wave1 + audioWave);
                const py = this.centerY + Math.sin(angle) * (radius + wave2 + audioWave);

                // Particle with glow
                const particleSize = 3 + magnitude * 5;
                this.ctx.fillStyle = color;
                this.ctx.shadowBlur = glowIntensity * 0.8;
                this.ctx.globalAlpha = 0.8;

                this.ctx.beginPath();
                this.ctx.arc(px, py, particleSize, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        // Central goddess core (bright pulsing center)
        const coreSize = 15 + energy * 20;
        const corePulse = (Math.sin(this.frameCounter * 0.15) + 1) / 2;

        this.ctx.shadowBlur = glowIntensity * 2;
        for (let i = 0; i < 3; i++) {
            const layerSize = coreSize + i * 8;
            const coreColor = this.getColor(Math.floor(barCount / 2), barCount);

            this.ctx.fillStyle = coreColor;
            this.ctx.shadowColor = coreColor;
            this.ctx.globalAlpha = (0.8 - i * 0.2) * (0.6 + corePulse * 0.4);

            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, layerSize, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 875: Sacred Masculine
     * Mode 875: Sacred masculine visualization
     */
    render875SacredMasculine(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 876: Hieros Gamos
     * Mode 876: Hieros gamos visualization
     */
    render876HierosGamos(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 877: Alchemical Wedding
     * Mode 877: Alchemical wedding visualization
     */
    render877AlchemicalWedding(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 878: Coniunctio
     * Mode 878: Coniunctio visualization
     */
    render878Coniunctio(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 879: Philosopher Stone
     * Mode 879: Philosopher stone visualization
     */
    render879PhilosopherStone(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 880: Prima Materia
     * Mode 880: Prima materia visualization
     */
    render880PrimaMateria(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 881: Nigredo
     * Mode 881: Nigredo visualization
     */
    render881Nigredo(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 882: Albedo
     * Mode 882: Albedo visualization
     */
    render882Albedo(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 883: Citrinitas
     * Mode 883: Citrinitas visualization
     */
    render883Citrinitas(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 884: Rubedo
     * Mode 884: Rubedo visualization
     */
    render884Rubedo(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 885: Seven Stages
     * Mode 885: Seven stages visualization
     */
    render885SevenStages(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 886: Hermetic Principle
     * Mode 886: Hermetic principle visualization
     */
    render886HermeticPrinciple(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 887: As Above So Below
     * Mode 887: As above so below visualization
     */
    render887AsAboveSoBelow(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 888: Microcosm Macrocosm
     * Mode 888: Microcosm macrocosm visualization
     */
    render888MicrocosmMacrocosm(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 889: Correspondence
     * Mode 889: Correspondence visualization
     */
    render889Correspondence(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 890: Vibration
     * Mode 890: Vibration visualization
     */
    render890Vibration(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 891: Polarity
     * Mode 891: Polarity visualization
     */
    render891Polarity(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 892: Rhythm
     * Mode 892: Rhythm visualization
     */
    render892Rhythm(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 893: Cause And Effect
     * Mode 893: Cause and effect visualization
     */
    render893CauseAndEffect(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 894: Gender Principle
     * Mode 894: Gender principle visualization
     */
    render894GenderPrinciple(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 895: Mentalism
     * Mode 895: Mentalism visualization
     */
    render895Mentalism(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 896: Emerald Tablet
     * Mode 896: Emerald tablet visualization
     */
    render896EmeraldTablet(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Mandala-style pattern with bass reactivity
        const numCircles = Math.floor(12 * complexity / 5);
        const numLayers = Math.floor(3 * complexity / 5);

        for (let i = 0; i < numCircles; i++) {
            const angle = (i / numCircles) * 2 * Math.PI;
            for (let j = 0; j < numLayers; j++) {
                const radius = (60 + j * 50 + bass * 40 * intensity) * (this.canvas.width / 800);
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((i * 15 + j * 40) % 180) * 2; // Convert 0-180 to 0-360
                const color = this.hsvToRgb(hue, 78, 78); // 200/255 * 100  78%

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8 * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 897: Kybalion
     * Mode 897: Kybalion visualization
     */
    render897Kybalion(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 898: Corpus Hermeticum
     * Mode 898: Corpus hermeticum visualization
     */
    render898CorpusHermeticum(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 899: Gnostic Vision
     * Mode 899: Gnostic vision visualization
     */
    render899GnosticVision(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Ring-based pattern
        const numRings = Math.floor(5 * complexity / 5);

        for (let ring = 0; ring < numRings; ring++) {
            const radius = (50 + ring * 60) * (this.canvas.width / 800);
            const numPoints = 6 + ring * 4;

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const magIdx = (ring * 10 + i) % magnitudes.length;
                const mag = magnitudes[magIdx] * intensity;
                const x = this.centerX + Math.cos(angle) * radius;
                const y = this.centerY + Math.sin(angle) * radius;
                const hue = ((ring * 36) % 180) * 2; // Convert 0-180 to 0-360
                const brightness = Math.min(100, (58.8 + mag * 41.2)); // (150 + mag * 105) / 255 * 100
                const color = this.hsvToRgb(hue, 100, brightness);

                this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, (5 + mag * 10) * intensity, 0, 2 * Math.PI);
                this.ctx.fill();
            }
        }
    }

    /**
     * Mode 900: Sophia
     * Mode 900: Sophia visualization
     */
    render900Sophia(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;        // Petal-based rotating pattern
        const numPetals = Math.floor(8 * complexity / 5);

        for (let i = 0; i < numPetals; i++) {
            const angle = (i / numPetals) * 2 * Math.PI + this.frameCounter * 0.05 * speed;
            const magIdx = Math.floor(i * magnitudes.length / numPetals);
            const mag = magnitudes[magIdx] * intensity;
            const radius = (80 + mag * 120) * (this.canvas.width / 800);
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const size = (15 + mag * 35) * intensity;
            const hue = ((i * 22 + this.frameCounter) % 180) * 2; // Convert 0-180 to 0-360
            const color = this.hsvToRgb(hue, 78, 100); // 200/255 * 100  78%

            this.ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }

    /**
     * Mode 901: Spiral Vortex
     * Mode 901: Spiral vortex visualization
     */
    render901SpiralVortex(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            const brightness = Math.floor(100 + mag * 155);

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 902: Concentric Circles
     * Mode 902: Concentric circles visualization
     */
    render902ConcentricCircles(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 903: Expanding Rings
     * Mode 903: Expanding rings visualization
     */
    render903ExpandingRings(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 904: Contracting Circles
     * Mode 904: Contracting circles visualization
     */
    render904ContractingCircles(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (1 - i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 905: Pulsing Orb
     * Mode 905: Pulsing orb visualization
     */
    render905PulsingOrb(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 906: Oscillating Wave
     * Mode 906: Oscillating wave visualization
     */
    render906OscillatingWave(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 907: Pendulum Swing
     * Mode 907: Pendulum swing visualization
     */
    render907PendulumSwing(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numPendulums = Math.floor(complexity * 10);
        for (let i = 0; i < numPendulums; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numPendulums);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 908: Hypnotic Swirl
     * Mode 908: Hypnotic swirl visualization
     */
    render908HypnoticSwirl(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numSwirls = Math.floor(complexity * 10);
        for (let i = 0; i < numSwirls; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numSwirls);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 909: Tunnel Zoom
     * Mode 909: Tunnel zoom visualization
     */
    render909TunnelZoom(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const numCircles = Math.floor(complexity * 10);
        for (let i = 0; i < numCircles; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numCircles);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 910: Perspective Shift
     * Mode 910: Perspective shift visualization
     */
    render910PerspectiveShift(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;

        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 911: Rotating Polygon
     * Mode 911: Rotating polygon visualization
     */
    render911RotatingPolygon(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 912: Morphing Shape
     * Mode 912: Morphing shape visualization
     */
    render912MorphingShape(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 913: Flowing Liquid
     * Mode 913: Flowing liquid visualization
     */
    render913FlowingLiquid(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 914: Ripple Effect
     * Mode 914: Ripple effect visualization
     */
    render914RippleEffect(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 915: Interference Pattern
     * Mode 915: Interference pattern visualization
     */
    render915InterferencePattern(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 916: Moire Effect
     * Mode 916: Moire effect visualization
     */
    render916MoireEffect(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 917: Strobing Light
     * Mode 917: Strobing light visualization
     */
    render917StrobingLight(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 918: Flickering
     * Mode 918: Flickering visualization
     */
    render918Flickering(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 919: Pulsating
     * Mode 919: Pulsating visualization
     */
    render919Pulsating(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 920: Breathing Pattern
     * Mode 920: Breathing pattern visualization
     */
    render920BreathingPattern(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 921: Expansion Contraction
     * Mode 921: Expansion contraction visualization
     */
    render921ExpansionContraction(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 922: Growth Decay
     * Mode 922: Growth decay visualization
     */
    render922GrowthDecay(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 923: Birth Death
     * Mode 923: Birth death visualization
     */
    render923BirthDeath(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 924: Ebb Flow
     * Mode 924: Ebb flow visualization
     */
    render924EbbFlow(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 925: Inhale Exhale
     * Mode 925: Inhale exhale visualization
     */
    render925InhaleExhale(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 926: Systole Diastole
     * Mode 926: Systole diastole visualization
     */
    render926SystoleDiastole(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 927: Tension Release
     * Mode 927: Tension release visualization
     */
    render927TensionRelease(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 928: Charge Discharge
     * Mode 928: Charge discharge visualization
     */
    render928ChargeDischarge(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 929: Loading Unloading
     * Mode 929: Loading unloading visualization
     */
    render929LoadingUnloading(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 930: Compression Rarefaction
     * Mode 930: Compression rarefaction visualization
     */
    render930CompressionRarefaction(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 931: Dense Sparse
     * Mode 931: Dense sparse visualization
     */
    render931DenseSparse(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 932: Thick Thin
     * Mode 932: Thick thin visualization
     */
    render932ThickThin(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 933: Heavy Light
     * Mode 933: Heavy light visualization
     */
    render933HeavyLight(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 934: Dark Bright
     * Mode 934: Dark bright visualization
     */
    render934DarkBright(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 935: Shadow Highlight
     * Mode 935: Shadow highlight visualization
     */
    render935ShadowHighlight(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 936: Positive Negative
     * Mode 936: Positive negative visualization
     */
    render936PositiveNegative(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 937: Convex Concave
     * Mode 937: Convex concave visualization
     */
    render937ConvexConcave(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 938: Inside Outside
     * Mode 938: Inside outside visualization
     */
    render938InsideOutside(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 939: Figure Ground
     * Mode 939: Figure ground visualization
     */
    render939FigureGround(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 940: Foreground Background
     * Mode 940: Foreground background visualization
     */
    render940ForegroundBackground(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 941: Solid Void
     * Mode 941: Solid void visualization
     */
    render941SolidVoid(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 942: Matter Antimatter
     * Mode 942: Matter antimatter visualization
     */
    render942MatterAntimatter(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 943: Particle Wave
     * Mode 943: Particle wave visualization
     */
    render943ParticleWave(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 944: Discrete Continuous
     * Mode 944: Discrete continuous visualization
     */
    render944DiscreteContinuous(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 945: Quantized Smooth
     * Mode 945: Quantized smooth visualization
     */
    render945QuantizedSmooth(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 946: Digital Analog
     * Mode 946: Digital analog visualization
     */
    render946DigitalAnalog(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 947: Binary Fluid
     * Mode 947: Binary fluid visualization
     */
    render947BinaryFluid(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 948: On Off
     * Mode 948: On off visualization
     */
    render948OnOff(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 949: Yes No
     * Mode 949: Yes no visualization
     */
    render949YesNo(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 950: Zero One
     * Mode 950: Zero one visualization
     */
    render950ZeroOne(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 951: Presence Absence
     * Mode 951: Presence absence visualization
     */
    render951PresenceAbsence(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 952: Being Nothingness
     * Mode 952: Being nothingness visualization
     */
    render952BeingNothingness(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 953: Existence Void
     * Mode 953: Existence void visualization
     */
    render953ExistenceVoid(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 954: Form Emptiness
     * Mode 954: Form emptiness visualization
     */
    render954FormEmptiness(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 955: Substance Essence
     * Mode 955: Substance essence visualization
     */
    render955SubstanceEssence(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 956: Appearance Reality
     * Mode 956: Appearance reality visualization
     */
    render956AppearanceReality(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 957: Illusion Truth
     * Mode 957: Illusion truth visualization
     */
    render957IllusionTruth(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 958: Maya Brahman
     * Mode 958: Maya brahman visualization
     */
    render958MayaBrahman(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 959: Phenomena Noumena
     * Mode 959: Phenomena noumena visualization
     */
    render959PhenomenaNoumena(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 960: Relative Absolute
     * Mode 960: Relative absolute visualization
     */
    render960RelativeAbsolute(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 961: Changing Unchanging
     * Mode 961: Changing unchanging visualization
     */
    render961ChangingUnchanging(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 962: Temporal Eternal
     * Mode 962: Temporal eternal visualization
     */
    render962TemporalEternal(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 963: Finite Infinite
     * Mode 963: Finite infinite visualization
     */
    render963FiniteInfinite(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 964: Limited Boundless
     * Mode 964: Limited boundless visualization
     */
    render964LimitedBoundless(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 965: Mortal Immortal
     * Mode 965: Mortal immortal visualization
     */
    render965MortalImmortal(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 966: Perishable Imperishable
     * Mode 966: Perishable imperishable visualization
     */
    render966PerishableImperishable(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 967: Transient Permanent
     * Mode 967: Transient permanent visualization
     */
    render967TransientPermanent(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 968: Fleeting Lasting
     * Mode 968: Fleeting lasting visualization
     */
    render968FleetingLasting(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 969: Ephemeral Enduring
     * Mode 969: Ephemeral enduring visualization
     */
    render969EphemeralEnduring(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 970: Momentary Timeless
     * Mode 970: Momentary timeless visualization
     */
    render970MomentaryTimeless(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 971: Local Universal
     * Mode 971: Local universal visualization
     */
    render971LocalUniversal(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 972: Particular General
     * Mode 972: Particular general visualization
     */
    render972ParticularGeneral(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 973: Specific Generic
     * Mode 973: Specific generic visualization
     */
    render973SpecificGeneric(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 974: Unique Common
     * Mode 974: Unique common visualization
     */
    render974UniqueCommon(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 975: Individual Collective
     * Mode 975: Individual collective visualization
     */
    render975IndividualCollective(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 976: One Many
     * Mode 976: One many visualization
     */
    render976OneMany(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 977: Unity Multiplicity
     * Mode 977: Unity multiplicity visualization
     */
    render977UnityMultiplicity(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 978: Simple Complex
     * Mode 978: Simple complex visualization
     */
    render978SimpleComplex(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 979: Elementary Composite
     * Mode 979: Elementary composite visualization
     */
    render979ElementaryComposite(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 980: Atomic Molecular
     * Mode 980: Atomic molecular visualization
     */
    render980AtomicMolecular(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 981: Fundamental Derived
     * Mode 981: Fundamental derived visualization
     */
    render981FundamentalDerived(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 982: Primary Secondary
     * Mode 982: Primary secondary visualization
     */
    render982PrimarySecondary(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 983: Essential Accidental
     * Mode 983: Essential accidental visualization
     */
    render983EssentialAccidental(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 984: Necessary Contingent
     * Mode 984: Necessary contingent visualization
     */
    render984NecessaryContingent(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 985: A Priori A Posteriori
     * Mode 985: A priori a posteriori visualization
     */
    render985APrioriAPosteriori(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 986: Analytic Synthetic
     * Mode 986: Analytic synthetic visualization
     */
    render986AnalyticSynthetic(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 987: Deductive Inductive
     * Mode 987: Deductive inductive visualization
     */
    render987DeductiveInductive(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 988: Logical Empirical
     * Mode 988: Logical empirical visualization
     */
    render988LogicalEmpirical(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 989: Rational Experiential
     * Mode 989: Rational experiential visualization
     */
    render989RationalExperiential(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 990: Abstract Concrete
     * Mode 990: Abstract concrete visualization
     */
    render990AbstractConcrete(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 991: Theoretical Practical
     * Mode 991: Theoretical practical visualization
     */
    render991TheoreticalPractical(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 992: Ideal Real
     * Mode 992: Ideal real visualization
     */
    render992IdealReal(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 993: Conceptual Actual
     * Mode 993: Conceptual actual visualization
     */
    render993ConceptualActual(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 994: Possible Necessary
     * Mode 994: Possible necessary visualization
     */
    render994PossibleNecessary(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 995: Potential Actual
     * Mode 995: Potential actual visualization
     */
    render995PotentialActual(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 996: Virtual Real
     * Mode 996: Virtual real visualization
     */
    render996VirtualReal(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 997: Simulated Genuine
     * Mode 997: Simulated genuine visualization
     */
    render997SimulatedGenuine(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 998: Artificial Natural
     * Mode 998: Artificial natural visualization
     */
    render998ArtificialNatural(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numRings = Math.floor(complexity * 2);
        for (let r = 0; r < numRings; r++) {
            const radius = 50 + r * 30 + Math.sin(this.frameCounter * 0.1 + r) * bass * 40 * intensity;
            const alpha = (255 - r * (255 / numRings)) / 255;

            const color = this.getColor(r, numRings);
            this.ctx.strokeStyle = color;
            this.ctx.globalAlpha = alpha;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 999: Synthetic Organic
     * Mode 999: Synthetic organic visualization
     */
    render999SyntheticOrganic(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const numElements = Math.floor(complexity * 10);
        for (let i = 0; i < numElements; i++) {
            const magIdx = i % magnitudes.length;
            const mag = magnitudes[magIdx] * intensity;
            const phase = this.frameCounter * 0.05 * speed + i * 0.1;
            const x = this.centerX + Math.sin(phase) * 200 * mag;
            const y = this.centerY + Math.cos(phase * 1.3) * 200 * mag;

            const color = this.getColor(i, numElements);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 1000: Mechanical Living
     * Mode 1000: Mechanical living visualization
     */
    render1000MechanicalLiving(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = params.complexity || 5;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        this.frameCounter = (this.frameCounter || 0) + speed;


        const phase = this.frameCounter * 0.1 * speed;
        for (let i = 0; i < magnitudes.length; i++) {
            const mag = magnitudes[i] * intensity;
            const angle = (i / magnitudes.length) * 4 * Math.PI * complexity + phase;
            const radius = (i / magnitudes.length) * this.maxRadius * mag;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const color = this.getColor(i, magnitudes.length);
            this.ctx.fillStyle = color;
            this.ctx.globalAlpha = mag;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        this.ctx.globalAlpha = 1.0;
    }

    /**
     * Mode 1001: Cassette Tape Deck
     * Retro cassette tape with spinning reels and VU meters
     */
    render1001CassetteTapeDeck(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const glowIntensity = params.glowIntensity !== undefined ? params.glowIntensity : 15;

        // Use Step 4 settings
        const barCount = this.settings.barCount || 72;
        const innerRadius = this.getEffectiveInnerRadius();

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        this.frameCounter = (this.frameCounter || 0) + speed * 2;

        // Cassette body dimensions
        const tapeWidth = Math.min(500, this.canvas.width * 0.7) * (0.8 + innerRadius / 500);
        const tapeHeight = tapeWidth * 0.45;
        const tapeX = this.centerX - tapeWidth / 2;
        const tapeY = this.centerY - tapeHeight / 2;
        const cornerRadius = 8;

        // Get dynamic colors
        const shellColor = this.getColor(0, 3);
        const labelColor = this.getColor(1, 3);
        const accentColor = this.getColor(2, 3);

        // Draw cassette shell with rounded corners
        this.ctx.fillStyle = shellColor.replace('rgb', 'rgba').replace(')', ', 0.95)');
        this.ctx.strokeStyle = shellColor.replace('rgb', 'rgba').replace(')', ', 1)');
        this.ctx.lineWidth = 3;
        this.ctx.beginPath();
        this.ctx.roundRect(tapeX, tapeY, tapeWidth, tapeHeight, cornerRadius);
        this.ctx.fill();
        this.ctx.stroke();

        // Cassette label area (top section)
        this.ctx.fillStyle = labelColor.replace('rgb', 'rgba').replace(')', ', 0.9)');
        this.ctx.fillRect(tapeX + 20, tapeY + 15, tapeWidth - 40, tapeHeight * 0.35);

        // Window for seeing tape (transparent area)
        const windowY = tapeY + tapeHeight * 0.55;
        const windowHeight = tapeHeight * 0.35;
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        this.ctx.fillRect(tapeX + 30, windowY, tapeWidth - 60, windowHeight);

        // Draw screws in corners
        const screwRadius = 4;
        this.ctx.fillStyle = accentColor.replace('rgb', 'rgba').replace(')', ', 0.7)');
        const screwPositions = [
            [tapeX + 15, tapeY + 15],
            [tapeX + tapeWidth - 15, tapeY + 15],
            [tapeX + 15, tapeY + tapeHeight - 15],
            [tapeX + tapeWidth - 15, tapeY + tapeHeight - 15]
        ];
        screwPositions.forEach(([x, y]) => {
            this.ctx.beginPath();
            this.ctx.arc(x, y, screwRadius, 0, Math.PI * 2);
            this.ctx.fill();
            // Screw slot
            this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
            this.ctx.lineWidth = 1.5;
            this.ctx.beginPath();
            this.ctx.moveTo(x - 3, y);
            this.ctx.lineTo(x + 3, y);
            this.ctx.stroke();
        });

        // Enable glow for animated parts
        this.ctx.shadowBlur = glowIntensity;

        // Draw spinning reels
        const reelRadius = tapeHeight * 0.15;
        const reel1X = tapeX + tapeWidth * 0.3;
        const reel2X = tapeX + tapeWidth * 0.7;
        const reelY = windowY + windowHeight / 2;

        // Reel rotation based on audio
        const rotation = this.frameCounter * 0.08 * (1 + energy * 0.5);

        // Draw tape connecting reels
        this.ctx.shadowBlur = 0;
        this.ctx.fillStyle = 'rgba(100, 70, 50, 0.6)';
        const tapeThickness = 6;
        this.ctx.fillRect(reel1X + reelRadius, reelY - tapeThickness / 2,
                         reel2X - reel1X - reelRadius * 2, tapeThickness);

        this.ctx.shadowBlur = glowIntensity;

        // Draw each reel
        for (let idx = 0; idx < 2; idx++) {
            const reelX = idx === 0 ? reel1X : reel2X;
            const color = this.getColor(idx * barCount / 2, barCount);

            this.ctx.shadowColor = color;

            // Outer reel hub
            this.ctx.strokeStyle = color;
            this.ctx.fillStyle = color.replace('rgb', 'rgba').replace(')', ', 0.3)');
            this.ctx.lineWidth = 4;
            this.ctx.beginPath();
            this.ctx.arc(reelX, reelY, reelRadius, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.stroke();

            // Inner hub (darker)
            this.ctx.fillStyle = color.replace('rgb', 'rgba').replace(')', ', 0.7)');
            this.ctx.beginPath();
            this.ctx.arc(reelX, reelY, reelRadius * 0.4, 0, Math.PI * 2);
            this.ctx.fill();

            // Spinning spokes
            const numSpokes = 6;
            this.ctx.lineWidth = 2.5;
            for (let i = 0; i < numSpokes; i++) {
                const angle = rotation + (i / numSpokes) * Math.PI * 2;
                const x1 = reelX + Math.cos(angle) * reelRadius * 0.4;
                const y1 = reelY + Math.sin(angle) * reelRadius * 0.4;
                const x2 = reelX + Math.cos(angle) * reelRadius * 0.85;
                const y2 = reelY + Math.sin(angle) * reelRadius * 0.85;

                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x2, y2);
                this.ctx.stroke();
            }

            // Tape wound on reel (varies with audio)
            const tapeAmount = 0.5 + (idx === 0 ? energy : bass) * 0.3;
            this.ctx.fillStyle = 'rgba(100, 70, 50, 0.5)';
            this.ctx.beginPath();
            this.ctx.arc(reelX, reelY, reelRadius * 0.6 * tapeAmount, 0, Math.PI * 2);
            this.ctx.fill();
        }

        // VU meters (segmented bars with better design)
        const vuBarWidth = tapeWidth * 0.35;
        const vuBarHeight = 20;
        const vuY = tapeY + 25;
        const numSegments = 12;
        const segmentWidth = (vuBarWidth / numSegments) - 2;

        // Left VU meter
        const leftLevel = magnitudes.slice(0, magnitudes.length / 2).reduce((a, b) => a + b, 0) / (magnitudes.length / 2) * intensity;
        const leftSegments = Math.floor(leftLevel * numSegments);
        const leftColor = this.getColor(0, barCount);

        for (let i = 0; i < numSegments; i++) {
            if (i < leftSegments) {
                // Color segments based on level (green->yellow->red)
                let segColor = leftColor;
                if (i > numSegments * 0.75) {
                    segColor = 'rgb(255, 50, 50)'; // Red for peaks
                } else if (i > numSegments * 0.5) {
                    segColor = 'rgb(255, 200, 50)'; // Yellow for mid
                }

                this.ctx.shadowColor = segColor;
                this.ctx.fillStyle = segColor;
                this.ctx.fillRect(tapeX + 30 + i * (segmentWidth + 2), vuY, segmentWidth, vuBarHeight);
            } else {
                // Inactive segments (dimmed)
                this.ctx.shadowBlur = 0;
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.fillRect(tapeX + 30 + i * (segmentWidth + 2), vuY, segmentWidth, vuBarHeight);
                this.ctx.shadowBlur = glowIntensity;
            }
        }

        // Right VU meter
        const rightLevel = magnitudes.slice(magnitudes.length / 2).reduce((a, b) => a + b, 0) / (magnitudes.length / 2) * intensity;
        const rightSegments = Math.floor(rightLevel * numSegments);
        const rightColor = this.getColor(barCount / 2, barCount);

        for (let i = 0; i < numSegments; i++) {
            if (i < rightSegments) {
                // Color segments based on level
                let segColor = rightColor;
                if (i > numSegments * 0.75) {
                    segColor = 'rgb(255, 50, 50)';
                } else if (i > numSegments * 0.5) {
                    segColor = 'rgb(255, 200, 50)';
                }

                this.ctx.shadowColor = segColor;
                this.ctx.fillStyle = segColor;
                this.ctx.fillRect(tapeX + tapeWidth - 30 - vuBarWidth + i * (segmentWidth + 2), vuY, segmentWidth, vuBarHeight);
            } else {
                this.ctx.shadowBlur = 0;
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.fillRect(tapeX + tapeWidth - 30 - vuBarWidth + i * (segmentWidth + 2), vuY, segmentWidth, vuBarHeight);
                this.ctx.shadowBlur = glowIntensity;
            }
        }

        // Add L/R labels
        this.ctx.shadowBlur = 0;
        this.ctx.fillStyle = accentColor;
        this.ctx.font = `bold ${Math.max(10, vuBarHeight * 0.7)}px Arial`;
        this.ctx.fillText('L', tapeX + 12, vuY + vuBarHeight - 5);
        this.ctx.fillText('R', tapeX + tapeWidth - 22, vuY + vuBarHeight - 5);

        this.ctx.shadowBlur = 0;
        this.ctx.globalAlpha = 1;
    }

    /**
     * Mode 1002: Arcade Pixel Bars
     * Chunky 8-bit style bars with retro arcade colors
     */
    render1002ArcadePixelBars(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const pixelSize = params.pixelSize !== undefined ? params.pixelSize : 8;
        const glowIntensity = params.glowIntensity !== undefined ? params.glowIntensity : 15;

        // Use Step 4 settings
        const barCount = this.settings.barCount || 72;
        const innerRadius = this.getEffectiveInnerRadius();

        this.ctx.shadowBlur = glowIntensity;

        // Keep bars chunky on small canvases (previews) by limiting bar count to available pixel width
        const maxBarsForWidth = Math.max(8, Math.floor(this.canvas.width / Math.max(pixelSize, 6)));
        const numBars = Math.min(barCount, magnitudes.length, maxBarsForWidth);
        const barSpacing = this.canvas.width / numBars;

        for (let i = 0; i < numBars; i++) {
            const magIdx = Math.floor((i * magnitudes.length) / numBars);
            const magnitude = magnitudes[magIdx] * intensity;

            // Pixel-perfect bar height
            const maxBarHeight = this.canvas.height * 0.8;
            const barHeight = Math.floor((magnitude * maxBarHeight) / pixelSize) * pixelSize;

            // Arcade-style colors (bright, saturated)
            const color = this.getColor(i, numBars);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;

            // Draw pixelated bar from bottom
            const x = i * barSpacing + barSpacing * 0.1;
            const barWidth = Math.max(
                pixelSize,
                Math.floor(Math.max(barSpacing * 0.8, pixelSize) / pixelSize) * pixelSize
            );
            const y = this.canvas.height - barHeight - (this.canvas.height * 0.1 + innerRadius / 5);

            // Main bar with pixel blocks
            for (let py = 0; py < barHeight; py += pixelSize) {
                this.ctx.fillRect(x, y + py, barWidth, pixelSize - 1);
            }

            // Highlight on top for 3D effect
            if (barHeight > pixelSize) {
                this.ctx.fillStyle = `rgba(255, 255, 255, 0.4)`;
                this.ctx.fillRect(x, y, barWidth, pixelSize);
            }
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 1003: Vector Oscilloscope
     * Classic green oscilloscope with glowing vector lines
     */
    render1003VectorOscilloscope(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity ?? 1;
        const speed = params.speed ?? 1;
        const lineThickness = params.lineThickness ?? 3;
        const glowIntensity = params.glowIntensity ?? 20;

        // Use Step 4 settings
        const barCount = this.settings.numBars || 72;
        const smoothing = this.settings.smoothing ?? 0.85;
        const barWidthMultiplier = this.settings.barWidthMultiplier ?? 1;
        const time = (this.frameCounter || 0) * 0.02 * speed;

        // Get primary color from color scheme (Step 4)
        const primaryColor = this.getColor(0, 1);
        const rgb = primaryColor.match(/\d+/g).map(Number);
        const beamAlpha = Math.min(1, 0.55 + intensity * 0.4);
        const scopeColor = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${beamAlpha})`;

        // CRT screen background with phosphor persistence using background color (Step 4)
        const bgStyle = BACKGROUND_STYLES[this.settings.background] || BACKGROUND_STYLES['transparent'];
        const bgRgb = bgStyle.color;
        const phosphorFade = Math.min(0.35, 0.18 + speed * 0.06);
        // Darken the background color and blend with primary color for phosphor effect
        const phosphorR = Math.floor(bgRgb[0] * 0.3 + rgb[0] * 0.1);
        const phosphorG = Math.floor(bgRgb[1] * 0.3 + rgb[1] * 0.1);
        const phosphorB = Math.floor(bgRgb[2] * 0.3 + rgb[2] * 0.1);
        this.ctx.fillStyle = `rgba(${phosphorR}, ${phosphorG}, ${phosphorB}, ${phosphorFade})`;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw grid (like oscilloscope) using primary color
        this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.05 + intensity * 0.05})`;
        this.ctx.lineWidth = Math.max(0.5, lineThickness * 0.2);
        const gridSpacing = Math.max(35, Math.min(70, this.canvas.width / Math.max(6, barCount / 12)));

        for (let x = 0; x < this.canvas.width; x += gridSpacing) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.canvas.height);
            this.ctx.stroke();
        }
        for (let y = 0; y < this.canvas.height; y += gridSpacing) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.canvas.width, y);
            this.ctx.stroke();
        }

        // Apply smoothing to magnitudes (Step 4)
        const smoothedMagnitudes = new Float32Array(magnitudes.length);
        for (let i = 0; i < magnitudes.length; i++) {
            if (i === 0) {
                smoothedMagnitudes[i] = magnitudes[i];
            } else {
                smoothedMagnitudes[i] = magnitudes[i] * (1 - smoothing) + smoothedMagnitudes[i - 1] * smoothing;
            }
        }

        // Draw waveform
        this.ctx.strokeStyle = scopeColor;
        this.ctx.lineWidth = lineThickness * barWidthMultiplier; // Apply barWidthMultiplier (Step 4)
        this.ctx.shadowBlur = glowIntensity;
        this.ctx.shadowColor = scopeColor;
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';

        const numPoints = Math.min(barCount * 2, magnitudes.length);
        const xStep = this.canvas.width / Math.max(1, numPoints - 1);
        const sweepOffset = (time * 12) % magnitudes.length;

        this.ctx.beginPath();
        for (let i = 0; i < numPoints; i++) {
            const magIdx = Math.floor(((i + sweepOffset) % numPoints) * (magnitudes.length / numPoints));
            const magnitude = (smoothedMagnitudes[magIdx] || 0) * intensity;

            const x = i * xStep;
            const jitter = Math.sin(time + i * 0.35) * 6 * speed;
            const y = this.centerY + (magnitude - 0.5) * this.canvas.height * 0.6 + jitter;

            if (i === 0) {
                this.ctx.moveTo(x, y);
            } else {
                this.ctx.lineTo(x, y);
            }
        }
        this.ctx.stroke();

        // Add second trace for dual-trace effect using gradient colors if enabled
        if (this.settings.gradient) {
            const secondaryColor = this.getColor(1, 2);
            const rgb2 = secondaryColor.match(/\d+/g).map(Number);
            this.ctx.strokeStyle = `rgba(${rgb2[0]}, ${rgb2[1]}, ${rgb2[2]}, 0.5)`;
            this.ctx.shadowColor = secondaryColor;
        } else {
            this.ctx.strokeStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.5)`;
            this.ctx.shadowColor = scopeColor;
        }
        this.ctx.shadowBlur = glowIntensity * 0.5;
        this.ctx.lineWidth = lineThickness * barWidthMultiplier * 0.8; // Slightly thinner for second trace
        this.ctx.beginPath();
        for (let i = 0; i < numPoints; i++) {
            const magIdx = Math.floor(((i + sweepOffset * 0.6) % numPoints) * (magnitudes.length / numPoints));
            const magnitude = (smoothedMagnitudes[magIdx] || 0) * intensity * 0.6;

            const x = i * xStep;
            const y = this.centerY - (magnitude - 0.25) * this.canvas.height * 0.4 + Math.cos(time * 1.3 + i * 0.25) * 4 * speed;

            if (i === 0) {
                this.ctx.moveTo(x, y);
            } else {
                this.ctx.lineTo(x, y);
            }
        }
        this.ctx.stroke();

        // Sweeping beam accent to make speed parameter immediately visible
        const sweepX = (this.canvas.width + (time * this.canvas.width * 0.15)) % this.canvas.width;
        this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${0.05 + speed * 0.08})`;
        this.ctx.fillRect(sweepX, 0, Math.max(2, lineThickness), this.canvas.height);

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 1004: LED Spectrum Grid
     * Old-school LED spectrum analyzer with discrete LED blocks
     */
    render1004LEDSpectrumGrid(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const ledSize = params.ledSize !== undefined ? params.ledSize : 8;
        const ledGap = params.ledGap !== undefined ? params.ledGap : 2;

        // Use Step 4 settings
        const barCount = this.settings.barCount || 72;
        const innerRadius = this.getEffectiveInnerRadius();

        // Background (dark)
        this.ctx.fillStyle = '#0a0a0a';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Calculate grid
        const numColumns = Math.min(barCount, magnitudes.length);
        const columnWidth = (this.canvas.width * 0.9) / numColumns;
        const startX = this.canvas.width * 0.05;

        const maxRows = Math.floor((this.canvas.height * 0.8) / (ledSize + ledGap));
        const startY = this.canvas.height * 0.1 + innerRadius / 10;

        for (let col = 0; col < numColumns; col++) {
            const magIdx = Math.floor((col * magnitudes.length) / numColumns);
            const magnitude = magnitudes[magIdx] * intensity;

            // Number of lit LEDs
            const litLEDs = Math.floor(magnitude * maxRows);

            const x = startX + col * columnWidth;

            for (let row = 0; row < maxRows; row++) {
                const y = this.canvas.height - startY - (row * (ledSize + ledGap));
                const ledX = x + (columnWidth - ledSize) / 2;

                if (row < litLEDs) {
                    // Lit LED - color based on height (green at bottom, yellow mid, red top)
                    let color;
                    const heightRatio = row / maxRows;
                    if (heightRatio < 0.5) {
                        color = this.getColor(col, numColumns);
                    } else if (heightRatio < 0.7) {
                        color = '#ffff00'; // Yellow
                    } else {
                        color = '#ff3000'; // Red
                    }

                    this.ctx.fillStyle = color;
                    this.ctx.shadowBlur = 8;
                    this.ctx.shadowColor = color;
                } else {
                    // Unlit LED (dim)
                    this.ctx.fillStyle = '#222222';
                    this.ctx.shadowBlur = 0;
                }

                // Draw LED rectangle
                this.ctx.fillRect(ledX, y, ledSize, ledSize);
            }
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 1008: Boombox Spectrum
     * Classic 80s boombox with dual speakers and spectrum display
     */
    render1008BoomboxSpectrum(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speakerSize = params.speakerSize !== undefined ? params.speakerSize : 1;
        const glowIntensity = params.glowIntensity !== undefined ? params.glowIntensity : 15;
        const bassResponse = params.bassResponse !== undefined ? params.bassResponse : 1;

        // Use Step 4 settings
        const barCount = this.settings.barCount || 72;
        const innerRadius = this.getEffectiveInnerRadius();

        // Calculate frequency ranges
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Background
        this.ctx.fillStyle = '#1a1a1a';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Boombox dimensions
        const boomboxWidth = Math.min(600, this.canvas.width * 0.85);
        const boomboxHeight = boomboxWidth * 0.5;
        const boomboxX = this.centerX - boomboxWidth / 2;
        const boomboxY = this.centerY - boomboxHeight / 2;

        // Main boombox body
        this.ctx.fillStyle = '#2a2a2a';
        this.ctx.fillRect(boomboxX, boomboxY, boomboxWidth, boomboxHeight);
        this.ctx.strokeStyle = '#444';
        this.ctx.lineWidth = 3;
        this.ctx.strokeRect(boomboxX, boomboxY, boomboxWidth, boomboxHeight);

        // Left speaker
        const speakerRadius = (boomboxHeight * 0.35) * speakerSize;
        const leftSpeakerX = boomboxX + boomboxWidth * 0.2;
        const speakerY = this.centerY;

        // Speaker cone with bass response
        const bassScale = 1 + (bass * bassResponse * 0.3);
        this.ctx.fillStyle = '#0a0a0a';
        this.ctx.beginPath();
        this.ctx.arc(leftSpeakerX, speakerY, speakerRadius * bassScale, 0, Math.PI * 2);
        this.ctx.fill();

        // Speaker rings
        const leftColor = this.getColor(0, barCount);
        this.ctx.strokeStyle = leftColor;
        this.ctx.shadowBlur = glowIntensity * bass;
        this.ctx.shadowColor = leftColor;
        this.ctx.lineWidth = 2;
        for (let i = 0; i < 3; i++) {
            this.ctx.beginPath();
            this.ctx.arc(leftSpeakerX, speakerY, speakerRadius * 0.3 + i * 15, 0, Math.PI * 2);
            this.ctx.stroke();
        }

        // Right speaker
        const rightSpeakerX = boomboxX + boomboxWidth * 0.8;
        this.ctx.fillStyle = '#0a0a0a';
        this.ctx.beginPath();
        this.ctx.arc(rightSpeakerX, speakerY, speakerRadius * bassScale, 0, Math.PI * 2);
        this.ctx.fill();

        const rightColor = this.getColor(barCount / 2, barCount);
        this.ctx.strokeStyle = rightColor;
        this.ctx.shadowColor = rightColor;
        for (let i = 0; i < 3; i++) {
            this.ctx.beginPath();
            this.ctx.arc(rightSpeakerX, speakerY, speakerRadius * 0.3 + i * 15, 0, Math.PI * 2);
            this.ctx.stroke();
        }

        // Center spectrum display
        const displayWidth = boomboxWidth * 0.25;
        const displayHeight = boomboxHeight * 0.5;
        const displayX = this.centerX - displayWidth / 2;
        const displayY = this.centerY - displayHeight / 2;

        // Display background
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(displayX, displayY, displayWidth, displayHeight);

        // Spectrum bars
        this.ctx.shadowBlur = glowIntensity;
        const numBars = Math.min(16, Math.floor(displayWidth / 8));
        const barWidth = displayWidth / numBars;

        for (let i = 0; i < numBars; i++) {
            const magIdx = Math.floor((i * magnitudes.length) / numBars);
            const magnitude = magnitudes[magIdx] * intensity;
            const barHeight = magnitude * displayHeight * 0.9;

            const color = this.getColor(i * (barCount / numBars), barCount);
            this.ctx.fillStyle = color;
            this.ctx.shadowColor = color;

            const x = displayX + i * barWidth + barWidth * 0.1;
            const y = displayY + displayHeight - barHeight - displayHeight * 0.05;
            this.ctx.fillRect(x, y, barWidth * 0.8, barHeight);
        }

        // Volume indicators (knobs)
        const knobRadius = 12;
        const knobY = boomboxY + boomboxHeight * 0.15;

        // Left volume knob
        const leftKnobX = boomboxX + boomboxWidth * 0.35;
        this.ctx.fillStyle = '#333';
        this.ctx.shadowBlur = 0;
        this.ctx.beginPath();
        this.ctx.arc(leftKnobX, knobY, knobRadius, 0, Math.PI * 2);
        this.ctx.fill();

        // Right volume knob
        const rightKnobX = boomboxX + boomboxWidth * 0.65;
        this.ctx.beginPath();
        this.ctx.arc(rightKnobX, knobY, knobRadius, 0, Math.PI * 2);
        this.ctx.fill();

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 1009: Synthwave Grid
     * Classic 1980s synthwave perspective grid with neon sun
     */
    render1009SynthwaveGrid(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const gridLines = params.gridLines !== undefined ? params.gridLines : 16;
        const glowIntensity = params.glowIntensity !== undefined ? params.glowIntensity : 20;

        // Use Step 4 settings
        const barCount = this.settings.barCount || 72;

        // Initialize animation time
        this.frameCounter = (this.frameCounter || 0) + speed;

        // Calculate average energy
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Sky gradient (dark purple to pink)
        const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height * 0.6);
        gradient.addColorStop(0, '#0a0015');
        gradient.addColorStop(0.5, '#1a0033');
        gradient.addColorStop(1, '#330066');
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Sun position and size
        const sunY = this.canvas.height * 0.3;
        const sunRadius = Math.min(100, this.canvas.width * 0.15) * (1 + energy * intensity * 0.3);

        // Draw sun with glow
        this.ctx.shadowBlur = glowIntensity * 2;
        const sunColor = this.getColor(barCount / 4, barCount);
        this.ctx.shadowColor = sunColor;

        // Sun gradient
        const sunGradient = this.ctx.createRadialGradient(
            this.centerX, sunY, sunRadius * 0.3,
            this.centerX, sunY, sunRadius
        );
        sunGradient.addColorStop(0, '#ffff00');
        sunGradient.addColorStop(0.5, '#ff00ff');
        sunGradient.addColorStop(1, '#ff0080');

        this.ctx.fillStyle = sunGradient;
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, sunY, sunRadius, 0, Math.PI * 2);
        this.ctx.fill();

        // Sun stripes (retro effect)
        this.ctx.shadowBlur = 0;
        this.ctx.fillStyle = '#0a0015';
        for (let i = 0; i < 8; i++) {
            const y = sunY - sunRadius + (i * sunRadius * 2 / 7);
            this.ctx.fillRect(this.centerX - sunRadius, y, sunRadius * 2, sunRadius * 0.08);
        }

        // Grid perspective
        const horizonY = this.canvas.height * 0.55;
        const gridStartY = horizonY;
        const gridEndY = this.canvas.height;
        const gridHeight = gridEndY - gridStartY;

        // Enable glow for grid
        this.ctx.shadowBlur = glowIntensity;
        const gridColor = this.getColor(barCount * 0.75, barCount);
        this.ctx.strokeStyle = gridColor;
        this.ctx.shadowColor = gridColor;
        this.ctx.lineWidth = 2;

        // Horizontal grid lines with perspective
        const numHorizontalLines = gridLines;
        const offset = (this.frameCounter * speed * 2) % (gridHeight / numHorizontalLines);

        for (let i = 0; i < numHorizontalLines + 2; i++) {
            const progress = (i * gridHeight / numHorizontalLines + offset) / gridHeight;
            const y = gridStartY + i * gridHeight / numHorizontalLines - offset;

            if (y < gridStartY || y > gridEndY) continue;

            // Get magnitude for this line
            const magIdx = Math.floor((i / numHorizontalLines) * magnitudes.length);
            const magnitude = magnitudes[magIdx % magnitudes.length] * intensity;

            // Perspective width
            const width = this.canvas.width * (0.1 + progress * 0.9);
            const x1 = this.centerX - width / 2;
            const x2 = this.centerX + width / 2;

            // Line y-position can wave based on magnitude
            const yWave = y + Math.sin(this.frameCounter * 0.05 + i) * magnitude * 10;

            this.ctx.beginPath();
            this.ctx.moveTo(x1, yWave);
            this.ctx.lineTo(x2, yWave);
            this.ctx.stroke();
        }

        // Vertical grid lines
        const numVerticalLines = Math.floor(gridLines * 1.5);
        for (let i = 0; i <= numVerticalLines; i++) {
            const progress = i / numVerticalLines;
            const xTop = this.centerX + (progress - 0.5) * this.canvas.width * 0.2;
            const xBottom = this.centerX + (progress - 0.5) * this.canvas.width * 1.8;

            // Get magnitude for this vertical line
            const magIdx = Math.floor(progress * magnitudes.length);
            const magnitude = magnitudes[magIdx] * intensity;

            // Line can pulse with magnitude
            const alpha = 0.5 + magnitude * 0.5;
            this.ctx.strokeStyle = gridColor.replace('rgb', 'rgba').replace(')', `, ${alpha})`);

            this.ctx.beginPath();
            this.ctx.moveTo(xTop, gridStartY);
            this.ctx.lineTo(xBottom, gridEndY);
            this.ctx.stroke();
        }

        // Horizon glow line
        this.ctx.shadowBlur = glowIntensity * 3;
        this.ctx.strokeStyle = '#ff00ff';
        this.ctx.shadowColor = '#ff00ff';
        this.ctx.lineWidth = 3;
        this.ctx.beginPath();
        this.ctx.moveTo(0, horizonY);
        this.ctx.lineTo(this.canvas.width, horizonY);
        this.ctx.stroke();

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 1012: Ocean Waves
     * Realistic ocean waves with foam particles and audio-reactive swells
     */
    render1012OceanWaves(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const waveHeight = params.waveHeight !== undefined ? params.waveHeight : 1;
        const waveSpeed = params.waveSpeed !== undefined ? params.waveSpeed : 0.5;
        const foamDensity = params.foamDensity !== undefined ? params.foamDensity : 0.5;
        const waveCount = params.waveCount !== undefined ? params.waveCount : 4;
        const glowIntensity = params.glowIntensity !== undefined ? params.glowIntensity : 10;

        // Use Step 4 settings
        const barCount = this.settings.barCount || 72;

        // Initialize animation time and wave particles
        this.frameCounter = (this.frameCounter || 0) + waveSpeed;

        if (!this.oceanFoamParticles) {
            this.oceanFoamParticles = [];
        }

        // Calculate frequency energies
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Ocean gradient background (deep blue to lighter blue)
        const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
        gradient.addColorStop(0, '#001a33');
        gradient.addColorStop(0.5, '#003d66');
        gradient.addColorStop(1, '#006699');
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw waves from back to front
        const horizonY = this.canvas.height * 0.4;

        for (let w = waveCount - 1; w >= 0; w--) {
            const waveProgress = w / waveCount;
            const baseY = horizonY + waveProgress * (this.canvas.height - horizonY);
            const wavePhase = this.frameCounter * 0.02 + w * 0.3;

            // Wave color from color scheme
            const color = this.getColor(Math.floor(w * (barCount / waveCount)), barCount);

            // Enable glow for wave crests
            this.ctx.shadowBlur = glowIntensity * (0.5 + energy * 0.5);
            this.ctx.shadowColor = color;

            // Draw the wave
            this.ctx.beginPath();
            this.ctx.fillStyle = color;

            const numPoints = 100;
            for (let i = 0; i <= numPoints; i++) {
                const x = (i / numPoints) * this.canvas.width;

                // Get magnitude for this point
                const magIdx = Math.floor((i / numPoints) * magnitudes.length);
                const magnitude = magnitudes[magIdx] * intensity;

                // Multiple sine waves for realistic ocean movement
                const wave1 = Math.sin(wavePhase + i * 0.05) * 20;
                const wave2 = Math.sin(wavePhase * 1.3 + i * 0.03) * 15;
                const wave3 = Math.sin(wavePhase * 0.7 + i * 0.08) * 10;

                // Audio-reactive wave height
                const audioWave = magnitude * 50 * waveHeight * (1 + bass);

                const y = baseY + wave1 + wave2 + wave3 + audioWave;

                if (i === 0) {
                    this.ctx.moveTo(x, y);
                } else {
                    this.ctx.lineTo(x, y);
                }
            }

            // Complete the wave shape
            this.ctx.lineTo(this.canvas.width, this.canvas.height);
            this.ctx.lineTo(0, this.canvas.height);
            this.ctx.closePath();
            this.ctx.fill();

            // Add wave highlights/foam on crests
            if (foamDensity > 0 && w < 2) {
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                this.ctx.shadowBlur = glowIntensity * 0.5;
                this.ctx.shadowColor = '#ffffff';

                for (let i = 0; i < numPoints; i += 3) {
                    const x = (i / numPoints) * this.canvas.width;
                    const magIdx = Math.floor((i / numPoints) * magnitudes.length);
                    const magnitude = magnitudes[magIdx] * intensity;

                    const wave1 = Math.sin(wavePhase + i * 0.05) * 20;
                    const wave2 = Math.sin(wavePhase * 1.3 + i * 0.03) * 15;
                    const wave3 = Math.sin(wavePhase * 0.7 + i * 0.08) * 10;
                    const audioWave = magnitude * 50 * waveHeight * (1 + bass);
                    const y = baseY + wave1 + wave2 + wave3 + audioWave;

                    // Draw foam highlight at wave peaks
                    const waveDerivative = Math.cos(wavePhase + i * 0.05);
                    if (waveDerivative > 0.7) {
                        const foamSize = 2 + magnitude * 4;
                        this.ctx.beginPath();
                        this.ctx.arc(x, y - 5, foamSize, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            }
        }

        // Add foam particles that float on the surface
        if (foamDensity > 0) {
            const targetParticleCount = Math.floor(foamDensity * 100);

            // Add new particles based on audio energy
            if (this.oceanFoamParticles.length < targetParticleCount && Math.random() < energy) {
                this.oceanFoamParticles.push({
                    x: Math.random() * this.canvas.width,
                    y: horizonY + Math.random() * (this.canvas.height - horizonY) * 0.3,
                    size: 2 + Math.random() * 4,
                    vx: (Math.random() - 0.5) * 2,
                    vy: Math.random() * 0.5,
                    life: 1.0
                });
            }

            // Update and draw foam particles
            this.ctx.shadowBlur = glowIntensity * 0.3;
            for (let i = this.oceanFoamParticles.length - 1; i >= 0; i--) {
                const particle = this.oceanFoamParticles[i];

                // Update particle
                particle.x += particle.vx * waveSpeed;
                particle.y += particle.vy * waveSpeed;
                particle.life -= 0.01;

                // Remove dead particles or ones off screen
                if (particle.life <= 0 || particle.x < -10 || particle.x > this.canvas.width + 10) {
                    this.oceanFoamParticles.splice(i, 1);
                    continue;
                }

                // Draw particle
                this.ctx.fillStyle = `rgba(255, 255, 255, ${particle.life * 0.7})`;
                this.ctx.shadowColor = '#ffffff';
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 1016: Quantum Flux
     * Minimalist quantum particles phasing between wave and particle states
     */
    render1016QuantumFlux(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const particleCount = params.particleCount !== undefined ? params.particleCount : 60;
        const phaseSpeed = params.phaseSpeed !== undefined ? params.phaseSpeed : 1.5;
        const waveAmplitude = params.waveAmplitude !== undefined ? params.waveAmplitude : 0.7;
        const coherence = params.coherence !== undefined ? params.coherence : 0.5;
        const glowIntensity = params.glowIntensity !== undefined ? params.glowIntensity : 20;

        // Use Step 4 settings
        const barCount = this.settings.barCount || 72;
        const innerRadius = this.getEffectiveInnerRadius();

        // Initialize animation time
        this.frameCounter = (this.frameCounter || 0) + phaseSpeed * 0.5;

        // Calculate energy
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Black background for minimalist look
        this.ctx.fillStyle = '#000000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Quantum phase state (0 = pure particle, 1 = pure wave)
        const phaseState = (Math.sin(this.frameCounter * 0.05) + 1) / 2;
        const quantumCoherence = coherence * (0.7 + energy * 0.3);

        this.ctx.shadowBlur = glowIntensity;

        // Draw particles/waves
        for (let i = 0; i < particleCount; i++) {
            const progress = i / particleCount;
            const magIdx = Math.floor(progress * magnitudes.length);
            const magnitude = magnitudes[magIdx] * intensity;

            // Base position in a clean grid or orbital pattern
            const angle = progress * Math.PI * 2 + this.frameCounter * 0.02;
            const radius = innerRadius + (this.maxRadius - innerRadius) * 0.5;

            const baseX = this.centerX + Math.cos(angle) * radius;
            const baseY = this.centerY + Math.sin(angle) * radius;

            // Wave-particle duality
            const waveOffset = Math.sin(this.frameCounter * 0.1 + i * 0.2) * waveAmplitude * 50;
            const particlePhase = phaseState * quantumCoherence;

            const x = baseX + waveOffset * particlePhase;
            const y = baseY;

            // Particle size based on observation (coherence)
            const particleSize = 2 + magnitude * 8 * (1 - particlePhase * 0.5);

            // Color from scheme
            const color = this.getColor(Math.floor(i * (barCount / particleCount)), barCount);
            this.ctx.shadowColor = color;
            this.ctx.fillStyle = color;

            // Opacity based on phase state (particles are solid, waves are translucent)
            this.ctx.globalAlpha = 0.3 + (1 - particlePhase) * 0.7;

            // Draw particle
            this.ctx.beginPath();
            this.ctx.arc(x, y, particleSize, 0, Math.PI * 2);
            this.ctx.fill();

            // Wave function visualization (probability cloud)
            if (particlePhase > 0.3) {
                this.ctx.globalAlpha = particlePhase * 0.2;
                for (let w = 0; w < 3; w++) {
                    const waveX = baseX + Math.sin(this.frameCounter * 0.1 + i * 0.2 + w) * waveAmplitude * 50;
                    this.ctx.beginPath();
                    this.ctx.arc(waveX, y, particleSize * 0.5, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 1017: Photon Streams
     * Elegant converging light beams with lens flare and refraction
     */
    render1017PhotonStreams(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const streamCount = params.streamCount !== undefined ? params.streamCount : 12;
        const flowSpeed = params.flowSpeed !== undefined ? params.flowSpeed : 1.2;
        const convergence = params.convergence !== undefined ? params.convergence : 0.6;
        const beamWidth = params.beamWidth !== undefined ? params.beamWidth : 3;
        const glowIntensity = params.glowIntensity !== undefined ? params.glowIntensity : 25;

        // Use Step 4 settings
        const barCount = this.settings.barCount || 72;
        const innerRadius = this.getEffectiveInnerRadius();

        // Initialize animation time and particles
        this.frameCounter = (this.frameCounter || 0) + flowSpeed * 0.5;

        if (!this.photonParticles) {
            this.photonParticles = [];
        }

        // Calculate energy
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Dark gradient background
        const gradient = this.ctx.createRadialGradient(
            this.centerX, this.centerY, 0,
            this.centerX, this.centerY, this.maxRadius
        );
        gradient.addColorStop(0, '#000000');
        gradient.addColorStop(1, '#0a0a0a');
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Convergence point
        const convergeX = this.centerX;
        const convergeY = this.centerY * (0.5 + convergence * 0.5);

        // Draw streams
        for (let s = 0; s < streamCount; s++) {
            const progress = s / streamCount;
            const magIdx = Math.floor(progress * magnitudes.length);
            const magnitude = magnitudes[magIdx] * intensity;

            // Stream origin (around the edges)
            const angle = progress * Math.PI * 2;
            const originX = this.centerX + Math.cos(angle) * this.maxRadius * 1.2;
            const originY = this.centerY + Math.sin(angle) * this.maxRadius * 1.2;

            // Color from scheme
            const color = this.getColor(Math.floor(s * (barCount / streamCount)), barCount);

            // Draw beam
            this.ctx.strokeStyle = color;
            this.ctx.shadowColor = color;
            this.ctx.shadowBlur = glowIntensity * (0.5 + magnitude * 0.5);
            this.ctx.lineWidth = beamWidth + magnitude * 4;
            this.ctx.globalAlpha = 0.4 + magnitude * 0.4;

            this.ctx.beginPath();
            this.ctx.moveTo(originX, originY);
            this.ctx.lineTo(convergeX, convergeY);
            this.ctx.stroke();

            // Add photon particles along the beam
            const particlesPerStream = 3 + Math.floor(magnitude * 5);
            for (let p = 0; p < particlesPerStream; p++) {
                const particleProgress = (this.frameCounter * 0.02 + s * 0.1 + p * 0.15) % 1;

                const px = originX + (convergeX - originX) * particleProgress;
                const py = originY + (convergeY - originY) * particleProgress;
                const pSize = 3 + magnitude * 5;

                this.ctx.fillStyle = color;
                this.ctx.shadowBlur = glowIntensity * 0.8;
                this.ctx.globalAlpha = 0.8;

                this.ctx.beginPath();
                this.ctx.arc(px, py, pSize, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }

        // Central convergence glow (lens flare effect)
        const centralGlow = energy * intensity;
        this.ctx.shadowBlur = glowIntensity * 2;
        for (let i = 0; i < 3; i++) {
            const glowSize = 15 + i * 10 + centralGlow * 30;
            const glowColor = this.getColor(Math.floor(barCount / 2), barCount);
            this.ctx.fillStyle = glowColor;
            this.ctx.shadowColor = glowColor;
            this.ctx.globalAlpha = (0.3 - i * 0.08) * (0.5 + centralGlow * 0.5);

            this.ctx.beginPath();
            this.ctx.arc(convergeX, convergeY, glowSize, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Mode 1018: Magnetic Field
     * Minimalist magnetic field lines flowing between reactive poles
     */
    render1018MagneticField(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const fieldLines = params.fieldLines !== undefined ? params.fieldLines : 16;
        const poleDistance = params.poleDistance !== undefined ? params.poleDistance : 0.6;
        const curvature = params.curvature !== undefined ? params.curvature : 1;
        const pulseSpeed = params.pulseSpeed !== undefined ? params.pulseSpeed : 1.5;
        const glowIntensity = params.glowIntensity !== undefined ? params.glowIntensity : 18;

        // Use Step 4 settings
        const barCount = this.settings.barCount || 72;
        const innerRadius = this.getEffectiveInnerRadius();

        // Initialize animation time
        this.frameCounter = (this.frameCounter || 0) + pulseSpeed * 0.5;

        // Calculate energy
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Pole positions (north and south)
        const poleSpacing = this.canvas.width * poleDistance;
        const northPoleX = this.centerX - poleSpacing / 2;
        const southPoleX = this.centerX + poleSpacing / 2;
        const poleY = this.centerY;

        // Pole strength based on audio
        const poleStrength = 1 + energy * intensity;

        // Draw field lines
        this.ctx.shadowBlur = glowIntensity;

        for (let l = 0; l < fieldLines; l++) {
            const lineProgress = l / fieldLines;
            const magIdx = Math.floor(lineProgress * magnitudes.length);
            const magnitude = magnitudes[magIdx] * intensity;

            // Field line starts from north pole
            const startAngle = (lineProgress - 0.5) * Math.PI * 0.8;
            const startDistance = 20 + magnitude * 20;

            const startX = northPoleX + Math.cos(startAngle) * startDistance;
            const startY = poleY + Math.sin(startAngle) * startDistance;

            // Field line ends at south pole
            const endAngle = Math.PI + (lineProgress - 0.5) * Math.PI * 0.8;
            const endDistance = 20 + magnitude * 20;

            const endX = southPoleX + Math.cos(endAngle) * endDistance;
            const endY = poleY + Math.sin(endAngle) * endDistance;

            // Color from scheme
            const color = this.getColor(Math.floor(l * (barCount / fieldLines)), barCount);
            this.ctx.strokeStyle = color;
            this.ctx.shadowColor = color;
            this.ctx.lineWidth = 1 + magnitude * 2;

            // Pulsing animation along field lines
            const pulse = (Math.sin(this.frameCounter * 0.1 + l * 0.3) + 1) / 2;
            this.ctx.globalAlpha = 0.4 + pulse * 0.4 + magnitude * 0.2;

            // Draw curved field line using quadratic bezier
            this.ctx.beginPath();
            this.ctx.moveTo(startX, startY);

            // Control point for curve (higher curvature = more pronounced arc)
            const controlDistance = poleSpacing * 0.3 * curvature;
            const controlY = poleY + (lineProgress - 0.5) * controlDistance * (1 + bass);

            this.ctx.quadraticCurveTo(
                this.centerX,
                controlY,
                endX,
                endY
            );
            this.ctx.stroke();

            // Add flowing particles along field lines
            const particleProgress = (this.frameCounter * 0.02 + l * 0.1) % 1;

            // Calculate particle position on bezier curve
            const t = particleProgress;
            const px = (1 - t) * (1 - t) * startX + 2 * (1 - t) * t * this.centerX + t * t * endX;
            const py = (1 - t) * (1 - t) * startY + 2 * (1 - t) * t * controlY + t * t * endY;

            this.ctx.fillStyle = color;
            this.ctx.shadowBlur = glowIntensity * 0.8;
            this.ctx.globalAlpha = 0.8 + magnitude * 0.2;

            this.ctx.beginPath();
            this.ctx.arc(px, py, 2 + magnitude * 3, 0, Math.PI * 2);
            this.ctx.fill();
        }

        // Draw magnetic poles
        const poleSize = 8 + energy * 10;

        // North pole (blue-ish from color scheme)
        const northColor = this.getColor(0, barCount);
        this.ctx.fillStyle = northColor;
        this.ctx.shadowColor = northColor;
        this.ctx.shadowBlur = glowIntensity * 1.5;
        this.ctx.globalAlpha = 1;

        this.ctx.beginPath();
        this.ctx.arc(northPoleX, poleY, poleSize, 0, Math.PI * 2);
        this.ctx.fill();

        // South pole (opposite end of color scheme)
        const southColor = this.getColor(barCount / 2, barCount);
        this.ctx.fillStyle = southColor;
        this.ctx.shadowColor = southColor;

        this.ctx.beginPath();
        this.ctx.arc(southPoleX, poleY, poleSize, 0, Math.PI * 2);
        this.ctx.fill();

        this.ctx.globalAlpha = 1;
        this.ctx.shadowBlur = 0;
    }

    /**
     * Helper method to adjust color brightness
     */
    adjustBrightness(color, amount) {
        // Extract RGB values from color string
        const match = color.match(/\d+/g);
        if (!match || match.length < 3) return color;

        let [r, g, b] = match.map(Number);

        // Adjust brightness
        r = Math.max(0, Math.min(255, r + amount));
        g = Math.max(0, Math.min(255, g + amount));
        b = Math.max(0, Math.min(255, b + amount));

        return `rgb(${r}, ${g}, ${b})`;
    }


    // ========================================
    // GENERATED MISSING RENDER METHODS
    // ========================================

    /**
     * Mode 107: DnaHelix
     * Dna Helix visualization with configurable parameters
     */
    render107DnaHelix(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 108: FractalBloom
     * Fractal Bloom visualization with configurable parameters
     */
    render108FractalBloom(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 109: CircuitBoard
     * Circuit Board visualization with configurable parameters
     */
    render109CircuitBoard(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 110: QuantumField
     * Quantum Field visualization with configurable parameters
     */
    render110QuantumField(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 111: OrigamiUnfold
     * Origami Unfold visualization with configurable parameters
     */
    render111OrigamiUnfold(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 112: GalaxySpiral
     * Galaxy Spiral visualization with configurable parameters
     */
    render112GalaxySpiral(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 113: RubberBands
     * Rubber Bands visualization with configurable parameters
     */
    render113RubberBands(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 114: InkDiffusion
     * Ink Diffusion visualization with configurable parameters
     */
    render114InkDiffusion(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 115: GeometricKaleidoscope
     * Geometric Kaleidoscope visualization with configurable parameters
     */
    render115GeometricKaleidoscope(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 157: WaterlineOscilloscope
     * Waterline Oscilloscope visualization with configurable parameters
     */
    render157WaterlineOscilloscope(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 174: InkSplatterScope
     * Ink Splatter Scope visualization with configurable parameters
     */
    render174InkSplatterScope(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 201: MeteorNet
     * Meteor Net visualization with configurable parameters
     */
    render201Meteornet(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 202: DeepSpaceGardenHose
     * Deep Space Garden Hose visualization with configurable parameters
     */
    render202DeepSpaceGardenHose(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 203: HorizonMonoliths
     * Horizon Monoliths visualization with configurable parameters
     */
    render203HorizonMonoliths(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 204: GravitySlingshotTrails
     * Gravity Slingshot Trails visualization with configurable parameters
     */
    render204GravitySlingshotTrails(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 205: SolarFlareNotches
     * Solar Flare Notches visualization with configurable parameters
     */
    render205SolarFlareNotches(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 206: TesseractWindow
     * Tesseract Window visualization with configurable parameters
     */
    render206TesseractWindow(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 207: InterstellarPostcards
     * Interstellar Postcards visualization with configurable parameters
     */
    render207InterstellarPostcards(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 208: CosmicBraille
     * Cosmic Braille visualization with configurable parameters
     */
    render208CosmicBraille(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 209: StellarHarpoon
     * Stellar Harpoon visualization with configurable parameters
     */
    render209StellarHarpoon(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 210: GalaxyTickerTape
     * Galaxy Ticker Tape visualization with configurable parameters
     */
    render210GalaxyTickerTape(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 211: AntimatterChess
     * Antimatter Chess visualization with configurable parameters
     */
    render211AntimatterChess(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 212: StarNurseryConveyor
     * Star Nursery Conveyor visualization with configurable parameters
     */
    render212StarNurseryConveyor(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 213: MagnetarLines
     * Magnetar Lines visualization with configurable parameters
     */
    render213MagnetarLines(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 214: ZeroKelvinDiamonds
     * Zero Kelvin Diamonds visualization with configurable parameters
     */
    render214ZeroKelvinDiamonds(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 215: OrbitalTimeGarden
     * Orbital Time Garden visualization with configurable parameters
     */
    render215OrbitalTimeGarden(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 216: SubspaceRibbonPrinter
     * Subspace Ribbon Printer visualization with configurable parameters
     */
    render216SubspaceRibbonPrinter(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 217: DarkMatterDrizzle
     * Dark Matter Drizzle visualization with configurable parameters
     */
    render217DarkMatterDrizzle(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 218: MeteorChoirCones
     * Meteor Choir Cones visualization with configurable parameters
     */
    render218MeteorChoirCones(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 219: FoldedGalaxyMap
     * Folded Galaxy Map visualization with configurable parameters
     */
    render219FoldedGalaxyMap(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 220: IonThrusterPlume
     * Ion Thruster Plume visualization with configurable parameters
     */
    render220IonThrusterPlume(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 221: CosmicDominoes
     * Cosmic Dominoes visualization with configurable parameters
     */
    render221CosmicDominoes(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 222: SpacesuitHud
     * Spacesuit Hud visualization with configurable parameters
     */
    render222SpacesuitHud(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 223: PulsarBarcodeBeam
     * Pulsar Barcode Beam visualization with configurable parameters
     */
    render223PulsarBarcodeBeam(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 224: AstroTerrarium
     * Astro Terrarium visualization with configurable parameters
     */
    render224AstroTerrarium(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 225: MicrometeorSparkCurtain
     * Micrometeor Spark Curtain visualization with configurable parameters
     */
    render225MicrometeorSparkCurtain(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 276: QuantumLattice
     * Quantum Lattice visualization with configurable parameters
     */
    render276QuantumLattice(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 277: PrismRays
     * Prism Rays visualization with configurable parameters
     */
    render277PrismRays(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 278: LiquidNitrogen
     * Liquid Nitrogen visualization with freezing and shattering effects
     */
    render278LiquidNitrogen(magnitudes) {
        const params = this.settings.modeParameters || {};
        const freezeIntensity = params.freezeIntensity || 1;
        const shatterAmount = params.shatterAmount || 1.5;
        const crystallization = params.crystallization || 5;

        // Calculate audio features
        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const mids = magnitudes.slice(Math.floor(magnitudes.length / 4), Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (Math.floor(3 * magnitudes.length / 4) - Math.floor(magnitudes.length / 4));
        const treble = magnitudes.slice(Math.floor(3 * magnitudes.length / 4)).reduce((a, b) => a + b, 0) / (magnitudes.length - Math.floor(3 * magnitudes.length / 4));

        // Initialize frame counter
        this.frameCounter = (this.frameCounter || 0) + 1;

        // Draw frozen base (icy vapor)
        const vaporParticles = Math.floor(20 * crystallization);
        for (let i = 0; i < vaporParticles; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const x = (i / vaporParticles) * this.width;
            const y = this.height - (magnitude * this.height * 0.3 * freezeIntensity);
            const size = 2 + magnitude * 8 * freezeIntensity;

            // Icy white-blue gradient
            const alpha = 0.2 + magnitude * 0.5;
            const blueShift = Math.sin(this.frameCounter * 0.05 + i) * 30;
            this.ctx.fillStyle = `rgba(${200 + blueShift}, ${230 + blueShift}, 255, ${alpha})`;
            this.ctx.shadowBlur = 10 * freezeIntensity;
            this.ctx.shadowColor = 'rgba(200, 230, 255, 0.6)';

            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }

        // Draw ice crystals (frozen formations)
        const numCrystals = Math.floor(15 * crystallization);
        for (let i = 0; i < numCrystals; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            const baseX = (i / numCrystals) * this.width;
            const baseY = this.height - (magnitude * this.height * 0.5 * freezeIntensity);

            // Draw crystal as a hexagon
            const crystalSize = 10 + magnitude * 20 * freezeIntensity;
            const rotation = this.frameCounter * 0.02 + i;

            this.ctx.save();
            this.ctx.translate(baseX, baseY);
            this.ctx.rotate(rotation);

            // Crystal fill
            this.ctx.beginPath();
            for (let j = 0; j < 6; j++) {
                const angle = (j / 6) * Math.PI * 2;
                const x = Math.cos(angle) * crystalSize;
                const y = Math.sin(angle) * crystalSize;
                if (j === 0) this.ctx.moveTo(x, y);
                else this.ctx.lineTo(x, y);
            }
            this.ctx.closePath();

            const cyanShift = Math.sin(this.frameCounter * 0.03 + i) * 50;
            this.ctx.fillStyle = `rgba(${150 + cyanShift}, ${220 + cyanShift}, 255, ${0.3 + magnitude * 0.4})`;
            this.ctx.fill();

            // Crystal edges
            this.ctx.strokeStyle = `rgba(255, 255, 255, ${0.6 + magnitude * 0.4})`;
            this.ctx.lineWidth = 1.5;
            this.ctx.stroke();

            this.ctx.restore();
        }

        // Draw shattering shards (triggered by high frequencies)
        const numShards = Math.floor(25 * shatterAmount);
        for (let i = 0; i < numShards; i++) {
            const magnitude = magnitudes[i % magnitudes.length];
            // Shards react more to treble and high energy
            const shardEnergy = magnitude * treble * shatterAmount;

            if (shardEnergy > 0.1) {
                const angle = (i / numShards) * Math.PI * 2 + this.frameCounter * 0.03;
                const distance = this.maxRadius * (0.3 + shardEnergy * 0.6);

                const x = this.centerX + Math.cos(angle) * distance;
                const y = this.centerY + Math.sin(angle) * distance;

                // Draw triangular shard
                const shardSize = 5 + shardEnergy * 15;
                const shardAngle = angle + Math.sin(this.frameCounter * 0.05 + i) * 0.5;

                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(shardAngle);

                this.ctx.beginPath();
                this.ctx.moveTo(0, -shardSize);
                this.ctx.lineTo(shardSize * 0.4, shardSize * 0.5);
                this.ctx.lineTo(-shardSize * 0.4, shardSize * 0.5);
                this.ctx.closePath();

                // Icy shard color with shimmer
                const shimmer = Math.sin(this.frameCounter * 0.1 + i) * 40;
                this.ctx.fillStyle = `rgba(${180 + shimmer}, ${230 + shimmer}, 255, ${0.5 + shardEnergy * 0.5})`;
                this.ctx.fill();

                this.ctx.strokeStyle = `rgba(255, 255, 255, ${0.8})`;
                this.ctx.lineWidth = 1;
                this.ctx.stroke();

                this.ctx.restore();
            }
        }

        // Draw freezing waves (emanating from center)
        const numWaves = Math.floor(5 * crystallization);
        for (let i = 0; i < numWaves; i++) {
            const wavePhase = (this.frameCounter * 0.02 + i * 0.5) % 1;
            const radius = wavePhase * this.maxRadius * 1.5;
            const magnitude = magnitudes[Math.floor(i * magnitudes.length / numWaves)];
            const alpha = (1 - wavePhase) * magnitude * freezeIntensity * 0.3;

            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, radius, 0, Math.PI * 2);
            this.ctx.strokeStyle = `rgba(200, 240, 255, ${alpha})`;
            this.ctx.lineWidth = 2 + magnitude * 4;
            this.ctx.stroke();
        }
    }
    /**
     * Mode 279: SilkRoadCaravan
     * Silk Road Caravan visualization with configurable parameters
     */
    render279SilkRoadCaravan(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 280: SteampunkGears
     * Steampunk Gears visualization with configurable parameters
     */
    render280SteampunkGears(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 281: DragonScales
     * Dragon Scales visualization with configurable parameters
     */
    render281DragonScales(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 282: TimeDilationGrid
     * Time Dilation Grid visualization with configurable parameters
     */
    render282TimeDilationGrid(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 283: FiberBundle
     * Fiber Bundle visualization with configurable parameters
     */
    render283FiberBundle(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 284: MothWingShimmer
     * Moth Wing Shimmer visualization with configurable parameters
     */
    render284MothWingShimmer(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 285: CathedralRose
     * Cathedral Rose visualization with configurable parameters
     */
    render285CathedralRose(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 286: NeonVeinsPulse
     * Neon Veins Pulse visualization with configurable parameters
     */
    render286NeonVeinsPulse(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 287: GlacialCrack
     * Glacial Crack visualization with configurable parameters
     */
    render287GlacialCrack(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 288: QuantumDots
     * Quantum Dots visualization with configurable parameters
     */
    render288QuantumDots(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 289: OrigamiCraneFlight
     * Origami Crane Flight visualization with configurable parameters
     */
    render289OrigamiCraneFlight(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 290: MagmaChamber
     * Magma Chamber visualization with configurable parameters
     */
    render290MagmaChamber(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 291: SpiderWebDew
     * Spider Web Dew visualization with configurable parameters
     */
    render291SpiderWebDew(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 292: NebulaBirth
     * Nebula Birth visualization with configurable parameters
     */
    render292NebulaBirth(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 293: CircuitBoardLive
     * Circuit Board Live visualization with configurable parameters
     */
    render293CircuitBoardLive(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 294: BioluminescentTide
     * Bioluminescent Tide visualization with configurable parameters
     */
    render294BioluminescentTide(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 295: TesseractProjection
     * Tesseract Projection visualization with configurable parameters
     */
    render295TesseractProjection(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 296: FrostCrystalGrowth
     * Frost Crystal Growth visualization with configurable parameters
     */
    render296FrostCrystalGrowth(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 297: SoundWaveInterference
     * Sound Wave Interference visualization with configurable parameters
     */
    render297SoundWaveInterference(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 298: HolographicFracture
     * Holographic Fracture visualization with configurable parameters
     */
    render298HolographicFracture(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 299: PlasmaBallArc
     * Plasma Ball Arc visualization with configurable parameters
     */
    render299PlasmaBallArc(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 300: EternalFlameDance
     * Eternal Flame Dance visualization with configurable parameters
     */
    render300EternalFlameDance(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 400: WaterLilyReflection
     * Water Lily Reflection visualization with configurable parameters
     */
    render400WaterLilyReflection(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 401: AtomModel
     * Atom Model visualization with configurable parameters
     */
    render401AtomModel(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 402: DoubleHelix
     * Double Helix visualization with configurable parameters
     */
    render402DoubleHelix(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 403: MagneticField
     * Magnetic Field visualization with configurable parameters
     */
    render403MagneticField(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 404: WaveInterference
     * Wave Interference visualization with configurable parameters
     */
    render404WaveInterference(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 406: CrystalLattice
     * Crystal Lattice visualization with configurable parameters
     */
    render406CrystalLattice(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 407: ElectromagneticWave
     * Electromagnetic Wave visualization with configurable parameters
     */
    render407ElectromagneticWave(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 408: QuantumTunneling
     * Quantum Tunneling visualization with configurable parameters
     */
    render408QuantumTunneling(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 409: FissionReaction
     * Fission Reaction visualization with configurable parameters
     */
    render409FissionReaction(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 410: DopplerEffect
     * Doppler Effect visualization with configurable parameters
     */
    render410DopplerEffect(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 411: GravityWell
     * Gravity Well visualization with configurable parameters
     */
    render411GravityWell(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 412: PrismSpectrum
     * Prism Spectrum visualization with configurable parameters
     */
    render412PrismSpectrum(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 413: MolecularBonds
     * Molecular Bonds visualization with configurable parameters
     */
    render413MolecularBonds(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 414: StandingWave
     * Standing Wave visualization with configurable parameters
     */
    render414StandingWave(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 415: BrownianMotion
     * Brownian Motion visualization with configurable parameters
     */
    render415BrownianMotion(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 416: TeslaCoil
     * Tesla Coil visualization with configurable parameters
     */
    render416TeslaCoil(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 417: PhaseTransition
     * Phase Transition visualization with configurable parameters
     */
    render417PhaseTransition(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 418: Superconductor
     * Superconductor visualization with configurable parameters
     */
    render418Superconductor(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 419: NeuronFiring
     * Neuron Firing visualization with configurable parameters
     */
    render419NeuronFiring(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 420: ResonanceModes
     * Resonance Modes visualization with configurable parameters
     */
    render420ResonanceModes(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 421: FractalDiffusion
     * Fractal Diffusion visualization with configurable parameters
     */
    render421FractalDiffusion(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 422: PlasmaBall
     * Plasma Ball visualization with configurable parameters
     */
    render422PlasmaBall(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 423: CoriolisEffect
     * Coriolis Effect visualization with configurable parameters
     */
    render423CoriolisEffect(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 424: PhotoelectricEffect
     * Photoelectric Effect visualization with configurable parameters
     */
    render424PhotoelectricEffect(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 425: LorenzAttractor
     * Lorenz Attractor visualization with configurable parameters
     */
    render425LorenzAttractor(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 426: SpinPrecession
     * Spin Precession visualization with configurable parameters
     */
    render426SpinPrecession(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 427: ComptonScattering
     * Compton Scattering visualization with configurable parameters
     */
    render427ComptonScattering(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 428: Ferrofluid
     * Ferrofluid visualization with configurable parameters
     */
    render428Ferrofluid(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 429: Sonoluminescence
     * Sonoluminescence visualization with configurable parameters
     */
    render429Sonoluminescence(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 430: CherenkovRadiation
     * Cherenkov Radiation visualization with configurable parameters
     */
    render430CherenkovRadiation(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 431: HallEffect
     * Hall Effect visualization with configurable parameters
     */
    render431HallEffect(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 432: Cymatics
     * Cymatics visualization with configurable parameters
     */
    render432Cymatics(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 433: KleinBottle
     * Klein Bottle visualization with configurable parameters
     */
    render433KleinBottle(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 434: RamanScattering
     * Raman Scattering visualization with configurable parameters
     */
    render434RamanScattering(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 435: VortexShedding
     * Vortex Shedding visualization with configurable parameters
     */
    render435VortexShedding(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 436: Polarization
     * Polarization visualization with configurable parameters
     */
    render436Polarization(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 437: HiggsField
     * Higgs Field visualization with configurable parameters
     */
    render437HiggsField(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 438: BoseEinstein
     * Bose Einstein visualization with configurable parameters
     */
    render438BoseEinstein(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 439: SchrodingerCat
     * Schrodinger Cat visualization with configurable parameters
     */
    render439SchrodingerCat(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 440: StringVibration
     * String Vibration visualization with configurable parameters
     */
    render440StringVibration(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 441: ElectronCloud
     * Electron Cloud visualization with configurable parameters
     */
    render441ElectronCloud(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 442: Thermoelectric
     * Thermoelectric visualization with configurable parameters
     */
    render442Thermoelectric(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 443: PhotonEntanglement
     * Photon Entanglement visualization with configurable parameters
     */
    render443PhotonEntanglement(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 444: Superfluidity
     * Superfluidity visualization with configurable parameters
     */
    render444Superfluidity(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 445: Piezoelectric
     * Piezoelectric visualization with configurable parameters
     */
    render445Piezoelectric(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 446: ZeemanEffect
     * Zeeman Effect visualization with configurable parameters
     */
    render446ZeemanEffect(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 447: CyclotronMotion
     * Cyclotron Motion visualization with configurable parameters
     */
    render447CyclotronMotion(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 448: FusionReactor
     * Fusion Reactor visualization with configurable parameters
     */
    render448FusionReactor(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 449: Antimatter
     * Antimatter visualization with configurable parameters
     */
    render449Antimatter(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 450: HawkingRadiation
     * Hawking Radiation visualization with configurable parameters
     */
    render450HawkingRadiation(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 451: HeisenbergUncertainty
     * Heisenberg Uncertainty visualization with configurable parameters
     */
    render451HeisenbergUncertainty(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 453: LaserCavity
     * Laser Cavity visualization with configurable parameters
     */
    render453LaserCavity(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 454: DielectricBreakdown
     * Dielectric Breakdown visualization with configurable parameters
     */
    render454DielectricBreakdown(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 455: CasimirEffect
     * Casimir Effect visualization with configurable parameters
     */
    render455CasimirEffect(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 456: Sonochemistry
     * Sonochemistry visualization with configurable parameters
     */
    render456Sonochemistry(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 457: PhononPropagation
     * Phonon Propagation visualization with configurable parameters
     */
    render457PhononPropagation(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 458: PairProduction
     * Pair Production visualization with configurable parameters
     */
    render458PairProduction(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 459: StefanBoltzmann
     * Stefan Boltzmann visualization with configurable parameters
     */
    render459StefanBoltzmann(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 460: EddyCurrents
     * Eddy Currents visualization with configurable parameters
     */
    render460EddyCurrents(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 461: WavefunctionCollapse
     * Wavefunction Collapse visualization with configurable parameters
     */
    render461WavefunctionCollapse(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 462: QedFeynman
     * Qed Feynman visualization with configurable parameters
     */
    render462QedFeynman(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 463: Holography
     * Holography visualization with configurable parameters
     */
    render463Holography(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 464: Metamaterial
     * Metamaterial visualization with configurable parameters
     */
    render464Metamaterial(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 465: Photodiode
     * Photodiode visualization with configurable parameters
     */
    render465Photodiode(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 466: Bremsstrahlung
     * Bremsstrahlung visualization with configurable parameters
     */
    render466Bremsstrahlung(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 467: Optogenetics
     * Optogenetics visualization with configurable parameters
     */
    render467Optogenetics(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 468: TopologicalInsulator
     * Topological Insulator visualization with configurable parameters
     */
    render468TopologicalInsulator(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 469: NernstEquation
     * Nernst Equation visualization with configurable parameters
     */
    render469NernstEquation(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 470: MriPrecession
     * Mri Precession visualization with configurable parameters
     */
    render470MriPrecession(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 471: JosephsonJunction
     * Josephson Junction visualization with configurable parameters
     */
    render471JosephsonJunction(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 472: LiquidCrystal
     * Liquid Crystal visualization with configurable parameters
     */
    render472LiquidCrystal(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 473: RydbergAtoms
     * Rydberg Atoms visualization with configurable parameters
     */
    render473RydbergAtoms(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 474: CavityQed
     * Cavity Qed visualization with configurable parameters
     */
    render474CavityQed(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 475: QuantumDots
     * Quantum Dots visualization with configurable parameters
     */
    render475QuantumDots(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 476: SolitonWave
     * Soliton Wave visualization with configurable parameters
     */
    render476SolitonWave(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 477: AcousticLevitation
     * Acoustic Levitation visualization with configurable parameters
     */
    render477AcousticLevitation(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 478: MosfetChannel
     * Mosfet Channel visualization with configurable parameters
     */
    render478MosfetChannel(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 479: Spintronics
     * Spintronics visualization with configurable parameters
     */
    render479Spintronics(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 480: Electrochemistry
     * Electrochemistry visualization with configurable parameters
     */
    render480Electrochemistry(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 481: LangmuirWave
     * Langmuir Wave visualization with configurable parameters
     */
    render481LangmuirWave(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 482: BlochSphere
     * Bloch Sphere visualization with configurable parameters
     */
    render482BlochSphere(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 483: CurieTemperature
     * Curie Temperature visualization with configurable parameters
     */
    render483CurieTemperature(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 484: DysonSphere
     * Dyson Sphere visualization with configurable parameters
     */
    render484DysonSphere(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 485: GrapheneLattice
     * Graphene Lattice visualization with configurable parameters
     */
    render485GrapheneLattice(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 486: Memristor
     * Memristor visualization with configurable parameters
     */
    render486Memristor(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 487: QuantumHall
     * Quantum Hall visualization with configurable parameters
     */
    render487QuantumHall(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 488: Optomechanics
     * Optomechanics visualization with configurable parameters
     */
    render488Optomechanics(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 489: Exciton
     * Exciton visualization with configurable parameters
     */
    render489Exciton(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 490: PhotonicCrystal
     * Photonic Crystal visualization with configurable parameters
     */
    render490PhotonicCrystal(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 491: Skyrmion
     * Skyrmion visualization with configurable parameters
     */
    render491Skyrmion(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 492: MottInsulator
     * Mott Insulator visualization with configurable parameters
     */
    render492MottInsulator(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 493: Squeezing
     * Squeezing visualization with configurable parameters
     */
    render493Squeezing(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 494: AndreevReflection
     * Andreev Reflection visualization with configurable parameters
     */
    render494AndreevReflection(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 495: CasimirPolder
     * Casimir Polder visualization with configurable parameters
     */
    render495CasimirPolder(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 496: FanoResonance
     * Fano Resonance visualization with configurable parameters
     */
    render496FanoResonance(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 497: QuantumZeno
     * Quantum Zeno visualization with configurable parameters
     */
    render497QuantumZeno(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 498: RabiOscillation
     * Rabi Oscillation visualization with configurable parameters
     */
    render498RabiOscillation(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 499: AharonovBohm
     * Aharonov Bohm visualization with configurable parameters
     */
    render499AharonovBohm(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 500: BerryPhase
     * Berry Phase visualization with configurable parameters
     */
    render500BerryPhase(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 501: Impressionist
     * Impressionist visualization with configurable parameters
     */
    render501Impressionist(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 502: Cubist
     * Cubist visualization with configurable parameters
     */
    render502Cubist(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 503: Surreal
     * Surreal visualization with configurable parameters
     */
    render503Surreal(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 504: AbstractExpressionist
     * Abstract Expressionist visualization with configurable parameters
     */
    render504AbstractExpressionist(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 505: PopArt
     * Pop Art visualization with configurable parameters
     */
    render505PopArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 506: Minimalist
     * Minimalist visualization with configurable parameters
     */
    render506Minimalist(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 507: Pointillist
     * Pointillist visualization with configurable parameters
     */
    render507Pointillist(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 508: ArtDeco
     * Art Deco visualization with configurable parameters
     */
    render508ArtDeco(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 509: ArtNouveau
     * Art Nouveau visualization with configurable parameters
     */
    render509ArtNouveau(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 510: Bauhaus
     * Bauhaus visualization with configurable parameters
     */
    render510Bauhaus(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 511: Futurist
     * Futurist visualization with configurable parameters
     */
    render511Futurist(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 512: Dadaist
     * Dadaist visualization with configurable parameters
     */
    render512Dadaist(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 513: Expressionist
     * Expressionist visualization with configurable parameters
     */
    render513Expressionist(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 514: Fauvism
     * Fauvism visualization with configurable parameters
     */
    render514Fauvism(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 515: Constructivist
     * Constructivist visualization with configurable parameters
     */
    render515Constructivist(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 516: Suprematist
     * Suprematist visualization with configurable parameters
     */
    render516Suprematist(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 517: Vorticism
     * Vorticism visualization with configurable parameters
     */
    render517Vorticism(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 518: Orphism
     * Orphism visualization with configurable parameters
     */
    render518Orphism(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 519: Rayonism
     * Rayonism visualization with configurable parameters
     */
    render519Rayonism(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 520: Synchromism
     * Synchromism visualization with configurable parameters
     */
    render520Synchromism(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 521: Precisionism
     * Precisionism visualization with configurable parameters
     */
    render521Precisionism(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 522: Regionalism
     * Regionalism visualization with configurable parameters
     */
    render522Regionalism(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 523: SocialRealism
     * Social Realism visualization with configurable parameters
     */
    render523SocialRealism(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 524: NeoPlasticism
     * Neo Plasticism visualization with configurable parameters
     */
    render524NeoPlasticism(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 525: DeStijl
     * De Stijl visualization with configurable parameters
     */
    render525DeStijl(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 526: ColorField
     * Color Field visualization with configurable parameters
     */
    render526ColorField(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 527: HardEdge
     * Hard Edge visualization with configurable parameters
     */
    render527HardEdge(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 528: LyricalAbstraction
     * Lyrical Abstraction visualization with configurable parameters
     */
    render528LyricalAbstraction(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 529: Tachisme
     * Tachisme visualization with configurable parameters
     */
    render529Tachisme(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 530: ActionPainting
     * Action Painting visualization with configurable parameters
     */
    render530ActionPainting(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 531: StainPainting
     * Stain Painting visualization with configurable parameters
     */
    render531StainPainting(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 532: ShapedCanvas
     * Shaped Canvas visualization with configurable parameters
     */
    render532ShapedCanvas(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 533: Monochrome
     * Monochrome visualization with configurable parameters
     */
    render533Monochrome(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 534: KineticArt
     * Kinetic Art visualization with configurable parameters
     */
    render534KineticArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 535: OpArt
     * Op Art visualization with configurable parameters
     */
    render535OpArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 536: LightArt
     * Light Art visualization with configurable parameters
     */
    render536LightArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 537: LandArt
     * Land Art visualization with configurable parameters
     */
    render537LandArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 538: EarthArt
     * Earth Art visualization with configurable parameters
     */
    render538EarthArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 539: EnvironmentalArt
     * Environmental Art visualization with configurable parameters
     */
    render539EnvironmentalArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 540: InstallationArt
     * Installation Art visualization with configurable parameters
     */
    render540InstallationArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 541: VideoArt
     * Video Art visualization with configurable parameters
     */
    render541VideoArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 542: DigitalArt
     * Digital Art visualization with configurable parameters
     */
    render542DigitalArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 543: GlitchArt
     * Glitch Art visualization with configurable parameters
     */
    render543GlitchArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 544: PixelArt
     * Pixel Art visualization with configurable parameters
     */
    render544PixelArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 545: AsciiArt
     * Ascii Art visualization with configurable parameters
     */
    render545AsciiArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 546: VectorArt
     * Vector Art visualization with configurable parameters
     */
    render546VectorArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 547: FractalArt
     * Fractal Art visualization with configurable parameters
     */
    render547FractalArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 548: AlgorithmicArt
     * Algorithmic Art visualization with configurable parameters
     */
    render548AlgorithmicArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 549: GenerativeArt
     * Generative Art visualization with configurable parameters
     */
    render549GenerativeArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 550: DataArt
     * Data Art visualization with configurable parameters
     */
    render550DataArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 551: BioArt
     * Bio Art visualization with configurable parameters
     */
    render551BioArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 552: NetArt
     * Net Art visualization with configurable parameters
     */
    render552NetArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 553: SoftwareArt
     * Software Art visualization with configurable parameters
     */
    render553SoftwareArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 554: RoboticArt
     * Robotic Art visualization with configurable parameters
     */
    render554RoboticArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 555: InteractiveArt
     * Interactive Art visualization with configurable parameters
     */
    render555InteractiveArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 556: ProjectionMapping
     * Projection Mapping visualization with configurable parameters
     */
    render556ProjectionMapping(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 557: HolographicArt
     * Holographic Art visualization with configurable parameters
     */
    render557HolographicArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 558: AugmentedRealityArt
     * Augmented Reality Art visualization with configurable parameters
     */
    render558AugmentedRealityArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 559: VrArt
     * Vr Art visualization with configurable parameters
     */
    render559VrArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 560: ProceduralArt
     * Procedural Art visualization with configurable parameters
     */
    render560ProceduralArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 561: ParametricArt
     * Parametric Art visualization with configurable parameters
     */
    render561ParametricArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 562: MathematicalArt
     * Mathematical Art visualization with configurable parameters
     */
    render562MathematicalArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 563: GeometricArt
     * Geometric Art visualization with configurable parameters
     */
    render563GeometricArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 564: TessellationArt
     * Tessellation Art visualization with configurable parameters
     */
    render564TessellationArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 565: SymmetryArt
     * Symmetry Art visualization with configurable parameters
     */
    render565SymmetryArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 566: KaleidoscopeArt
     * Kaleidoscope Art visualization with configurable parameters
     */
    render566KaleidoscopeArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 567: MandalaArt
     * Mandala Art visualization with configurable parameters
     */
    render567MandalaArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 568: ZentangleArt
     * Zentangle Art visualization with configurable parameters
     */
    render568ZentangleArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 569: DoodleArt
     * Doodle Art visualization with configurable parameters
     */
    render569DoodleArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 570: StreetArt
     * Street Art visualization with configurable parameters
     */
    render570StreetArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 571: GraffitiArt
     * Graffiti Art visualization with configurable parameters
     */
    render571GraffitiArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 572: MuralArt
     * Mural Art visualization with configurable parameters
     */
    render572MuralArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 573: StencilArt
     * Stencil Art visualization with configurable parameters
     */
    render573StencilArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 574: WheatPasteArt
     * Wheat Paste Art visualization with configurable parameters
     */
    render574WheatPasteArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 575: SprayPaintArt
     * Spray Paint Art visualization with configurable parameters
     */
    render575SprayPaintArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 576: MosaicArt
     * Mosaic Art visualization with configurable parameters
     */
    render576MosaicArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 577: CollageArt
     * Collage Art visualization with configurable parameters
     */
    render577CollageArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 578: MixedMediaArt
     * Mixed Media Art visualization with configurable parameters
     */
    render578MixedMediaArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 579: AssemblageArt
     * Assemblage Art visualization with configurable parameters
     */
    render579AssemblageArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 580: FoundObjectArt
     * Found Object Art visualization with configurable parameters
     */
    render580FoundObjectArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 581: ReadymadeArt
     * Readymade Art visualization with configurable parameters
     */
    render581ReadymadeArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 582: AppropriationArt
     * Appropriation Art visualization with configurable parameters
     */
    render582AppropriationArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 583: SamplingArt
     * Sampling Art visualization with configurable parameters
     */
    render583SamplingArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 584: RemixArt
     * Remix Art visualization with configurable parameters
     */
    render584RemixArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 585: MashupArt
     * Mashup Art visualization with configurable parameters
     */
    render585MashupArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 586: Photomontage
     * Photomontage visualization with configurable parameters
     */
    render586Photomontage(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 587: CutUpTechnique
     * Cut Up Technique visualization with configurable parameters
     */
    render587CutUpTechnique(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 588: ExquisiteCorpse
     * Exquisite Corpse visualization with configurable parameters
     */
    render588ExquisiteCorpse(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 589: AutomaticDrawing
     * Automatic Drawing visualization with configurable parameters
     */
    render589AutomaticDrawing(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 590: ChanceArt
     * Chance Art visualization with configurable parameters
     */
    render590ChanceArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 591: IndeterminacyArt
     * Indeterminacy Art visualization with configurable parameters
     */
    render591IndeterminacyArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 592: AleatoryArt
     * Aleatory Art visualization with configurable parameters
     */
    render592AleatoryArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 593: StochasticArt
     * Stochastic Art visualization with configurable parameters
     */
    render593StochasticArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 594: EntropyArt
     * Entropy Art visualization with configurable parameters
     */
    render594EntropyArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 595: ChaosArt
     * Chaos Art visualization with configurable parameters
     */
    render595ChaosArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 596: ComplexityArt
     * Complexity Art visualization with configurable parameters
     */
    render596ComplexityArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 597: EmergenceArt
     * Emergence Art visualization with configurable parameters
     */
    render597EmergenceArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 598: SelfOrganizationArt
     * Self Organization Art visualization with configurable parameters
     */
    render598SelfOrganizationArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 600: FlockingArt
     * Flocking Art visualization with configurable parameters
     */
    render600FlockingArt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 601: Nebula
     * Nebula visualization with configurable parameters
     */
    render601Nebula(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 602: GalaxySpiral
     * Galaxy Spiral visualization with configurable parameters
     */
    render602GalaxySpiral(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 603: BlackHole
     * Black Hole visualization with configurable parameters
     */
    render603BlackHole(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 604: Pulsar
     * Pulsar visualization with configurable parameters
     */
    render604Pulsar(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 605: Quasar
     * Quasar visualization with configurable parameters
     */
    render605Quasar(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 606: Supernova
     * Supernova visualization with configurable parameters
     */
    render606Supernova(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 607: StarCluster
     * Star Cluster visualization with configurable parameters
     */
    render607StarCluster(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 608: AsteroidBelt
     * Asteroid Belt visualization with configurable parameters
     */
    render608AsteroidBelt(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 609: CometTail
     * Comet Tail visualization with configurable parameters
     */
    render609CometTail(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 610: MeteorShower
     * Meteor Shower visualization with configurable parameters
     */
    render610MeteorShower(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 611: PlanetaryRings
     * Planetary Rings visualization with configurable parameters
     */
    render611PlanetaryRings(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 612: SolarFlare
     * Solar Flare visualization with configurable parameters
     */
    render612SolarFlare(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 613: CoronalMassEjection
     * Coronal Mass Ejection visualization with configurable parameters
     */
    render613CoronalMassEjection(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 614: CosmicRay
     * Cosmic Ray visualization with configurable parameters
     */
    render614CosmicRay(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 615: GammaRayBurst
     * Gamma Ray Burst visualization with configurable parameters
     */
    render615GammaRayBurst(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 616: GravitationalLens
     * Gravitational Lens visualization with configurable parameters
     */
    render616GravitationalLens(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 617: DarkMatterHalo
     * Dark Matter Halo visualization with configurable parameters
     */
    render617DarkMatterHalo(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 618: CosmicWeb
     * Cosmic Web visualization with configurable parameters
     */
    render618CosmicWeb(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 619: Void
     * Void visualization with configurable parameters
     */
    render619Void(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 620: FilamentStructure
     * Filament Structure visualization with configurable parameters
     */
    render620FilamentStructure(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 621: HubbleDeepField
     * Hubble Deep Field visualization with configurable parameters
     */
    render621HubbleDeepField(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 622: GalaxyCollision
     * Galaxy Collision visualization with configurable parameters
     */
    render622GalaxyCollision(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 623: TidalTail
     * Tidal Tail visualization with configurable parameters
     */
    render623TidalTail(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 624: StarburstGalaxy
     * Starburst Galaxy visualization with configurable parameters
     */
    render624StarburstGalaxy(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 625: ActiveGalacticNucleus
     * Active Galactic Nucleus visualization with configurable parameters
     */
    render625ActiveGalacticNucleus(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 626: Blazar
     * Blazar visualization with configurable parameters
     */
    render626Blazar(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 627: SeyfertGalaxy
     * Seyfert Galaxy visualization with configurable parameters
     */
    render627SeyfertGalaxy(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 628: RadioGalaxy
     * Radio Galaxy visualization with configurable parameters
     */
    render628RadioGalaxy(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 629: EllipticalGalaxy
     * Elliptical Galaxy visualization with configurable parameters
     */
    render629EllipticalGalaxy(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 630: IrregularGalaxy
     * Irregular Galaxy visualization with configurable parameters
     */
    render630IrregularGalaxy(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 631: DwarfGalaxy
     * Dwarf Galaxy visualization with configurable parameters
     */
    render631DwarfGalaxy(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 632: GlobularCluster
     * Globular Cluster visualization with configurable parameters
     */
    render632GlobularCluster(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 633: OpenCluster
     * Open Cluster visualization with configurable parameters
     */
    render633OpenCluster(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 634: ProtoplanetaryDisk
     * Protoplanetary Disk visualization with configurable parameters
     */
    render634ProtoplanetaryDisk(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 635: AccretionDisk
     * Accretion Disk visualization with configurable parameters
     */
    render635AccretionDisk(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 636: JetsFromBlackHole
     * Jets From Black Hole visualization with configurable parameters
     */
    render636JetsFromBlackHole(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 637: EventHorizon
     * Event Horizon visualization with configurable parameters
     */
    render637EventHorizon(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 638: PhotonSphere
     * Photon Sphere visualization with configurable parameters
     */
    render638PhotonSphere(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 639: Ergosphere
     * Ergosphere visualization with configurable parameters
     */
    render639Ergosphere(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 640: Singularity
     * Singularity visualization with configurable parameters
     */
    render640Singularity(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 641: Wormhole
     * Wormhole visualization with configurable parameters
     */
    render641Wormhole(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 642: WhiteHole
     * White Hole visualization with configurable parameters
     */
    render642WhiteHole(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 643: NakedSingularity
     * Naked Singularity visualization with configurable parameters
     */
    render643NakedSingularity(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 644: HawkingRadiation
     * Hawking Radiation visualization with configurable parameters
     */
    render644HawkingRadiation(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 645: InformationParadox
     * Information Paradox visualization with configurable parameters
     */
    render645InformationParadox(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 646: MultiverseBubble
     * Multiverse Bubble visualization with configurable parameters - particle-based
     */
    render646MultiverseBubble(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        // Particle properties (configurable via parameters)
        const particleSize = params.particleSize || 6; // Size of each square particle
        const particleSpacing = params.particleSpacing || 3; // Space between particles
        const glowIntensity = params.glowIntensity !== undefined ? params.glowIntensity : 25;
        const barWidth = 50; // Width of the bar

        // Animation time for floating effect
        const time = Date.now() * 0.001 * speed;

        // Enable glow effect
        this.ctx.shadowBlur = glowIntensity;

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.canvas.width + this.canvas.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.canvas.height * 0.7;

            const color = this.getColor(i, numColumns);
            this.ctx.shadowColor = color;

            // Calculate number of particles needed to fill the height
            const numParticlesVertical = Math.floor(height / particleSpacing);
            const numParticlesHorizontal = Math.floor(barWidth / particleSpacing);

            // Draw particles forming the bar
            for (let py = 0; py < numParticlesVertical; py++) {
                for (let px = 0; px < numParticlesHorizontal; px++) {
                    // Calculate particle position
                    const particleX = x - barWidth/2 + px * particleSpacing;
                    const particleY = this.canvas.height - (py * particleSpacing);

                    // Add floating/bubble animation
                    const floatOffset = Math.sin(time + i + py * 0.5 + px * 0.3) * 3;
                    const driftOffset = Math.cos(time * 0.7 + i + py * 0.2) * 2;

                    // Vary particle opacity based on position (fade towards top)
                    const opacityFactor = 0.8 + (py / numParticlesVertical) * 0.2;

                    // Extract RGB from color string
                    const rgb = color.match(/\d+/g);
                    this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${opacityFactor})`;

                    // Draw small square particle
                    this.ctx.fillRect(
                        particleX + driftOffset,
                        particleY + floatOffset,
                        particleSize,
                        particleSize
                    );

                    // Add bright core to some particles for extra glow
                    if ((px + py) % 3 === 0) {
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${opacityFactor * 0.5})`;
                        this.ctx.fillRect(
                            particleX + driftOffset + particleSize/4,
                            particleY + floatOffset + particleSize/4,
                            particleSize/2,
                            particleSize/2
                        );
                    }
                }
            }
        }

        // Reset shadow
        this.ctx.shadowBlur = 0;
    }
    /**
     * Mode 647: ParallelUniverse
     * Parallel Universe visualization with configurable parameters
     */
    render647ParallelUniverse(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 648: BraneCollision
     * Brane Collision visualization with configurable parameters
     */
    render648BraneCollision(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 649: ExtraDimensions
     * Extra Dimensions visualization with configurable parameters
     */
    render649ExtraDimensions(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 650: CalabiYauManifold
     * Calabi Yau Manifold visualization with configurable parameters
     */
    render650CalabiYauManifold(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 651: StringTheoryVibration
     * String Theory Vibration visualization with configurable parameters
     */
    render651StringTheoryVibration(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 652: QuantumFoam
     * Quantum Foam visualization with configurable parameters
     */
    render652QuantumFoam(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 653: PlanckScale
     * Planck Scale visualization with configurable parameters
     */
    render653PlanckScale(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 654: BigBang
     * Big Bang visualization with configurable parameters
     */
    render654BigBang(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 655: CosmicMicrowaveBackground
     * Cosmic Microwave Background visualization with configurable parameters
     */
    render655CosmicMicrowaveBackground(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 656: InflationField
     * Inflation Field visualization with configurable parameters
     */
    render656InflationField(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 657: DensityFluctuations
     * Density Fluctuations visualization with configurable parameters
     */
    render657DensityFluctuations(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 658: BaryonAcousticOscillations
     * Baryon Acoustic Oscillations visualization with configurable parameters
     */
    render658BaryonAcousticOscillations(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 659: DarkEnergy
     * Dark Energy visualization with configurable parameters
     */
    render659DarkEnergy(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 660: CosmologicalConstant
     * Cosmological Constant visualization with configurable parameters
     */
    render660CosmologicalConstant(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 661: QuintessenceField
     * Quintessence Field visualization with configurable parameters
     */
    render661QuintessenceField(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 662: HeatDeath
     * Heat Death visualization with configurable parameters
     */
    render662HeatDeath(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 663: BigRip
     * Big Rip visualization with configurable parameters
     */
    render663BigRip(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 664: BigCrunch
     * Big Crunch visualization with configurable parameters
     */
    render664BigCrunch(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 665: BigBounce
     * Big Bounce visualization with configurable parameters
     */
    render665BigBounce(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 666: CyclicUniverse
     * Cyclic Universe visualization with configurable parameters
     */
    render666CyclicUniverse(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 667: ConformalCyclicCosmology
     * Conformal Cyclic Cosmology visualization with configurable parameters
     */
    render667ConformalCyclicCosmology(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 668: EternalInflation
     * Eternal Inflation visualization with configurable parameters
     */
    render668EternalInflation(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 669: LandscapeMultiverse
     * Landscape Multiverse visualization with configurable parameters
     */
    render669LandscapeMultiverse(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 670: QuantumDecoherence
     * Quantum Decoherence visualization with configurable parameters
     */
    render670QuantumDecoherence(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 671: ManyWorlds
     * Many Worlds visualization with configurable parameters
     */
    render671ManyWorlds(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 672: PilotWave
     * Pilot Wave visualization with configurable parameters
     */
    render672PilotWave(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 673: SpontaneousCollapse
     * Spontaneous Collapse visualization with configurable parameters
     */
    render673SpontaneousCollapse(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 674: TransactionalInterpretation
     * Transactional Interpretation visualization with configurable parameters
     */
    render674TransactionalInterpretation(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 675: RelationalQuantumMechanics
     * Relational Quantum Mechanics visualization with configurable parameters
     */
    render675RelationalQuantumMechanics(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 676: QuantumBayesianism
     * Quantum Bayesianism visualization with configurable parameters
     */
    render676QuantumBayesianism(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 677: ConsistentHistories
     * Consistent Histories visualization with configurable parameters
     */
    render677ConsistentHistories(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 678: BohemianMechanics
     * Bohemian Mechanics visualization with configurable parameters
     */
    render678BohemianMechanics(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 679: StochasticMechanics
     * Stochastic Mechanics visualization with configurable parameters
     */
    render679StochasticMechanics(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 680: QuantumDarwinism
     * Quantum Darwinism visualization with configurable parameters
     */
    render680QuantumDarwinism(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 681: Einselection
     * Einselection visualization with configurable parameters
     */
    render681Einselection(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 682: PointerStates
     * Pointer States visualization with configurable parameters
     */
    render682PointerStates(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 683: BranchingSpacetime
     * Branching Spacetime visualization with configurable parameters
     */
    render683BranchingSpacetime(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 684: Worldline
     * Worldline visualization with configurable parameters
     */
    render684Worldline(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 685: LightCone
     * Light Cone visualization with configurable parameters
     */
    render685LightCone(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 686: CauchySurface
     * Cauchy Surface visualization with configurable parameters
     */
    render686CauchySurface(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 687: SpacelikeHypersurface
     * Spacelike Hypersurface visualization with configurable parameters
     */
    render687SpacelikeHypersurface(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 688: TimelikeCurve
     * Timelike Curve visualization with configurable parameters
     */
    render688TimelikeCurve(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 689: ClosedTimelikeCurve
     * Closed Timelike Curve visualization with configurable parameters
     */
    render689ClosedTimelikeCurve(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 690: ChronologyProtection
     * Chronology Protection visualization with configurable parameters
     */
    render690ChronologyProtection(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 691: NovikovSelfConsistency
     * Novikov Self Consistency visualization with configurable parameters
     */
    render691NovikovSelfConsistency(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 692: GrandfatherParadox
     * Grandfather Paradox visualization with configurable parameters
     */
    render692GrandfatherParadox(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 693: BootstrapParadox
     * Bootstrap Paradox visualization with configurable parameters
     */
    render693BootstrapParadox(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 694: PredestinationParadox
     * Predestination Paradox visualization with configurable parameters
     */
    render694PredestinationParadox(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 695: CausalLoop
     * Causal Loop visualization with configurable parameters
     */
    render695CausalLoop(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 696: Retrocausality
     * Retrocausality visualization with configurable parameters
     */
    render696Retrocausality(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 697: AdvancedWave
     * Advanced Wave visualization with configurable parameters
     */
    render697AdvancedWave(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 698: WheelerFeynmanAbsorber
     * Wheeler Feynman Absorber visualization with configurable parameters
     */
    render698WheelerFeynmanAbsorber(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 699: TransactionalInterpretation
     * Transactional Interpretation visualization with configurable parameters
     */
    render699TransactionalInterpretation(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }
    /**
     * Mode 700: TwoStateVector
     * Two State Vector visualization with configurable parameters
     */
    render700TwoStateVector(magnitudes) {
        const params = this.settings.modeParameters || {};
        const intensity = params.intensity || 1;
        const speed = params.speed || 1;
        const complexity = Math.floor(params.complexity || 5);

        // Use complexity to determine number of columns (3-12 range)
        const numColumns = Math.max(3, Math.min(12, complexity + 3));

        for (let i = 0; i < numColumns; i++) {
            const x = (i / numColumns) * this.width + this.width / (2 * numColumns);
            const magIdx = Math.floor((i * magnitudes.length) / numColumns);
            const mag = magnitudes[magIdx] * intensity;
            const height = mag * this.height * 0.7;

            const color = this.getColor(i, numColumns);

            // Filled rectangle
            this.ctx.fillStyle = color;
            this.ctx.fillRect(x - 20, this.height - height, 40, height);

            // Border rectangle for depth
            this.ctx.strokeStyle = this.adjustBrightness(color, 20);
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(x - 20, this.height - height, 40, height);
        }
    }


    generatePreview(magnitudes) {
        if (!magnitudes) {
            // Generate demo data
            magnitudes = new Float32Array(this.settings.numBars);
            for (let i = 0; i < magnitudes.length; i++) {
                magnitudes[i] = Math.random() * 0.5 + 0.3;
            }
        }
    }

    // ========================================
    // AUTO-GENERATED MODE IMPLEMENTATIONS (401-500)
    // ========================================

    renderMode401_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 401 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode402_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 402 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode403_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 403 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode404_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 404 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode405_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 405 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode406_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 406 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode407_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 407 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode408_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 408 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode409_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 409 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode410_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 410 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode411_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 411 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode412_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 412 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode413_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 413 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode414_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 414 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode415_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 415 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode416_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 416 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode417_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 417 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode418_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 418 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode419_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 419 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode420_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 420 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode421_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 421 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode422_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 422 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode423_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 423 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode424_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 424 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode425_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 425 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode426_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 426 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode427_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 427 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode428_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 428 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode429_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 429 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode430_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 430 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode431_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 431 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode432_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 432 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode433_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 433 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode434_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 434 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode435_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 435 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode436_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 436 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode437_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 437 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode438_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 438 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode439_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 439 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode440_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 440 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode441_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 441 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode442_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 442 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode443_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 443 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode444_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 444 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode445_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 445 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode446_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 446 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode447_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 447 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode448_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 448 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode449_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 449 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode450_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 450 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode451_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 451 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode452_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 452 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode453_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 453 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode454_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 454 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode455_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 455 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode456_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 456 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode457_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 457 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode458_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 458 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode459_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 459 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode460_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 460 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode461_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 461 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode462_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 462 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode463_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 463 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode464_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 464 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode465_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 465 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode466_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 466 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode467_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 467 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode468_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 468 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode469_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 469 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode470_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 470 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode471_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 471 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode472_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 472 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode473_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 473 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode474_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 474 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode475_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 475 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode476_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 476 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode477_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 477 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode478_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 478 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode479_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 479 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode480_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 480 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode481_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 481 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode482_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 482 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode483_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 483 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode484_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 484 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode485_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 485 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode486_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 486 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode487_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 487 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode488_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 488 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode489_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 489 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode490_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 490 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode491_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 491 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode492_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 492 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode493_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 493 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode494_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 494 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode495_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 495 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode496_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 496 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode497_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 497 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode498_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 498 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode499_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 499 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    renderMode500_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Mode 500 - Audio-reactive visualization
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Circular particle visualization
        for (let i = 0; i < Math.min(magnitudes.length, this.settings.numBars || 64); i++) {
            const mag = magnitudes[i];
            const angle = (i / magnitudes.length) * Math.PI * 2 + this.frameCounter * 0.05 * speed;
            const radius = this.maxRadius * 0.3 + mag * this.maxRadius * 0.5 * intensity;

            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;

            const size = 2 + mag * 8 * intensity;
            this.ctx.fillStyle = this.getColor(i, magnitudes.length);
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
    }

    /**
     * Convert HSV to RGB
     * @param {number} h - Hue (0-360)
     * @param {number} s - Saturation (0-100)
     * @param {number} v - Value (0-100)
     * @returns {Array} RGB array [r, g, b] (0-255)
     */
    hsvToRgb(h, s, v) {
        h = h / 360;
        s = s / 100;
        v = v / 100;

        let r, g, b;
        const i = Math.floor(h * 6);
        const f = h * 6 - i;
        const p = v * (1 - s);
        const q = v * (1 - f * s);
        const t = v * (1 - (1 - f) * s);

        switch (i % 6) {
            case 0: r = v; g = t; b = p; break;
            case 1: r = q; g = v; b = p; break;
            case 2: r = p; g = v; b = t; break;
            case 3: r = p; g = q; b = v; break;
            case 4: r = t; g = p; b = v; break;
            case 5: r = v; g = p; b = q; break;
        }

        return [
            Math.round(r * 255),
            Math.round(g * 255),
            Math.round(b * 255)
        ];
    }

    /**
     * Shared implementation for modes 401-500
     * Provides audio-reactive circular visualization
     */
    renderMode401_500_IMPL(magnitudes, bass, mids, treble, intensity, speed, complexity) {
        // Enhanced stub implementation - generates unique visualizations based on mode
        const modeId = this.settings.mode || '';
        const modeNum = parseInt(modeId.match(/\d+/)?.[0] || '0');

        // Use mode number as seed for variation
        const seed = modeNum;
        const variant = seed % 10;

        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const numBars = Math.min(magnitudes.length, this.settings.numBars || 64);

        // Generate unique visualization based on mode variant
        switch (variant) {
            case 0: // Orbital rings
                this.renderOrbitalRings(magnitudes, bass, mids, treble, intensity, speed, complexity, seed);
                break;
            case 1: // Spiral waves
                this.renderSpiralWaves(magnitudes, bass, mids, treble, intensity, speed, complexity, seed);
                break;
            case 2: // Radial burst
                this.renderRadialBurst(magnitudes, bass, mids, treble, intensity, speed, complexity, seed);
                break;
            case 3: // Wave interference
                this.renderWaveInterferencePattern(magnitudes, bass, mids, treble, intensity, speed, complexity, seed);
                break;
            case 4: // Particle field
                this.renderParticleField(magnitudes, bass, mids, treble, intensity, speed, complexity, seed);
                break;
            case 5: // Geometric patterns
                this.renderGeometricPattern(magnitudes, bass, mids, treble, intensity, speed, complexity, seed);
                break;
            case 6: // Energy pulses
                this.renderEnergyPulses(magnitudes, bass, mids, treble, intensity, speed, complexity, seed);
                break;
            case 7: // Frequency bands
                this.renderFrequencyBands(magnitudes, bass, mids, treble, intensity, speed, complexity, seed);
                break;
            case 8: // Circular flow
                this.renderCircularFlow(magnitudes, bass, mids, treble, intensity, speed, complexity, seed);
                break;
            case 9: // Crystal formation
                this.renderCrystalFormation(magnitudes, bass, mids, treble, intensity, speed, complexity, seed);
                break;
        }

        this.ctx.globalAlpha = 1;
    }

    // Variant implementations for mode stub system
    renderOrbitalRings(magnitudes, bass, mids, treble, intensity, speed, complexity, seed) {
        const numRings = 3 + Math.floor(complexity / 3);
        for (let ring = 0; ring < numRings; ring++) {
            const ringRadius = this.maxRadius * (0.2 + ring * 0.15);
            const numPoints = 16 + ring * 8;
            for (let i = 0; i < numPoints; i++) {
                const mag = magnitudes[i % magnitudes.length];
                const angle = (i / numPoints) * Math.PI * 2 + this.frameCounter * 0.02 * speed * (1 + ring * 0.5);
                const r = ringRadius + mag * 40 * intensity;
                const x = this.centerX + Math.cos(angle) * r;
                const y = this.centerY + Math.sin(angle) * r;
                const size = 2 + mag * 6 * intensity;
                this.ctx.fillStyle = this.getColor(i + ring * 20, numPoints * numRings);
                this.ctx.globalAlpha = 0.6 + mag * 0.4;
                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    renderSpiralWaves(magnitudes, bass, mids, treble, intensity, speed, complexity, seed) {
        const numSpirals = 2 + Math.floor(complexity / 4);
        for (let spiral = 0; spiral < numSpirals; spiral++) {
            const spiralOffset = (spiral / numSpirals) * Math.PI * 2;
            for (let i = 0; i < magnitudes.length; i++) {
                const mag = magnitudes[i];
                const t = i / magnitudes.length;
                const angle = spiralOffset + t * Math.PI * 4 + this.frameCounter * 0.01 * speed;
                const r = this.maxRadius * (0.2 + t * 0.6) + mag * 50 * intensity;
                const x = this.centerX + Math.cos(angle) * r;
                const y = this.centerY + Math.sin(angle) * r;
                const size = 2 + mag * 5 * intensity;
                this.ctx.fillStyle = this.getColor(i, magnitudes.length);
                this.ctx.globalAlpha = 0.5 + mag * 0.5;
                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    renderRadialBurst(magnitudes, bass, mids, treble, intensity, speed, complexity, seed) {
        const numRays = Math.min(magnitudes.length, 72);
        for (let i = 0; i < numRays; i++) {
            const mag = magnitudes[i];
            const angle = (i / numRays) * Math.PI * 2;
            const baseR = this.maxRadius * 0.15;
            const maxR = baseR + mag * this.maxRadius * 0.7 * intensity;

            // Draw ray as line of circles
            const steps = 10 + Math.floor(complexity);
            for (let step = 0; step < steps; step++) {
                const t = step / steps;
                const r = Utils.lerp(baseR, maxR, t);
                const x = this.centerX + Math.cos(angle) * r;
                const y = this.centerY + Math.sin(angle) * r;
                const size = (1 + mag * 4 * intensity) * (1 - t * 0.5);
                this.ctx.fillStyle = this.getColor(i, numRays);
                this.ctx.globalAlpha = (0.7 - t * 0.5) * (0.5 + mag * 0.5);
                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    renderWaveInterferencePattern(magnitudes, bass, mids, treble, intensity, speed, complexity, seed) {
        const gridSize = 8 + Math.floor(complexity);
        const cellSize = (this.maxRadius * 2) / gridSize;

        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                const x = this.centerX - this.maxRadius + i * cellSize;
                const y = this.centerY - this.maxRadius + j * cellSize;
                const dx = x - this.centerX;
                const dy = y - this.centerY;
                const dist = Math.sqrt(dx * dx + dy * dy) / this.maxRadius;
                const magIndex = Math.floor(dist * magnitudes.length) % magnitudes.length;
                const mag = magnitudes[magIndex];
                const wave = Math.sin(dist * 8 - this.frameCounter * 0.05 * speed + mag * 2) * 0.5 + 0.5;
                const size = cellSize * 0.3 * wave * mag * intensity;

                if (size > 1) {
                    this.ctx.fillStyle = this.getColor(magIndex, magnitudes.length);
                    this.ctx.globalAlpha = 0.4 + mag * 0.6;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
        }
    }

    renderParticleField(magnitudes, bass, mids, treble, intensity, speed, complexity, seed) {
        const numParticles = Math.min(magnitudes.length * 2, 128);
        for (let i = 0; i < numParticles; i++) {
            const mag = magnitudes[i % magnitudes.length];
            const angle1 = (i / numParticles) * Math.PI * 2;
            const angle2 = angle1 + this.frameCounter * 0.02 * speed;
            const r1 = this.maxRadius * (0.3 + Math.sin(this.frameCounter * 0.01 + i) * 0.2);
            const r2 = r1 + mag * 100 * intensity;
            const x = this.centerX + Math.cos(angle2) * r2;
            const y = this.centerY + Math.sin(angle2) * r2;
            const size = 1 + mag * 4 * intensity;
            this.ctx.fillStyle = this.getColor(i, numParticles);
            this.ctx.globalAlpha = 0.4 + mag * 0.6;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    renderGeometricPattern(magnitudes, bass, mids, treble, intensity, speed, complexity, seed) {
        const numShapes = 6 + Math.floor(complexity);
        for (let i = 0; i < numShapes; i++) {
            const mag = magnitudes[Math.floor((i / numShapes) * magnitudes.length)];
            const angle = (i / numShapes) * Math.PI * 2 + this.frameCounter * 0.02 * speed;
            const r = this.maxRadius * (0.3 + mag * 0.4 * intensity);
            const x = this.centerX + Math.cos(angle) * r;
            const y = this.centerY + Math.sin(angle) * r;
            const sides = 3 + (i % 5);
            const size = 20 + mag * 40 * intensity;

            this.ctx.strokeStyle = this.getColor(i, numShapes);
            this.ctx.lineWidth = 2 + mag * 3 * intensity;
            this.ctx.globalAlpha = 0.5 + mag * 0.5;
            this.ctx.beginPath();
            for (let s = 0; s <= sides; s++) {
                const a = (s / sides) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
                const px = x + Math.cos(a) * size;
                const py = y + Math.sin(a) * size;
                if (s === 0) this.ctx.moveTo(px, py);
                else this.ctx.lineTo(px, py);
            }
            this.ctx.stroke();
        }
    }

    renderEnergyPulses(magnitudes, bass, mids, treble, intensity, speed, complexity, seed) {
        const numPulses = 5 + Math.floor(complexity / 2);
        for (let i = 0; i < numPulses; i++) {
            const mag = bass * (i % 2) + mids * ((i + 1) % 2);
            const t = (this.frameCounter * 0.02 * speed + i * 0.3) % 1;
            const r = this.maxRadius * t * (0.5 + mag * 0.5 * intensity);
            const alpha = (1 - t) * (0.3 + mag * 0.7);

            this.ctx.strokeStyle = this.getColor(i * 30, numPulses * 30);
            this.ctx.lineWidth = 2 + mag * 4 * intensity;
            this.ctx.globalAlpha = alpha;
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, r, 0, Math.PI * 2);
            this.ctx.stroke();
        }
    }

    renderFrequencyBands(magnitudes, bass, mids, treble, intensity, speed, complexity, seed) {
        const bands = 5 + Math.floor(complexity / 2);
        const bandSize = magnitudes.length / bands;

        for (let band = 0; band < bands; band++) {
            const start = Math.floor(band * bandSize);
            const end = Math.floor((band + 1) * bandSize);
            const bandMag = magnitudes.slice(start, end).reduce((a, b) => a + b, 0) / bandSize;

            const innerR = this.maxRadius * (0.2 + band * 0.15);
            const outerR = innerR + bandMag * 80 * intensity;
            const numBars = 24 + band * 12;

            for (let i = 0; i < numBars; i++) {
                const angle = (i / numBars) * Math.PI * 2 + this.frameCounter * 0.01 * speed * (1 + band * 0.2);
                const x1 = this.centerX + Math.cos(angle) * innerR;
                const y1 = this.centerY + Math.sin(angle) * innerR;
                const x2 = this.centerX + Math.cos(angle) * outerR;
                const y2 = this.centerY + Math.sin(angle) * outerR;

                this.ctx.strokeStyle = this.getColor(band * 30 + i, bands * 30 + numBars);
                this.ctx.lineWidth = 2 + bandMag * 3 * intensity;
                this.ctx.globalAlpha = 0.5 + bandMag * 0.5;
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x2, y2);
                this.ctx.stroke();
            }
        }
    }

    renderCircularFlow(magnitudes, bass, mids, treble, intensity, speed, complexity, seed) {
        const numFlows = 3 + Math.floor(complexity / 3);
        for (let flow = 0; flow < numFlows; flow++) {
            const flowAngle = (flow / numFlows) * Math.PI * 2;
            const numPoints = 32;

            for (let i = 0; i < numPoints; i++) {
                const mag = magnitudes[Math.floor((i / numPoints) * magnitudes.length)];
                const t = i / numPoints;
                const angle = flowAngle + t * Math.PI * 2 + this.frameCounter * 0.03 * speed * (flow + 1);
                const baseR = this.maxRadius * (0.25 + flow * 0.15);
                const r = baseR + Math.sin(t * Math.PI * 4 + this.frameCounter * 0.1) * 30 * mag * intensity;
                const x = this.centerX + Math.cos(angle) * r;
                const y = this.centerY + Math.sin(angle) * r;
                const size = 2 + mag * 5 * intensity;

                this.ctx.fillStyle = this.getColor(flow * 40 + i, numFlows * 40 + numPoints);
                this.ctx.globalAlpha = 0.5 + mag * 0.5;
                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
    }

    renderCrystalFormation(magnitudes, bass, mids, treble, intensity, speed, complexity, seed) {
        const numCrystals = 8 + Math.floor(complexity);
        for (let i = 0; i < numCrystals; i++) {
            const angle = (i / numCrystals) * Math.PI * 2 + this.frameCounter * 0.01 * speed;
            const mag = magnitudes[Math.floor((i / numCrystals) * magnitudes.length)];
            const r = this.maxRadius * (0.3 + mag * 0.4 * intensity);
            const x = this.centerX + Math.cos(angle) * r;
            const y = this.centerY + Math.sin(angle) * r;

            // Draw crystal shape
            const size = 15 + mag * 35 * intensity;
            const points = 6;
            this.ctx.fillStyle = this.getColor(i, numCrystals);
            this.ctx.globalAlpha = 0.4 + mag * 0.6;
            this.ctx.beginPath();
            for (let p = 0; p < points; p++) {
                const pa = (p / points) * Math.PI * 2;
                const pr = size * (p % 2 === 0 ? 1 : 0.5);
                const px = x + Math.cos(pa) * pr;
                const py = y + Math.sin(pa) * pr;
                if (p === 0) this.ctx.moveTo(px, py);
                else this.ctx.lineTo(px, py);
            }
            this.ctx.closePath();
            this.ctx.fill();
        }
    }

    /**
     * Mode 405: Particle Accelerator
     * Particles accelerating in a ring with speed trails
     */
    render405ParticleAccelerator(magnitudes) {
        const numParticles = magnitudes.length;
        const innerRadius = this.getEffectiveInnerRadius();
        const maxRadius = this.maxRadius;

        // Initialize particle positions if not exists
        if (!this.acceleratorParticles) {
            this.acceleratorParticles = [];
            for (let i = 0; i < numParticles; i++) {
                this.acceleratorParticles.push({
                    angle: (i / numParticles) * Math.PI * 2,
                    speed: 0.01 + Math.random() * 0.02,
                    radius: innerRadius + Math.random() * (maxRadius - innerRadius) * 0.5,
                    trail: []
                });
            }
        }

        // Draw acceleration ring
        this.ctx.strokeStyle = this.getColor(0, numParticles);
        this.ctx.lineWidth = 2 * this.scaleFactor;
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, innerRadius + (maxRadius - innerRadius) * 0.3, 0, Math.PI * 2);
        this.ctx.stroke();

        // Update and draw particles with trails
        this.acceleratorParticles.forEach((particle, i) => {
            const magnitude = magnitudes[i];

            // Accelerate particle based on audio
            particle.speed += magnitude * 0.001;
            particle.speed = Math.min(particle.speed, 0.1); // Cap speed
            particle.angle += particle.speed;

            // Calculate position
            const x = this.centerX + Math.cos(particle.angle) * particle.radius;
            const y = this.centerY + Math.sin(particle.angle) * particle.radius;

            // Add to trail
            particle.trail.push({ x, y, alpha: 1.0 });
            if (particle.trail.length > 20) particle.trail.shift();

            // Draw trail
            particle.trail.forEach((point, j) => {
                const alpha = (j / particle.trail.length) * 0.5;
                const size = (magnitude * 4 + 2) * this.scaleFactor * (j / particle.trail.length);
                this.ctx.fillStyle = this.getColor(i, numParticles).replace('rgb', 'rgba').replace(')', `, ${alpha})`);
                this.ctx.beginPath();
                this.ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                this.ctx.fill();
            });

            // Draw particle
            const particleSize = (magnitude * 6 + 3) * this.scaleFactor;
            this.ctx.fillStyle = this.getColor(i, numParticles);
            this.ctx.shadowBlur = 10 * this.scaleFactor;
            this.ctx.shadowColor = this.getColor(i, numParticles);
            this.ctx.beginPath();
            this.ctx.arc(x, y, particleSize, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        });
    }

    /**
     * Mode 452: Particle Decay
     * Radioactive particle decay chain with fading particles
     */
    render452ParticleDecay(magnitudes) {
        const numParticles = magnitudes.length * 2;
        const centerRadius = this.maxRadius * 0.3;

        // Initialize decay particles if not exists
        if (!this.decayParticles) {
            this.decayParticles = [];
        }

        // Spawn new particles based on audio magnitude
        magnitudes.forEach((magnitude, i) => {
            if (magnitude > 0.3 && Math.random() < magnitude * 0.5) {
                const angle = (i / magnitudes.length) * Math.PI * 2;
                const speed = (magnitude * 6 + 2) * this.scaleFactor;
                this.decayParticles.push({
                    x: this.centerX,
                    y: this.centerY,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    decay: 0.015 + Math.random() * 0.01,
                    size: (magnitude * 16 + 8) * this.scaleFactor,
                    colorIndex: i
                });
            }
        });

        // Draw nucleus glow
        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
        const glowSize = (avgMagnitude * 60 + 40) * this.scaleFactor;
        const gradient = this.ctx.createRadialGradient(
            this.centerX, this.centerY, 0,
            this.centerX, this.centerY, glowSize
        );
        gradient.addColorStop(0, this.getColor(0, magnitudes.length).replace('rgb', 'rgba').replace(')', ', 0.8)'));
        gradient.addColorStop(0.5, this.getColor(Math.floor(magnitudes.length / 2), magnitudes.length).replace('rgb', 'rgba').replace(')', ', 0.3)'));
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        this.ctx.fillStyle = gradient;
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, glowSize, 0, Math.PI * 2);
        this.ctx.fill();

        // Update and draw decay particles
        this.decayParticles = this.decayParticles.filter(particle => {
            // Update position
            particle.x += particle.vx;
            particle.y += particle.vy;

            // Apply decay
            particle.life -= particle.decay;
            particle.vx *= 0.98; // Slow down
            particle.vy *= 0.98;

            // Draw particle
            if (particle.life > 0) {
                const alpha = particle.life;
                const size = particle.size * particle.life;
                this.ctx.fillStyle = this.getColor(particle.colorIndex, magnitudes.length)
                    .replace('rgb', 'rgba').replace(')', `, ${alpha})`);
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                this.ctx.fill();

                // Draw decay trail
                this.ctx.strokeStyle = this.getColor(particle.colorIndex, magnitudes.length)
                    .replace('rgb', 'rgba').replace(')', `, ${alpha * 0.3})`);
                this.ctx.lineWidth = size * 0.5;
                this.ctx.beginPath();
                this.ctx.moveTo(particle.x, particle.y);
                this.ctx.lineTo(particle.x - particle.vx * 2, particle.y - particle.vy * 2);
                this.ctx.stroke();
            }

            return particle.life > 0;
        });
    }

    /**
     * Mode 599: Swarm Art
     * Particle swarm with flocking behavior
     */
    render599SwarmArt(magnitudes) {
        const numSwarmers = magnitudes.length * 3;

        // Initialize swarm if not exists
        if (!this.swarmParticles || this.swarmParticles.length !== numSwarmers) {
            this.swarmParticles = [];
            for (let i = 0; i < numSwarmers; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * this.maxRadius * 0.5;
                this.swarmParticles.push({
                    x: this.centerX + Math.cos(angle) * distance,
                    y: this.centerY + Math.sin(angle) * distance,
                    vx: (Math.random() - 0.5) * 2 * this.scaleFactor,
                    vy: (Math.random() - 0.5) * 2 * this.scaleFactor,
                    colorIndex: Math.floor(i / 3)
                });
            }
        }

        const avgMagnitude = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Update swarm particles with flocking behavior
        this.swarmParticles.forEach((particle, i) => {
            // Get magnitude for this particle
            const magnitude = magnitudes[particle.colorIndex % magnitudes.length];

            // Calculate center pull (cohesion)
            const dx = this.centerX - particle.x;
            const dy = this.centerY - particle.y;
            const distToCenter = Math.sqrt(dx * dx + dy * dy);
            const centerPull = 0.02 * magnitude * this.scaleFactor;
            particle.vx += (dx / distToCenter) * centerPull;
            particle.vy += (dy / distToCenter) * centerPull;

            // Swirl around center based on audio
            const angle = Math.atan2(dy, dx);
            const swirlStrength = magnitude * 0.05 * this.scaleFactor;
            particle.vx += Math.cos(angle + Math.PI / 2) * swirlStrength;
            particle.vy += Math.sin(angle + Math.PI / 2) * swirlStrength;

            // Neighbor interaction (alignment + separation)
            let neighborVx = 0, neighborVy = 0, neighborCount = 0;
            const neighborDist = 50 * this.scaleFactor;

            this.swarmParticles.forEach((other, j) => {
                if (i !== j) {
                    const odx = other.x - particle.x;
                    const ody = other.y - particle.y;
                    const dist = Math.sqrt(odx * odx + ody * ody);

                    if (dist < neighborDist && dist > 0) {
                        // Separation
                        particle.vx -= (odx / dist) * 0.1 * this.scaleFactor;
                        particle.vy -= (ody / dist) * 0.1 * this.scaleFactor;

                        // Alignment
                        neighborVx += other.vx;
                        neighborVy += other.vy;
                        neighborCount++;
                    }
                }
            });

            if (neighborCount > 0) {
                particle.vx += (neighborVx / neighborCount - particle.vx) * 0.05;
                particle.vy += (neighborVy / neighborCount - particle.vy) * 0.05;
            }

            // Apply velocity limits
            const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
            const maxSpeed = (3 + magnitude * 2) * this.scaleFactor;
            if (speed > maxSpeed) {
                particle.vx = (particle.vx / speed) * maxSpeed;
                particle.vy = (particle.vy / speed) * maxSpeed;
            }

            // Update position
            particle.x += particle.vx;
            particle.y += particle.vy;

            // Bounce off edges
            const margin = 20 * this.scaleFactor;
            if (particle.x < margin || particle.x > this.canvas.width - margin) particle.vx *= -0.8;
            if (particle.y < margin || particle.y > this.canvas.height - margin) particle.vy *= -0.8;
        });

        // Draw swarm connections
        this.ctx.lineWidth = 1 * this.scaleFactor;
        const connectionDist = 80 * this.scaleFactor;
        this.swarmParticles.forEach((particle, i) => {
            this.swarmParticles.forEach((other, j) => {
                if (i < j) {
                    const dx = other.x - particle.x;
                    const dy = other.y - particle.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < connectionDist) {
                        const alpha = (1 - dist / connectionDist) * 0.3;
                        this.ctx.strokeStyle = this.getColor(particle.colorIndex, magnitudes.length)
                            .replace('rgb', 'rgba').replace(')', `, ${alpha})`);
                        this.ctx.beginPath();
                        this.ctx.moveTo(particle.x, particle.y);
                        this.ctx.lineTo(other.x, other.y);
                        this.ctx.stroke();
                    }
                }
            });
        });

        // Draw swarm particles
        this.swarmParticles.forEach(particle => {
            const magnitude = magnitudes[particle.colorIndex % magnitudes.length];
            const size = (magnitude * 5 + 3) * this.scaleFactor;

            this.ctx.fillStyle = this.getColor(particle.colorIndex, magnitudes.length);
            this.ctx.shadowBlur = 8 * this.scaleFactor;
            this.ctx.shadowColor = this.getColor(particle.colorIndex, magnitudes.length);
            this.ctx.beginPath();
            this.ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        });
    }

    /**
     * Mode 1005: V-Formation Migration
     * Geese flying in V-shaped formation
     */
    render1005VFormationMigration(magnitudes) {
        const params = this.settings.modeParameters || {};
        const birdCount = params.birdCount || 25;
        const wingSpan = params.wingSpan || 15;
        const formationSpread = params.formationSpread || 40;
        const speed = params.speed || 1.5;
        const trailLength = params.trailLength !== undefined ? params.trailLength : 0.2;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length * 0.25);
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Initialize formation
        if (!this.vFormationBirds || this.vFormationBirds.length !== birdCount) {
            this.vFormationBirds = [];
            for (let i = 0; i < birdCount; i++) {
                this.vFormationBirds.push({
                    phase: Math.random() * Math.PI * 2,
                    wingPhase: Math.random() * Math.PI * 2
                });
            }
            this.vFormationLeaderSwitch = 0;
        }

        // Motion trail
        if (trailLength > 0) {
            this.ctx.fillStyle = `rgba(0, 0, 0, ${trailLength})`;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        } else {
            this.drawBackground();
        }

        // Formation parameters
        const time = (this.frameCounter || 0) * 0.02 * speed;
        const centerX = this.centerX + Math.sin(time * 0.5) * 100;
        const centerY = this.centerY - 100 + Math.sin(time * 0.3) * 50;

        // Bass causes leader switch
        if (bass > 0.6 && (this.frameCounter || 0) - this.vFormationLeaderSwitch > 60) {
            this.vFormationLeaderSwitch = this.frameCounter || 0;
        }

        const leaderIndex = Math.floor(this.vFormationLeaderSwitch / 60) % birdCount;

        // Draw V-formation
        let formationPosition = 0;
        for (let i = 0; i < birdCount; i++) {
            const bird = this.vFormationBirds[i];
            const isLeader = i === leaderIndex;

            // Calculate position in V-formation (proper V-shape)
            let xOffset, yOffset;
            if (isLeader) {
                xOffset = 0;
                yOffset = 0;
            } else {
                formationPosition++;
                const side = formationPosition % 2 === 0 ? 1 : -1;
                const position = Math.floor((formationPosition + 1) / 2);
                // V-formation: birds trail behind AND to the sides
                xOffset = side * position * formationSpread * 0.7;
                yOffset = position * formationSpread * 0.8; // Birds trail behind leader
            }

            const x = centerX + xOffset;
            const y = centerY + yOffset;

            // Wing flapping (faster with treble)
            bird.wingPhase += (0.3 + treble * 0.2) * speed;
            const wingFlap = Math.sin(bird.wingPhase) * 0.4 + 0.6;
            const currentWingSpan = wingSpan * wingFlap;

            // Color
            const batColor = this.getColor(i, birdCount);
            const match = batColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            let r = 80, g = 80, b = 80;
            if (match) {
                r = parseInt(match[1]);
                g = parseInt(match[2]);
                b = parseInt(match[3]);
            }

            const magnitude = magnitudes[i % magnitudes.length];
            const opacity = 0.8 + magnitude * 0.2;
            const birdSize = (isLeader ? 1.3 : 1.0) * (1 + magnitude * 0.2);

            this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
            this.ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
            this.ctx.lineWidth = 2 * birdSize;
            this.ctx.shadowBlur = isLeader ? 15 : 8;
            this.ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.6)`;

            // Draw bird facing forward (V-formation flies horizontally)
            this.ctx.save();
            this.ctx.translate(x, y);

            // Draw wings
            this.ctx.beginPath();
            this.ctx.moveTo(-currentWingSpan, 2);
            this.ctx.quadraticCurveTo(-currentWingSpan * 0.5, -6 * birdSize, -2 * birdSize, -3 * birdSize);
            this.ctx.lineTo(0, -5 * birdSize);
            this.ctx.lineTo(2 * birdSize, -3 * birdSize);
            this.ctx.quadraticCurveTo(currentWingSpan * 0.5, -6 * birdSize, currentWingSpan, 2);
            this.ctx.stroke();

            // Body
            this.ctx.beginPath();
            this.ctx.arc(0, 0, 2.5 * birdSize, 0, Math.PI * 2);
            this.ctx.fill();

            this.ctx.restore();
        }

        this.ctx.shadowBlur = 0;
        this.frameCounter = (this.frameCounter || 0) + 1;
    }

    /**
     * Mode 1006: Diving Seagulls
     * Seagulls diving down and swooping back up
     */
    render1006DivingSeagulls(magnitudes) {
        const params = this.settings.modeParameters || {};
        const birdCount = params.birdCount || 20;
        const wingSpan = params.wingSpan || 17;
        const diveSpeed = params.diveSpeed || 2.5;
        const diveHeight = params.diveHeight || 0.6;
        const trailLength = params.trailLength !== undefined ? params.trailLength : 0.15;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length * 0.25);
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Initialize seagulls
        if (!this.divingSeagulls || this.divingSeagulls.length !== birdCount) {
            this.divingSeagulls = [];
            for (let i = 0; i < birdCount; i++) {
                this.divingSeagulls.push({
                    phase: Math.random() * Math.PI * 2,
                    offsetX: Math.random() * this.canvas.width,
                    offsetY: Math.random() * this.canvas.height * 0.8, // Vary starting heights
                    diveDepth: 0.4 + Math.random() * 0.5, // Each bird dives to different depths
                    wingPhase: Math.random() * Math.PI * 2
                });
            }
        }

        // Motion trail
        if (trailLength > 0) {
            const bgStyle = BACKGROUND_STYLES[this.settings.background];
            const color = bgStyle.color;

            if (this.settings.background === 'transparent') {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = `rgba(0, 0, 0, ${trailLength * 0.3})`;
            } else {
                this.ctx.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${trailLength})`;
            }
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        } else {
            this.drawBackground();
        }

        const time = (this.frameCounter || 0) * 0.02 * diveSpeed;

        // Draw diving seagulls
        for (let i = 0; i < this.divingSeagulls.length; i++) {
            const bird = this.divingSeagulls[i];
            const magnitude = magnitudes[i % magnitudes.length];

            // Update phases
            bird.phase += 0.02 * diveSpeed * (1 + bass * 0.5);
            bird.wingPhase += (0.4 + treble * 0.3);

            // Diving arc motion - spread across entire canvas
            const diveProgress = (Math.sin(bird.phase) + 1) / 2;
            // Wrap x position around canvas width for continuous movement
            const x = (bird.offsetX + (time * 30 * (0.8 + i * 0.05))) % this.canvas.width;
            // Use varied y positions across full height
            const yTop = bird.offsetY;
            const yBottom = bird.offsetY + this.canvas.height * bird.diveDepth;
            const y = yTop + (yBottom - yTop) * (1 - Math.abs(Math.cos(bird.phase)));

            // Wing flapping
            const wingFlap = Math.sin(bird.wingPhase) * 0.4 + 0.6;
            const currentWingSpan = wingSpan * wingFlap;

            // Calculate heading for dive
            const heading = Math.atan2(Math.sin(bird.phase), 1) * 0.5;

            // Color
            const batColor = this.getColor(i, this.divingSeagulls.length);
            const match = batColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            let r = 240, g = 240, b = 240;
            if (match) {
                r = parseInt(match[1]);
                g = parseInt(match[2]);
                b = parseInt(match[3]);
            }

            const opacity = 0.7 + magnitude * 0.3;
            const birdSize = 1.0 + magnitude * 0.3;

            this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
            this.ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
            this.ctx.lineWidth = 2 * birdSize;
            this.ctx.shadowBlur = 10;
            this.ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.5)`;

            // Draw seagull
            this.ctx.save();
            this.ctx.translate(x, y);
            this.ctx.rotate(heading);

            // Draw wings
            this.ctx.beginPath();
            this.ctx.moveTo(-currentWingSpan, 2);
            this.ctx.quadraticCurveTo(-currentWingSpan * 0.5, -6 * birdSize, -2 * birdSize, -3 * birdSize);
            this.ctx.lineTo(0, -5 * birdSize);
            this.ctx.lineTo(2 * birdSize, -3 * birdSize);
            this.ctx.quadraticCurveTo(currentWingSpan * 0.5, -6 * birdSize, currentWingSpan, 2);
            this.ctx.stroke();

            // Body
            this.ctx.beginPath();
            this.ctx.arc(0, 0, 2.5 * birdSize, 0, Math.PI * 2);
            this.ctx.fill();

            this.ctx.restore();
        }

        this.ctx.shadowBlur = 0;
        this.frameCounter = (this.frameCounter || 0) + 1;
    }

    /**
     * Mode 1007: Sparrow Scatter
     * Small birds that scatter explosively on bass, then regroup
     */
    render1007SparrowScatter(magnitudes) {
        const params = this.settings.modeParameters || {};
        const birdCount = params.birdCount || 50;
        const wingSpan = (params.wingSpan || 8) * this.scaleFactor;
        const scatterRadius = (params.scatterRadius || 120) * this.scaleFactor;
        const bassThreshold = params.bassThreshold || 0.4;
        const trailLength = params.trailLength !== undefined ? params.trailLength : 0.1;

        const bass = magnitudes.slice(0, Math.floor(magnitudes.length / 4)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length / 4);
        const treble = magnitudes.slice(Math.floor(magnitudes.length * 0.75)).reduce((a, b) => a + b, 0) / Math.floor(magnitudes.length * 0.25);
        const energy = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;

        // Initialize sparrows
        if (!this.sparrowBirds || this.sparrowBirds.length !== birdCount) {
            this.sparrowBirds = [];
            for (let i = 0; i < birdCount; i++) {
                const angle = (i / birdCount) * Math.PI * 2;
                this.sparrowBirds.push({
                    x: this.centerX + Math.cos(angle) * 50,
                    y: this.centerY + Math.sin(angle) * 50,
                    vx: 0,
                    vy: 0,
                    scatterAngle: angle,
                    wingPhase: Math.random() * Math.PI * 2
                });
            }
            this.lastScatterTime = 0;
        }

        // Motion trail
        if (trailLength > 0) {
            this.ctx.fillStyle = `rgba(0, 0, 0, ${trailLength})`;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        } else {
            this.drawBackground();
        }

        // Bass causes scatter
        const shouldScatter = bass > bassThreshold && ((this.frameCounter || 0) - this.lastScatterTime) > 40;
        if (shouldScatter) {
            this.lastScatterTime = this.frameCounter || 0;
            // Randomize scatter angles
            this.sparrowBirds.forEach(bird => {
                bird.scatterAngle = Math.random() * Math.PI * 2;
            });
        }

        // Update each bird
        for (let i = 0; i < this.sparrowBirds.length; i++) {
            const bird = this.sparrowBirds[i];
            const magnitude = magnitudes[i % magnitudes.length];

            // Scatter/regroup behavior
            const scatterForce = shouldScatter ? 10 : 0;
            const targetX = this.centerX + Math.cos(bird.scatterAngle) * scatterRadius * bass;
            const targetY = this.centerY + Math.sin(bird.scatterAngle) * scatterRadius * bass;

            // Move towards target (regroup)
            const dx = targetX - bird.x;
            const dy = targetY - bird.y;
            bird.vx += dx * 0.02;
            bird.vy += dy * 0.02;

            // Add scatter impulse
            if (shouldScatter) {
                bird.vx += Math.cos(bird.scatterAngle) * scatterForce;
                bird.vy += Math.sin(bird.scatterAngle) * scatterForce;
            }

            // Damping
            bird.vx *= 0.95;
            bird.vy *= 0.95;

            // Update position
            bird.x += bird.vx;
            bird.y += bird.vy;

            // Keep within bounds (soft)
            if (bird.x < 0) bird.vx += 1;
            if (bird.x > this.canvas.width) bird.vx -= 1;
            if (bird.y < 0) bird.vy += 1;
            if (bird.y > this.canvas.height) bird.vy -= 1;

            // Wing flapping (faster with treble and when scattering)
            bird.wingPhase += (0.5 + treble * 0.3 + (shouldScatter ? 1 : 0));
            const wingFlap = Math.sin(bird.wingPhase) * 0.4 + 0.6;
            const currentWingSpan = wingSpan * wingFlap;

            // Heading based on velocity
            const heading = Math.atan2(bird.vy, bird.vx);

            // Color
            const batColor = this.getColor(i, this.sparrowBirds.length);
            const match = batColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            let r = 139, g = 90, b = 60;
            if (match) {
                r = parseInt(match[1]);
                g = parseInt(match[2]);
                b = parseInt(match[3]);
            }

            const opacity = 0.7 + magnitude * 0.3;
            const birdSize = 0.8 + magnitude * 0.2;

            this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
            this.ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
            this.ctx.lineWidth = 1.5 * birdSize;
            this.ctx.shadowBlur = 5;
            this.ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.5)`;

            // Draw sparrow
            this.ctx.save();
            this.ctx.translate(bird.x, bird.y);
            this.ctx.rotate(heading);

            // Small wings
            this.ctx.beginPath();
            this.ctx.moveTo(-currentWingSpan, 1);
            this.ctx.quadraticCurveTo(-currentWingSpan * 0.5, -4 * birdSize, -1.5 * birdSize, -2 * birdSize);
            this.ctx.lineTo(0, -3 * birdSize);
            this.ctx.lineTo(1.5 * birdSize, -2 * birdSize);
            this.ctx.quadraticCurveTo(currentWingSpan * 0.5, -4 * birdSize, currentWingSpan, 1);
            this.ctx.stroke();

            // Small body
            this.ctx.beginPath();
            this.ctx.arc(0, 0, 1.8 * birdSize, 0, Math.PI * 2);
            this.ctx.fill();

            this.ctx.restore();
        }

        this.ctx.shadowBlur = 0;
        this.frameCounter = (this.frameCounter || 0) + 1;
    }

    dispose() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
        this.clear();
    }
}
